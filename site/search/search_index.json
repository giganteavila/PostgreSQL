{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PostgreSQL","text":""},{"location":"#que-es-postgresql","title":"Qu\u00e9 es PostgreSQL?","text":"<p>PostgreSQL es un potente sistema de bases de datos de c\u00f3digo abierto que utiliza y extiende el lenguaje SQL combinado con muchas caracter\u00edsticas que almacenan y escalan las cargas de datos m\u00e1s complicadas. Los or\u00edgenes de PostgreSQL se remontan a 1986 como parte del proyecto POSTGRES en la Universidad de California en Berkeley y tiene m\u00e1s de 35 a\u00f1os de desarrollo activo en la plataforma central.</p> <p>PostgreSQL se ha ganado una s\u00f3lida reputaci\u00f3n por su arquitectura probada, fiabilidad, integridad de datos, conjunto de caracter\u00edsticas robustas, extensibilidad y la dedicaci\u00f3n de la comunidad de c\u00f3digo abierto detr\u00e1s del software para ofrecer constantemente soluciones eficaces e innovadoras. PostgreSQL se ejecuta en todos los principales sistemas operativos, ha sido compatible con ACID desde 2001, y tiene potentes complementos como el popular extensor de bases de datos geoespaciales PostGIS. No es de extra\u00f1ar que PostgreSQL se haya convertido en la base de datos relacional de c\u00f3digo abierto de elecci\u00f3n para muchas personas y organizaciones.</p> <p>Empezar con el uso de PostgreSQL nunca ha sido m\u00e1s f\u00e1cil: elige un proyecto que quieres construir, y deja que PostgreSQL almacene de forma segura y robusta tus datos.</p>"},{"location":"#por-que-usar-postgresql","title":"Por qu\u00e9 usar PostgreSQL?","text":"<p>PostgreSQL viene con muchas caracter\u00edsticas destinadas a ayudar a los desarrolladores a construir aplicaciones, administradores para proteger la integridad de los datos y construir entornos tolerantes a fallos, y ayudarle a administrar sus datos sin importar el conjunto de datos tan grande o peque\u00f1o. Adem\u00e1s de ser de c\u00f3digo libre y abierto, PostgreSQL es muy extensible. Por ejemplo, puede definir sus propios tipos de datos, construir funciones personalizadas, incluso escribir c\u00f3digo de diferentes lenguajes de programaci\u00f3n sin recompilar su base de datos.</p> <p>PostgreSQL trata de ajustarse al est\u00e1ndar SQL donde tal conformidad no contradice las caracter\u00edsticas tradicionales o podr\u00eda conducir a malas decisiones arquitect\u00f3nicas. Muchas de las caracter\u00edsticas requeridas por el est\u00e1ndar SQL son compatibles, aunque a veces con una sintaxis o funci\u00f3n ligeramente diferente. Se pueden esperar nuevos pasos hacia la conformidad con el tiempo. A partir de la versi\u00f3n 16 de septiembre de 2023, PostgreSQL se ajusta al menos a 170 de las 179 funciones obligatorias para la conformidad del n\u00facleo SQL:2023. A partir de este escrito, ninguna base de datos relacional cumple con toda la conformidad con esta norma.</p> <p>A continuaci\u00f3n se muestra una lista no exhaustiva de varias caracter\u00edsticas que se encuentran en PostgreSQL, se a\u00f1aden m\u00e1s en cada versi\u00f3n importante:</p> <ul> <li>Tipos de datos<ul> <li>Primitivas: entero, num\u00e9rico, cadena, booleano</li> <li>Estructurado: Fecha/hora, Array, Range / Multirange, UUID</li> <li>Documento: JSON/JSONB, XML, Clave-valor (Hstore)</li> <li>Geometr\u00eda: Punto, L\u00ednea, C\u00edrculo, Pol\u00edgono</li> <li>Personalizaciones: Composite, Tipos personalizados</li> </ul> </li> <li>Integridad de los datos<ul> <li>UNIQUE, NO NULL</li> <li>Claves primarias</li> <li>Claves for\u00e1neas</li> <li>Restricciones de exclusi\u00f3n</li> <li>Explicit Locks, Advisory Locks</li> </ul> </li> <li>Concurrencia, Rendimiento<ul> <li>Indizaci\u00f3n: \u00c1rbol B, Multicolumna, Expresiones, Partial</li> <li>Indizaci\u00f3n avanzada: GiST, SP-Gist, KNN Gist, GIN, BRIN, Covering indexes, Bloom filters</li> <li>Sofisticado planificador de consultas/optimizador, escaneos de solo \u00edndice, estad\u00edsticas multicolumna</li> <li>Transacciones, Operaciones anidadas (a trav\u00e9s de puntos de ahorro)</li> <li>Control de concurrencia Multi-Versi\u00f3n (MVCC)</li> <li>Paralelizaci\u00f3n de las consultas de lectura y la construcci\u00f3n de \u00edndices de \u00e1rbol B</li> <li>Particionado de tablas</li> <li>Todos los niveles de aislamiento de las transacciones definidos en la norma SQL, incluyendo Serializable</li> <li>Compilati\u00f3n de expresiones Just-In-Time (JIT)</li> </ul> </li> <li>Fiabilidad, Recuperaci\u00f3n de Desastres</li> <li>Write-ahead Logging (WAL)</li> <li>Replication: Asynchronous, Synchronous, Logical</li> <li>Point-in-time-recovery (PITR), active standbys</li> <li>Tablespaces</li> <li>Seguridad<ul> <li>Autenticaci\u00f3n: GSSAPI, SSPI, LDAP, SCRAM-SHA-256, Certificado, y m\u00e1s</li> <li>Sistema de control de acceso robusto</li> <li>Seguridad a nivel de columna y fila</li> <li>La autenticaci\u00f3n multifactor con certificados y un m\u00e9todo adicional</li> </ul> </li> <li>Extensibilidad<ul> <li>Funciones y procedimientos almacenados</li> <li>Lenguajes procedurales: PL/pgSQL, Perl, Python y Tcl. Hay otros lenguajes disponibles a trav\u00e9s de extensiones, por ejemplo. Java, JavaScript (V8), R, Lua y Rust</li> <li>Constructores SQL/JSON y expresiones de ruta</li> <li>Envoltorios de datos extranjeros: con\u00e9ctese a otras bases de datos o flujos con una interfaz SQL est\u00e1ndar</li> <li>Interfaz de almacenamiento personalizable para tablas</li> <li>Muchas extensiones que proporcionan funcionalidad adicional, incluyendo PostGIS</li> </ul> </li> <li>Internacionalizaci\u00f3n, B\u00fasqueda de Texto<ul> <li>Apoyo a conjuntos internacionales de caracteres, por ejemplo, a trav\u00e9s de las recopilaciones de la UCI</li> <li>Cifras de casos insensibles e insensibles a los acentos</li> <li>B\u00fasqueda de texto completo</li> </ul> </li> </ul> <p>Hay muchas m\u00e1s caracter\u00edsticas que se pueden descubrir en la documentaci\u00f3n PostgreSQL. Adem\u00e1s, PostgreSQL es altamente extensible: muchas caracter\u00edsticas, como los \u00edndices, tienen API definidas para que se pueda construir con PostgreSQL tus desaf\u00edos.</p> <p>PostgreSQL ha demostrado ser altamente escalable tanto en la cantidad de datos que puede gestionar y en el n\u00famero de usuarios concurrentes que puede acomodarse. Hay cl\u00fasteres activos PostgreSQL en entornos de producci\u00f3n que manejan muchos terabytes de datos, y sistemas especializados que manejan petabytes.</p>"},{"location":"#alguna-pregunta","title":"Alguna pregunta?","text":"<p>El primer lugar al que acudir para cualquier pregunta en PostgreSQL es su documentaci\u00f3n de renombre mundial que discute c\u00f3mo usar PostgreSQL en profundidad.</p> <p>Tambi\u00e9n hay muchas listas de correo donde te puedes conectar y participar en la comunidad. Tambi\u00e9n hay muchos eventos y grupos de usuarios locales donde te puedes conectar con otros usuarios de PostgreSQL.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/","title":"01.-Instalaci\u00f3n","text":"<p>Antes de poder usar PostgreSQL necesitamos instalarlo, por supuesto. Es posible que PostgreSQL ya est\u00e9 instalado, ya sea porque estaba incluido en la distribuci\u00f3n de nuestro sistema operativo o porque el administrador del sistema ya lo instal\u00f3. Si ese es el caso, debemos obtener informaci\u00f3n de la documentaci\u00f3n del sistema operativo o del administrador del sistema sobre c\u00f3mo acceder a PostgreSQL.</p> <p>Si no se est\u00e1 seguro de si PostgreSQL ya est\u00e1 disponible o si se puede utilizar para experimentaci\u00f3n, entonces puedemos instalarlo nosotros mismos. Hacerlo no es dif\u00edcil y puede ser un buen ejercicio. PostgreSQL puede ser instalado por cualquier usuario no privilegiado; no se requiere acceso al superusuario (root).</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion-en-arch-linux","title":"Instalaci\u00f3n en Arch Linux","text":""},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#resumen","title":"Resumen","text":"<pre><code>$ sudo pacman -S postgresql\n$ postgres --version\n$ sudo -iu postgres\n$ initdb -D /var/lib/postgres/data\n$ sudo vim /var/lib/postgress/data/postgresql.conf\n\n    # Agregaremos/modificaremos la siguiente linea\n\n       listen_addresses = '*'\n\n$ ip addr | grep inet\n$ sudo vim /var/lib/postgres/data/pg_hba.conf\n\n# Dentro del archivo, encontrar las siguientes l\u00edneas...\n\n    # TYPE  DATABASE        USER            ADDRESS                 METHOD\n    # \"local\" is for Unix domain socket connections only\n    local   all             user                                    trust\n\n    # Agrega la siguiente linea en donde\n    # reemplazar xxx.xxx.xxx.xxx/xx por su direcci\u00f3n IP\n    host    all             all             xxx.xxx.xxx.xxx/xx      md5\n\n$ sudo passwd postgres\n$ sudo -iu postgres\n\n# Dentro...\n[postgres]$ psql\n[postgres]$ ALTER USER postgres WITH password 'xxxx';\n# En las 'xxxx' pondremos nuestra contrase\u00f1a\n\n\n$ sudo systemctl start postgresql.service\n$ sudo systemctl enable postgresql.service\n$ sudo systemctl status postgresql.service\n\n# Habilitar el hist\u00f3rico /var/lib/postgres/.psql_history\n#\n# Debemos crear los ficheros .psql_history y .bashrc en /var/lib/postgres\n# y hacerlos pertenecer al usuario \"postgres\" y al grupo \"postgres\"\n\n$ sudo touch /var/lib/postgres/.bashrc\n$ sudo touch /var/lib/postgres/.psql_history\n$ sudo chown postgres:postgres /var/lib/postgres/.bashrc\n$ sudo chown postgres:postgres /var/lib/postgres/.psql_history\n$ sudo chmod 644 /var/lib/postgres/.bashrc\n$ sudo chmod 644 /var/lib/postgres/.psql_history\n\n# Cargar la variable de entorno PSQL_HISTORY con el fichero .psql_history\n# y exportarla para hacerlo permanente en .bashrc\n\n$ sudo -iu postgres\n$ echo 'export PSQL_HISTORY=/var/lib/postgres/.psql_history' &gt;&gt; /var/lib/postgres/.bashrc\n</code></pre>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion-desde-los-binarios","title":"Instalaci\u00f3n desde los binarios","text":"<p>Si el administrador de no ha establecido las cosas de la manera predeterminada, es posible que tengamos algo m\u00e1s de trabajo que hacer. Por ejemplo, si la m\u00e1quina de servidor de base de datos es una m\u00e1quina remota, tendremos que configurar la variable de entorno <code>PGHOST</code> al nombre de la m\u00e1quina servidor de bases de datos. La variable de entorno <code>PGPORT</code> tambi\u00e9n deber\u00eda que ser establecida. La conclusi\u00f3n es esta: si intentamos iniciar un programa de aplicaci\u00f3n y se queja de que no puede conectarse a la base de datos, debemos consultar al administrador del sitio o, si somos nosotros mismos, la documentaci\u00f3n para asegurarnos de que el entorno est\u00e1 correctamente configurado.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/02.-Fundamentos%20arquitect%C3%B3nicos/","title":"02.-Fundamentos arquitect\u00f3nicos","text":"<p>Antes de proceder,  debemos entender la arquitectura b\u00e1sica del sistema PostgreSQL. Entender c\u00f3mo interact\u00faan entre s\u00ed las partes de PostgreSQL har\u00e1 este cap\u00edtulo algo m\u00e1s claro.</p> <p>En la jerga de bases de datos, PostgreSQL utiliza un modelo cliente/servidor. Una sesi\u00f3n de PostgreSQL consiste en los siguientes procesos de cooperaci\u00f3n (programas):</p> <ul> <li> <p>Un proceso de servidor, que administra los archivos de la base de datos, acepta conexiones a la base de datos de aplicaciones de clientes y realiza acciones de base de datos en nombre de los clientes. El programa de servidores de bases de datos se llama <code>postgres</code>.</p> </li> <li> <p>La aplicaci\u00f3n cliente (frontend) del usuario que quiere realizar operaciones de base de datos. Las aplicaciones de cliente pueden ser de muy diversa naturaleza: un cliente podr\u00eda ser una herramienta orientada al texto, una aplicaci\u00f3n gr\u00e1fica, un servidor web que acceda a la base de datos para mostrar p\u00e1ginas web, o una herramienta especializada de mantenimiento de bases de datos. Algunas aplicaciones de clientes se suministran con la distribuci\u00f3n PostgreSQL; la mayor\u00eda son desarrolladas por los usuarios.</p> </li> </ul> <p>Como es t\u00edpico de las aplicaciones cliente/servidor, el cliente y el servidor pueden estar en diferentes hosts. En ese caso se comunican a trav\u00e9s de una conexi\u00f3n de red TCP/IP.  Debemos tener esto en cuenta, porque los archivos a los que se puede acceder en una m\u00e1quina cliente pueden no ser accesibles (o s\u00f3lo podr\u00edan ser accesibles usando un nombre de archivo diferente) en la m\u00e1quina del servidor de bases de datos.</p> <p>El servidor PostgreSQL puede manejar m\u00faltiples conexiones simult\u00e1neas de los clientes. Para lograrlo comienza un nuevo proceso (\"forks\")  para cada conexi\u00f3n. A partir de ese momento, el cliente y el nuevo proceso de servidor se comunican sin la intervenci\u00f3n del proceso original <code>postgres</code>. Por lo tanto, el proceso de servidor supervisor siempre est\u00e1 funcionando, esperando conexiones de clientes, mientras que los procesos de servidor asociados y el cliente van y vienen. (Todo esto es, por supuesto, invisible para el usuario. S\u00f3lo lo mencionamos aqu\u00ed para estar al tanto.)</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/03.-Creando%20una%20Base%20de%20Datos/","title":"03.-Creando una Base de Datos","text":"<p>La primera prueba para ver si puede acceder al servidor de base de datos es tratar de crear una base de datos. Un servidor PostgreSQL en ejecuci\u00f3n puede administrar muchas bases de datos. Normalmente, se utiliza una base de datos separada para cada proyecto o para cada usuario.</p> <p>Posiblemente, el administrador de tu sitio ya ha creado una base de datos para nuestro uso. En ese caso puedes omitir este paso y saltar a la siguiente secci\u00f3n.</p> <p>Para crear una nueva base de datos, en este ejemplo nombrada <code>mydb</code>, se utiliza el siguiente comando:</p> <pre><code>$ createdb mydb\n</code></pre> <p>Si esto no produce respuesta, este paso fue exitoso y se puede saltar el resto de esta secci\u00f3n.</p> <p>Si ves un mensaje similar a:</p> <pre><code>createdb: comando no encontrado\n</code></pre> <p>Entonces PostgreSQL no se instal\u00f3 correctamente. O no se instal\u00f3 en absoluto o la ruta de b\u00fasqueda de su shell no estaba configurada para incluirlo. Llamaremos al comando con un camino absoluto en su lugar:</p> <pre><code>$/usr/local/pgsql/bin/createdb mydb\n</code></pre> <p>El camino en nuestro sitio podr\u00eda ser diferente (<code>/usr/bin/createdb mydb</code> en archlinux). El administrador del sitio o las instrucciones de instalaci\u00f3n puede ayudarnos a corregir la situaci\u00f3n.</p> <p>Otra respuesta podr\u00eda ser esta:</p> <pre><code>createdb: error: connection to server on socket \"/tmp/.s.PGSQL.5432\" failed: No such file or directory\n        Is the server running locally and accepting connections on that socket?\n</code></pre> <p>Esto significa que el servidor no se inici\u00f3, o no est\u00e1 escuchando d\u00f3nde <code>createdb</code>espera contactarlo. Una vez m\u00e1s, revise las instrucciones de instalaci\u00f3n o consulte al administrador.</p> <p>Otra respuesta podr\u00eda ser esta:</p> <pre><code>createdb: error: connection to server on socket \"/tmp/.s.PGSQL.5432\" failed: FATAL:  role \"joe\" does not exist\n</code></pre> <p>donde se menciona nuestro propio nombre de inicio de sesi\u00f3n. Esto suceder\u00e1 si el administrador no ha creado una cuenta de usuario de PostgreSQL para nosotros. (Las cuentas de usuario de PostgreSQL son distintas de las cuentas de usuario del sistema operativo.) Si somos el administrador, consultar el cap\u00edtulo 22 para ayudar en la creaci\u00f3n de cuentas. Debemos convertirnos en el usuario del sistema operativo bajo el cual PostgreSQL fue instalado (generalmente <code>postgres</code>) para crear la primera cuenta de usuario. Tambi\u00e9n podr\u00eda ser que se nos asign\u00f3 un nombre de usuario de PostgreSQL que es diferente de nuestro nombre de usuario de nuestro sistema operativo; en ese caso necesitamos utilizar la opci\u00f3n <code>-U</code> o configurar la variable de entorno <code>PGUSER</code> para especificar nuestro nombre de usuario de PostgreSQL.</p> <p>Si tenemos una cuenta de usuario pero no tiene los privilegios necesarios para crear una base de datos, veremos lo siguiente:</p> <pre><code>createdb: error: database creation failed: ERROR:  permission denied to create database\n</code></pre> <p>No todos los usuarios tienen autorizaci\u00f3n para crear nuevas bases de datos. Si PostgreSQL se niega a crear bases de datos para nosotros, entonces el administrador del sitio necesita concedenos permiso para crear bases de datos. Consultaremos a nuestro administrador del sitio si esto ocurre. Si hemos instalado PostgreSQL nosotros mismos, entonces debemos iniciar sesi\u00f3n bajo la cuenta de usuario con la que iniciamos el servidor. </p> <p>Tambi\u00e9n podemos crear bases de datos con otros nombres. PostgreSQL nos permite crear cualquier n\u00famero de bases de datos en un sitio determinado. Los nombres de la base de datos deben tener un primer car\u00e1cter alfab\u00e9tico y se limitan a 63 bytes de longitud. Una opci\u00f3n conveniente es crear una base de datos con el mismo nombre que nuestro nombre de usuario actual. Muchas herramientas asumen ese nombre de base de datos como predeterminado, por lo que puede ahorrarnos algo de escritura. Para crear esa base de datos, simplemente escribiremos:</p> <pre><code>$ createdb\n</code></pre> <p>Si ya no queremos usar tu base de datos, podemos eliminarla. Por ejemplo, si somos el propietario (creador) de la base de datos <code>mydb</code>, podemos destruirla usando el siguiente comando:</p> <pre><code>$ dropdb mydb\n</code></pre> <p>(Para este comando, el nombre de la base de datos no predetermina el nombre de la cuenta de usuario. Siempre tienes que especificarlo.) Esta acci\u00f3n elimina f\u00edsicamente todos los archivos asociados con la base de datos y no se puede deshacer, por lo que debe hacerse con mucho cuidado.</p> <p>M\u00e1s sobre <code>createdb</code>y <code>dropdb</code>se puede encontrar en createdb y dropdb respectivamente.</p> <p>Nota aclaratoria: Los nombres de usuario est\u00e1n separados de las cuentas de usuario del sistema operativo. Cuando nos conectamos a una base de datos, se puede elegir con qu\u00e9 nombre de usuario de PostgreSQL nos conectamos; si no lo hacemos, se predeterminar\u00e1 al mismo nombre de nuestra cuenta actual del sistema operativo. Sucede que siempre habr\u00e1 una cuenta de usuario de PostgreSQL que tenga el mismo nombre que el usuario del sistema operativo que inici\u00f3 el servidor, y tambi\u00e9n sucede que ese usuario siempre tiene permiso para crear bases de datos. En lugar de iniciar sesi\u00f3n como ese usuario tambi\u00e9n se puede especificar opci\u00f3n <code>-U</code>opci\u00f3n en todas partes para seleccionar un nombre de usuario de PostgreSQL con el que conectarse.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/04.-Accediendo%20a%20una%20base%20de%20datos/","title":"04.-Accediendo a una base de datos","text":"<p>Una vez que se haya creado una base de datos, podemos acceder a ella...:</p> <ul> <li> <p>Ejecutando el programa de terminal interactivo PostgreSQL, llamado <code>psql</code>, que nos permite entrar, editar y ejecutar interactivamente comandos SQL.</p> </li> <li> <p>Usando una herramienta web existente como <code>pgAdmin</code> o una suite de oficina con soporte para <code>ODBC</code> o <code>JDBC</code>  para crear y manipular una base de datos. Estas posibilidades no las cubriremos por ahora.</p> </li> <li> <p>Escribiendo una aplicaci\u00f3n personalizada, utilizando una de las varias conexiones con diferentes lenguajes disponibles como pgSQL, Python, Tcl y Perl. Estas posibilidades se examinar\u00e1n m\u00e1s adelante.</p> </li> </ul> <p>Vamos a empezar con <code>psql</code> para probar los ejemplos. Se puede activar para la base de datos <code>mydb</code> escribiendo el comando:</p> <pre><code>$ psql mydb\n</code></pre> <p>Si no suministramos el nombre de la base de datos, se presupone el nombre de la cuenta de usuario. Ya descubrimos este esquema en la secci\u00f3n anterior usando <code>createdb</code>.</p> <p>En <code>psql</code>, nos recibir\u00e1 el siguiente mensaje:</p> <pre><code>psql (16.0)\nEscriba \"ayuda\" para ayuda.\n\nmydb=&gt;\n</code></pre> <p>La \u00faltima l\u00ednea tambi\u00e9n podr\u00eda ser:</p> <pre><code>mydb=#\n</code></pre> <p>Eso significar\u00eda que somos un superusuario de la base de datos, que ser\u00e1 el caso m\u00e1s probable ya que nosotros fuimos los instaladores de la instancia PostgreSQL. Ser superusuario significa no estar sujeto a controles de acceso. Por ahora no es un hecho importante.</p> <p>Si hay problemas de inicio con <code>psql</code> volveremos a la secci\u00f3n anterior. El diagn\u00f3stico de <code>createdb</code>y <code>psql</code>son similares, y si el primero funcionaba, el segundo deber\u00eda funcionar tambi\u00e9n.</p> <p>La \u00faltima l\u00ednea impresa por <code>psql</code>es el prompt, e indica que <code>psql</code> nos est\u00e1 escuchando y que podemos empezar a escribir consultas SQL en un espacio de trabajo mantenido por <code>psql</code>. Prueba estos comandos:</p> <pre><code>mydb=&gt; SELECT version();\n                                         versi\u00f3n\n-------------------------------------------------------------------------------\n PostgreSQL 16.0 on x86o64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\n(1 fila) \n\nmydb=&gt; SELECT current_date;\n current_date\n--------------\n 2023-10-19\n(1 row)\n\n\nmydb=&gt; SELECT 2 + 2;\n ?column?\n----------\n        4\n(1 row)\n</code></pre> <p>El programa  <code>psql</code> tiene una serie de comandos internos que no son comandos SQL. Comienzan con el car\u00e1cter, <code>\\</code>. Por ejemplo, podemos obtener ayuda en la sintaxis de varios comandos PostgreSQL SQL escribiendo:</p> <pre><code>mydb=&gt; \\h\n</code></pre> <p>Para salir de <code>psql</code>, escribiremos:</p> <pre><code>mydb=&gt; \\q\n</code></pre> <p>y <code>psql</code> nos devolver\u00e1 a nuestra l\u00ednea de comandos habitual. (Para m\u00e1s comandos internos, escribir <code>\\?</code>en el prompt <code>psql</code>). Todas la capacidades de <code>psql</code>est\u00e1n documentadas . No usaremos estas caracter\u00edsticas expl\u00edcitamente, pero podemos usarlas cuando sea preciso.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>Este cap\u00edtulo ofrece una visi\u00f3n general de c\u00f3mo utilizar SQL para realizar operaciones sencillas. Solo se tiene la intenci\u00f3n de dar una introducci\u00f3n y no es de ninguna manera un tutorial completo sobre SQL. Se han escrito numerosos libros sobre SQL, incluyendo [melt93] y [DATE97].  Debemos ser conscientes de que algunas caracter\u00edsticas del lenguaje PostgreSQL son extensiones del est\u00e1ndar.</p> <p>En los ejemplos que siguen, asumimos que se ha creado una base de datos nombrada <code>mydb</code> y se ha podido iniciar <code>psql</code>.</p> <p>Los ejemplos de este manual tambi\u00e9n se pueden encontrar en la distribuci\u00f3n de la fuente PostgreSQL en el directorio <code>src/tutorial/</code>. (Las distribuciones en binario de PostgreSQL podr\u00edan no proporcionar esos archivos). Para usar esos archivos, primero cambiaremos a ese directorio y ejecutaremos <code>make</code>:</p> <pre><code>$ cd .../src/tutorial\n$ make\n</code></pre> <p>Esto crea los scripts y compila los archivos C que contienen funciones y tipos definidos por el usuario. Luego, para iniciar el tutorial, haga lo siguiente:</p> <pre><code>$ psql -s mydb\n\n...\n\nmydb=&gt; \\i basics.sql\n</code></pre> <p>El comando <code>\\i</code> lee entre los comandos del archivo especificado.  La opci\u00f3n <code>-s</code> de <code>psql</code> nos pondr\u00e1 en el modo single step el cual se detiene antes de enviar cada declaraci\u00f3n al servidor. Los comandos utilizados en esta secci\u00f3n est\u00e1n en el archivo <code>basics.sql</code>.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/02.-Conceptos/","title":"02.-Conceptos","text":"<p>PostgreSQL es un sistema de gesti\u00f3n relacional de bases de datos (RDBMS - Relational Data Base Management System). Eso significa que es un sistema para gestionar los datos almacenados en relaciones. La relaci\u00f3n es esencialmente un t\u00e9rmino matem\u00e1tico para la tabla. La noci\u00f3n de almacenar datos en tablas es tan com\u00fan hoy d\u00eda que puede parecer inherentemente obvio, pero hay una serie de otras formas de organizar bases de datos. Los archivos y directorios en sistemas operativos similares a Unix forman un ejemplo de una base de datos jer\u00e1rquica. Un desarrollo m\u00e1s moderno son las bases de datos orientadas a objetos.</p> <p>Cada tabla es una colecci\u00f3n de filas nombradas. Cada fila de una tabla dada tiene el mismo conjunto de columnas nombradas, y cada columna es de un tipo de datos espec\u00edfico. Mientras que las  columnas tienen un orden fijo en cada fila, es importante recordar que  SQL no garantiza el orden de las filas dentro de la tabla de ninguna manera (aunque se pueden ordenar expl\u00edcitamente para su visualizaci\u00f3n).</p> <p>Las tablas se agrupan en bases de datos, y una colecci\u00f3n de bases de datos gestionadas por una sola instancia de servidor PostgreSQL constituye un cluster de bases de datos.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/","title":"03.-Creando una nueva tabla","text":"<p>Podemos crear una nueva tabla especificando el nombre de la tabla, junto con todos los nombres de la columna y sus tipos:</p> <pre><code>CREATE TABLE weather (\n    city            varchar(80),\n    temp_lo         int,           -- low temperature\n    temp_hi         int,           -- high temperature\n    prcp            real,          -- precipitation\n    date            date\n);\n</code></pre> <p>Podemos entrar esto en  <code>psql</code> con los avances de l\u00ednea.  <code>psql</code> reconocer\u00e1 que el comando no se termina hasta el punto y coma.</p> <p>Los espacios blanco (es decir, espacios, tabuladores y avances de l\u00ednea) se pueden utilizar libremente en comandos SQL. Eso significa que podemos escribir el comando alineado de manera diferente, o incluso todo en una l\u00ednea. Los dos guiones <code>--</code> permiten presentar comentarios. Lo que les sigue es ignorado hasta el final de la l\u00ednea. SQL es insensible a las may\u00fasculas y min\u00fasculas y tambi\u00e9n sus identificadores, excepto cuando los identificadores se enmarcan con dobles comillas para preservar las may\u00fasculas/min\u00fasculas (no se hace arriba).</p> <p><code>varchar(80)</code>especifica un tipo de datos que puede almacenar cadenas de caracteres arbitrarias de hasta 80 caracteres de longitud.  </p> <p><code>int</code> es el tipo entero normal.  </p> <p><code>real</code> es un tipo para almacenar n\u00fameros de punto flotante de una sola precisi\u00f3n. </p> <p><code>date</code> debe ser autoexplicativo. (S\u00ed, la columna de tipo  <code>date</code> tambi\u00e9n se nombra <code>date</code>. Esto puede ser conveniente o confuso.)</p> <p>PostgreSQL soporta el est\u00e1ndar de tipos SQL <code>int</code>, <code>smallint</code>, <code>real</code>, <code>double precision</code>, <code>char(N)</code>, <code>varchar(N)</code>, <code>date</code>, <code>time</code>, <code>timestamp</code> y <code>interval</code>, as\u00ed como otros tipos de utilidad general y un rico conjunto de tipos geom\u00e9tricos. PostgreSQL se puede personalizar con un n\u00famero arbitrario de tipos de datos definidos por el usuario. Por lo tanto, los nombres de tipo no son  palabras clave en la sintaxis, excepto cuando sea necesario para apoyar casos especiales en el SQL est\u00e1ndar.</p> <p>El segundo ejemplo almacenar\u00e1 las ciudades y su ubicaci\u00f3n geogr\u00e1fica asociada:</p> <pre><code>CREATE TABLE cities (\n    name            varchar(80),\n    location        point\n);\n</code></pre> <p>El tipo <code>point</code> es un ejemplo de un tipo de datos PostgreSQL espec\u00edfico.</p> <p>Por \u00faltimo, debe mencionarse que si no se necesita una tabla por m\u00e1s tiempo o se desea recrearla de manera diferente se puede eliminar usando el  siguiente comando:</p> <pre><code>DROP TABLE tablename;\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#ejercicios","title":"Ejercicios","text":"<p>1.- Crear una tabla llamada <code>employees</code> con columnas para <code>id</code>, <code>first_name</code>,  <code>last_name</code>, <code>email</code> y <code>hire_date</code>. Usar los tipos de datos apropiados para cada columna.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#solucion","title":"Soluci\u00f3n","text":"<pre><code>CREATE TABLE employees (\n  id INTEGER, \n  firs_name VARCHAR(50),\n  last_name VARCHAR(50), \n  email VARCHAR(100),\n  hire_date DATE\n);\n</code></pre> <p>2.- Crea una tabla llamada <code>products</code> con las siguientes columnas:</p> <ul> <li><code>product_id</code> de tipo entero para almacenar un identificador \u00fanico para cada producto.</li> <li><code>name</code> de tipo texto para almacenar el nombre del producto.</li> <li><code>price</code> de tipo num\u00e9rico con precisi\u00f3n 10 y escala 2 para almacenar el precio del producto con 2 d\u00edgitos decimales.</li> <li><code>stock</code> de tipo entero para almacenar la cantidad en stock de ese producto.</li> <li><code>arrival_date</code> de tipo fecha para almacenar la fecha en que ese producto ingres\u00f3 al inventario.</li> </ul> <p>Utiliza los tipos de datos adecuados para cada columna.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#solucion_1","title":"Soluci\u00f3n","text":"<pre><code>CREATE TABLE products (\n  product_id INTEGER,      -- product unique indentificator\n  name VARCHAR(100),\n  price DECIMAL(10,2),     -- price in 10 digits and 2 decimals\n  stock INTEGER,\n  arrival_date DATE        -- arrival product date\n);\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/04.-Cargando%20una%20tabla%20con%20filas/","title":"04.-Cargando una tabla con filas","text":"<p>La sentencia <code>INSERT</code> se utiliza para cargar una tabla con filas:</p> <pre><code>INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');\n</code></pre> <p>Todos los tipos de datos utilizan formatos de  entrada bastante obvios. Las constantes que no son simples valores num\u00e9ricos generalmente deben estar rodeados de comillas individuales (<code>'</code>), como en el ejemplo. El tipo <code>date</code> es realmente bastante flexible en lo que acepta, pero para este  tutorial nos acogeremos al formato inequ\u00edvoco que se muestra aqu\u00ed.</p> <p>El tipo <code>point</code> requiere un par de coordenadas como entrada, como se muestra aqu\u00ed:</p> <pre><code>INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');\n</code></pre> <p>La sintaxis utilizada hasta ahora requiere recordar el orden de las columnas. Una sintaxis alternativa permite enumerar las columnas  expl\u00edcitamente:</p> <pre><code>INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');\n</code></pre> <p>Puedes listar las columnas en un orden diferente si deseas o  incluso omite algunas columnas, por ejemplo, si se desconoce la  precipitaci\u00f3n:</p> <pre><code>INSERT INTO tiempo (date, city, temp_hi, temp_lo)\n    VALUES ('1994-11-29', 'Hayward', 54, 37);\n</code></pre> <p>Muchos desarrolladores consideran que enumerar expl\u00edcitamente las columnas es m\u00e1s estiloso que confiar en el orden impl\u00edcitamente.</p> <p>Introduzcamos todos los comandos mostrados  anteriormente para que tener algunos datos con los que trabajar en las secciones siguientes.</p> <p>Tambi\u00e9n se puede usar <code>COPY</code> para cargar grandes cantidades de datos de archivos de texto plano. Esto suele ser m\u00e1s r\u00e1pido porque el comando  <code>COPY</code> est\u00e1 optimizado para esta aplicaci\u00f3n, aunque permitiendo menos flexibilidad que <code>INSERT</code>. Un ejemplo ser\u00eda:</p> <pre><code>COPY weather FROM '/home/user/weather.txt';\n</code></pre> <p>donde el nombre del archivo para el archivo fuente debe estar  disponible en la m\u00e1quina que ejecuta el proceso de backend, no en el  cliente, ya que el proceso de backend lee el archivo directamente.  Puedes leer m\u00e1s sobre el  comando <code>COPY</code> en COPY.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/05.-Consulta%20de%20tablas/","title":"05.-Consulta de tablas","text":"<p>Para recuperar datos de una tabla, se consulta; para locual utilizamos la declaraci\u00f3n SQL <code>SELECT</code>. La declaraci\u00f3n se divide en una lista de selecci\u00f3n (la parte que enumera las columnas a devolver), una lista de tablas (la parte que enumera las tablas a partir de las cuales recuperar los datos), y una calificaci\u00f3n opcional (la parte que especifica cualquier restricci\u00f3n). Por ejemplo, para recuperar todas las filas de la tabla <code>weather</code>, escribimos:</p> <pre><code>SELECT * FROM weather;\n</code></pre> <p>Aqu\u00ed  <code>*</code> es una abreviatura para todas las columnas. 1 As\u00ed que el mismo resultado ser\u00eda tenido con: </p> <pre><code>SELECT city, temp_lo, temp_hi, prcp, date FROM weather;\n</code></pre> <p>La salida debe ser:</p> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      43 |      57 |    0 | 1994-11-29\n Hayward       |      37 |      54 |      | 1994-11-29\n(3 rows)\n</code></pre> <p>Puedes escribir expresiones, no solo referencias de columna simples, en la lista de selecci\u00f3n. Por ejemplo, puede hacer:</p> <pre><code>SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;\n</code></pre> <p>Esto deber\u00eda dar:</p> <pre><code>     city      | temp_avg |    date\n---------------+----------+------------\n San Francisco |       48 | 1994-11-27\n San Francisco |       50 | 1994-11-29\n Hayward       |       45 | 1994-11-29\n(3 rows)\n</code></pre> <p>Observe c\u00f3mo el  <code>AS</code>cl\u00e1usula se utiliza para reetiquete la columna de salida. (El  <code>AS</code>la cl\u00e1usula es opcional.)</p> <p>Una consulta puede ser calificada.  <code>WHERE</code>cl\u00e1usula que especifica qu\u00e9 filas se quieren. El  <code>WHERE</code>cl\u00e1usula contiene una expresi\u00f3n booleana (valor de la verdad), y s\u00f3lo se  devuelven filas para las que la expresi\u00f3n booleana es verdadera. Los  habituales operadores booleanos (<code>AND</code>, <code>OR</code>, y <code>NOT</code>) est\u00e1n permitidos en la calificaci\u00f3n. Por ejemplo, los siguientes recuperan el clima de San Francisco en d\u00edas lluviosos:</p> <pre><code>SELECT * FROM weather\n    WHERE city = 'San Francisco' AND prcp &gt; 0.0;\n</code></pre> <p>Resultado:</p> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n(1 row)\n</code></pre> <p>Puede solicitar que los resultados de una consulta sean devueltos en orden ordenado:</p> <pre><code>SELECT * FROM weather\n    ORDER BY city;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n Hayward       |      37 |      54 |      | 1994-11-29\n San Francisco |      43 |      57 |    0 | 1994-11-29\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n</code></pre> <p>En este ejemplo, el orden de tipo no est\u00e1 completamente  especificado, y por lo que podr\u00eda obtener las filas de San Francisco en  cualquier orden. Pero siempre obtendr\u00edas los resultados mostrados arriba si lo haces:</p> <pre><code>SELECT * FROM weather\n    ORDER BY city, temp_lo;\n</code></pre> <p>Puede solicitar que se eliminen las filas duplicadas del resultado de una consulta:</p> <pre><code>SELECT DISTINCT city\n    FROM weather;\n</code></pre> <pre><code>     city\n---------------\n Hayward\n San Francisco\n(2 rows)\n</code></pre> <p>Una vez m\u00e1s, el pedido de la fila de resultados podr\u00eda variar. Usted puede asegurar resultados consistentes mediante el uso de  <code>DISTINCT</code>y  <code>ORDER BY</code>en conjunto: 2</p> <pre><code>SELECT DISTINCT city\n    FROM weather\n    ORDER BY city;\n</code></pre> <ol> <li> <p>Mientras  <code>SELECT *</code>es \u00fatil para las consultas fuera de las esposas, se considera ampliamente  mal estilo en el c\u00f3digo de producci\u00f3n, ya que a\u00f1adir una columna a la  tabla cambiar\u00eda los resultados.\u00a0\u21a9</p> </li> <li> <p>En algunos sistemas de bases de datos, incluidas versiones anteriores de PostgreSQL, la implementaci\u00f3n de  <code>DISTINCT</code> autom\u00e1ticamente ordena las filas con lo que  <code>ORDER BY</code> es innecesario. Pero esto no es requerido por el est\u00e1ndar SQL, y el PostgreSQL actual no garantiza que  <code>DISTINCT</code> haga que las filas aparezcan ordenadas.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/06.-Uniones%20de%20tablas/","title":"06.-Uniones de tablas","text":"<p>Hasta ahora, nuestras consultas s\u00f3lo han accedido a una mesa a la  vez. Las consultas pueden acceder a varias mesas a la vez, o acceder a  la misma tabla de tal manera que se est\u00e1n procesando varias filas de la  tabla al mismo tiempo. Las consultas que acceden a m\u00faltiples tablas (o  m\u00faltiples instancias de la misma mesa) en un momento se llaman a consultas de unirse. Combinan filas de una tabla con filas de una segunda tabla, con una  expresi\u00f3n que especifica qu\u00e9 filas deben ser emparejados. Por ejemplo,  para devolver todos los registros meteorol\u00f3gicos junto con la ubicaci\u00f3n  de la ciudad asociada, la base de datos necesita comparar la  <code>city</code>columna de cada hilera de la  <code>weather</code>mesa con el  <code>name</code>columna de todas las filas en el  <code>cities</code>mesa y seleccione los pares de filas donde coinciden estos valores.1 Esto se lograr\u00eda con la siguiente consulta:</p> <pre><code>SELECT * FROM weather JOIN cities ON city = name;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(2 rows)\n</code></pre> <p>Observe dos cosas sobre el conjunto de resultados:</p> <ul> <li> <p>No hay ninguna fila de resultados para la ciudad de Hayward. Esto se debe a que no hay ninguna entrada a juego en el  <code>cities</code>mesa para Hayward, as\u00ed que la uni\u00f3n ignora las filas inigualables en el  <code>weather</code>mesa. En breve veremos c\u00f3mo se arregla esto.</p> </li> <li> <p>Hay dos columnas que contienen el nombre de la ciudad. Esto es correcto porque las listas de columnas de la  <code>weather</code>y  <code>cities</code>las mesas est\u00e1n concatenadas. En la pr\u00e1ctica esto es indeseable, sin  embargo, por lo que probablemente querr\u00e1 enumerar las columnas de salida expl\u00edcitamente en lugar de usar <code>*</code>:</p> </li> </ul> <p><code>postgresql   SELECT city, temp_lo, temp_hi, prcp, date, location       FROM weather JOIN cities ON city = name;</code></p> <p>Dado que todas las columnas ten\u00edan diferentes nombres, el  analizador encontr\u00f3 autom\u00e1ticamente a qu\u00e9 tabla pertenec\u00edan. Si hubiera  nombres de columnas duplicados en las dos tablas tendr\u00edas que calificar los nombres de las columnas para mostrar cu\u00e1l se refer\u00eda, como en:</p> <pre><code>SELECT weather.city, weather.temp_lo, weather.temp_hi,\n       weather.prcp, weather.date, cities.location\n    FROM weather JOIN cities ON weather.city = cities.name;\n</code></pre> <p>Es ampliamente considerado buen estilo para calificar todos los  nombres de columna en una consulta de uni\u00f3n, de modo que la consulta no  fallar\u00e1 si un nombre de columna duplicado se a\u00f1ade m\u00e1s tarde a una de  las tablas.</p> <p>Suscr\u00edmense a las preguntas del tipo visto hasta ahora tambi\u00e9n se pueden escribir en esta forma:</p> <pre><code>SELECT *\n    FROM weather, cities\n    WHERE city = name;\n</code></pre> <p>Esta sintaxis es anterior a la <code>JOIN</code>/ <code>ON</code>sintaxis, que se introdujo en SQL-92. Las tablas se enumeran simplemente en la  <code>FROM</code>cl\u00e1usula, y la expresi\u00f3n de comparaci\u00f3n se a\u00f1ade a la  <code>WHERE</code>cl\u00e1usula. Los resultados de esta sintaxis impl\u00edcita m\u00e1s antigua y de lo m\u00e1s reciente expl\u00edcito <code>JOIN</code>/ <code>ON</code>Sintaxis son id\u00e9nticas. Pero para un lector de la consulta, la sintaxis  expl\u00edcita hace su significado m\u00e1s f\u00e1cil de entender: La condici\u00f3n de  uni\u00f3n se introduce por su propia palabra clave, mientras que  anteriormente la condici\u00f3n se mezclaba en el  <code>WHERE</code>cl\u00e1usula junto con otras condiciones.</p> <p>Ahora averiguaremos c\u00f3mo podemos conseguir los discos de Hayward. Lo que queremos que haga la consulta es es escanear el  <code>weather</code>mesa y para cada fila para encontrar la coincidencia  <code>cities</code>filas (s). Si no se encuentra ninguna fila a juego queremos que algunos valores vac\u00edos sean sustituidos por el  <code>cities</code>las columnas de la mesa. Este tipo de consulta se llama uni\u00f3n externa. (Las uniones que hemos visto hasta ahora son uniciones internas.) El comando se ve as\u00ed:</p> <pre><code>SELECT *\n    FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n Hayward       |      37 |      54 |      | 1994-11-29 |               |\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(3 rows)\n</code></pre> <p>Esta consulta se llama uni\u00f3n externa izquierda porque la tabla mencionada a la izquierda del operador de uni\u00f3n tendr\u00e1  cada una de sus filas en la salida al menos una vez, mientras que la  tabla en la derecha s\u00f3lo tendr\u00e1 esa salida de filas que coincen con  alguna fila de la tabla izquierda. Al salir de una fila de mesa  izquierda para la que no hay coincidencia de la mesa derecha, los  valores vac\u00edos (null) se sustituyen por las columnas de la mesa derecha.</p> <p>Ejercicio: Tambi\u00e9n hay uniones exteriores derechas y \u00fanete exterior completo. Intenta averiguar qu\u00e9 hacen.</p> <p>Tambi\u00e9n podemos unirnos a una mesa contra s\u00ed misma. Esto se llama unirse a s\u00ed mismo. Como ejemplo, supongamos que deseamos encontrar todos los registros  meteorol\u00f3gicos que est\u00e1n en el rango de temperatura de otros registros  meteorol\u00f3gicos. As\u00ed que tenemos que comparar el  <code>temp_lo</code>y  <code>temp_hi</code>columnas de cada uno  <code>weather</code>fila a la  <code>temp_lo</code>y  <code>temp_hi</code>columnas de todos los dem\u00e1s  <code>weather</code>filas. Podemos hacerlo con la siguiente consulta:</p> <pre><code>SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,\n       w2.city, w2.temp_lo AS low, w2.temp_hi AS high\n    FROM weather w1 JOIN weather w2\n        ON w1.temp_lo &lt; w2.temp_lo AND w1.temp_hi &gt; w2.temp_hi;\n</code></pre> <pre><code>     city      | low | high |     city      | low | high\n---------------+-----+------+---------------+-----+------\n San Francisco |  43 |   57 | San Francisco |  46 |   50\n Hayward       |  37 |   54 | San Francisco |  46 |   50\n(2 rows)\n</code></pre> <p>Aqu\u00ed hemos reetiquetado la tabla de la meteorolog\u00eda como  <code>w1</code>y  <code>w2</code>para poder distinguir el lado izquierdo y derecho de la uni\u00f3n. Tambi\u00e9n puede utilizar este tipo de alias en otras consultas para ahorrar algunos  mees, por ejemplo:</p> <pre><code>SELECT *\n    FROM weather w JOIN cities c ON w.city = c.name;\n</code></pre> <p>Usted encontrar\u00e1 este estilo de abreviatura con bastante frecuencia.</p> <ol> <li> <p>Esto es s\u00f3lo un modelo conceptual. La uni\u00f3n se realiza normalmente de una manera m\u00e1s eficiente que la comparaci\u00f3n real de cada par posible de filas, pero esto es invisible para el usuario.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/07.-Funciones%20agregadas/","title":"07.-Funciones agregadas","text":"<p>Como la mayor\u00eda de los otros productos de base de datos relacionales, PostgreSQL admite funciones agregadas. Una funci\u00f3n agregada calcula un solo resultado de m\u00faltiples filas de entrada. Por ejemplo, hay agregados para calcular la <code>count</code>, <code>sum</code>,  <code>avg</code>(promedio),  <code>max</code>(m\u00e1ximo) y  <code>min</code>(m\u00ednimo) sobre un conjunto de filas.</p> <p>Como ejemplo, podemos encontrar la lectura m\u00e1s alta a bajo temperatura en cualquier lugar con:</p> <pre><code>SELECT max(temp_lo) FROM weather;\n</code></pre> <pre><code> max\n-----\n  46\n(1 row)\n</code></pre> <p>Si quer\u00edamos saber en qu\u00e9 ciudad (o ciudades) se produjo esa lectura, podr\u00edamos intentar:</p> <pre><code>SELECT city FROM weather WHERE temp_lo = max(temp_lo);     Err\u00f3neo\n</code></pre> <p>pero esto no funcionar\u00e1 desde el agregado  <code>max</code>no se puede utilizar en el  <code>WHERE</code>cl\u00e1usula. (Esta restricci\u00f3n existe porque el  <code>WHERE</code>la cl\u00e1usula determina qu\u00e9 filas se incluir\u00e1n en el c\u00e1lculo agregado; por  lo que obviamente debe ser evaluada antes de que se computen las  funciones agregadas.) Sin embargo, como suele ocurrir, la consulta se  puede reafirmar para lograr el resultado deseado, aqu\u00ed mediante una subcoquer\u00eda:</p> <pre><code>SELECT city FROM weather\n    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);\n</code></pre> <pre><code>     city\n---------------\n San Francisco\n(1 row)\n</code></pre> <p>Esto est\u00e1 bien porque la subcoquer\u00eda es un c\u00e1lculo independiente  que calcula su propio agregado por separado de lo que est\u00e1 sucediendo en la consulta exterior.</p> <p>Los agregados tambi\u00e9n son muy \u00fatiles en combinaci\u00f3n con  <code>GROUP BY</code>cl\u00e1usulas. Por ejemplo, podemos obtener el n\u00famero de lecturas y la temperatura m\u00e1xima baja observada en cada ciudad con:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n Hayward       |     1 |  37\n San Francisco |     2 |  46\n(2 rows)\n</code></pre> <p>lo que nos da una fila de salida por ciudad. Cada resultado  agregado se calcula sobre las filas de la mesa que coinciden con esa  ciudad. Podemos filtrar estas filas agrupadas usando <code>HAVING</code>:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    GROUP BY city\n    HAVING max(temp_lo) &lt; 40;\n</code></pre> <pre><code>  city   | count | max\n---------+-------+-----\n Hayward |     1 |  37\n(1 row)\n</code></pre> <p>que nos da los mismos resultados s\u00f3lo para las ciudades que tienen todas  <code>temp_lo</code>valores inferiores a 40. Por \u00faltimo, si s\u00f3lo nos importan las ciudades cuyos nombres comienzan con<code>S</code>- Podr\u00edamos hacerlo:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    WHERE city LIKE 'S%'            -- (1)\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n San Francisco |     2 |  46\n(1 row)\n</code></pre> <p>El operador <code>LIKE</code> trabaja con patrones y se explicar\u00e1 m\u00e1s adelante.</p> <p>Es importante comprender la interacci\u00f3n entre agregados y SQLde  <code>WHERE</code>y  <code>HAVING</code>cl\u00e1usulas. La diferencia fundamental entre  <code>WHERE</code>y  <code>HAVING</code>Esto es:  <code>WHERE</code>selecciona filas de entrada antes de que se computen los grupos y agregados (por  lo tanto, controla qu\u00e9 filas van en el c\u00f3mputo agregado), mientras que  <code>HAVING</code>selecciona filas de grupo despu\u00e9s de grupos y agregados se calculan. As\u00ed, el  <code>WHERE</code>la cl\u00e1usula no debe contener funciones agregadas; no tiene sentido tratar  de utilizar un agregado para determinar qu\u00e9 filas ser\u00e1n entradas a los  agregados. Por otro lado, el  <code>HAVING</code>cl\u00e1usula siempre contiene funciones agregadas. (Estrictamente hablando, se te permite escribir un  <code>HAVING</code>cl\u00e1usula que no usa agregados, pero rara vez es \u00fatil. La misma condici\u00f3n podr\u00eda ser utilizada de manera m\u00e1s eficiente en el  <code>WHERE</code>etapa.)</p> <p>En el ejemplo anterior, podemos aplicar la restricci\u00f3n del nombre de la ciudad en <code>WHERE</code>, ya que no necesita ning\u00fan agregado. Esto es m\u00e1s eficiente que a\u00f1adir la restricci\u00f3n a <code>HAVING</code>, porque evitamos hacer la agrupaci\u00f3n y los c\u00e1lculos agregados para todas las filas que fallan el  <code>WHERE</code>compruebas.</p> <p>Otra forma de seleccionar las filas que entran en un c\u00f3mputo agregado es usar <code>FILTER</code>, que es una opci\u00f3n por agregado:</p> <pre><code>SELECT city, count(*) FILTER (WHERE temp_lo &lt; 45), max(temp_lo)\n    FROM weather\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n Hayward       |     1 |  37\n San Francisco |     1 |  46\n(2 rows)\n</code></pre> <p><code>FILTER</code>es como <code>WHERE</code>, excepto que elimina las filas s\u00f3lo de la entrada de la funci\u00f3n agregada particular a la que se une. Aqu\u00ed, el  <code>count</code>agregados s\u00f3lo cuenta filas con  <code>temp_lo</code>debajo de 45; pero el  <code>max</code>agregados se sigue aplicando a todas las filas, por lo que todav\u00eda encuentra la lectura de 46.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/08.-Actualizaciones/","title":"08.-Actualizaciones","text":"<p>Puede actualizar las filas existentes utilizando el  <code>UPDATE</code>comando. Supongamos que descubres que las lecturas de temperatura est\u00e1n todas  desactivadas en 2 grados despu\u00e9s del 28 de noviembre. Puede corregir los datos de la siguiente manera:</p> <pre><code>UPDATE weather\n    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n    WHERE date &gt; '1994-11-28';\n</code></pre> <p>Veamos el nuevo estado de los datos:</p> <pre><code>SELECT * FROM weather;\n\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n Hayward       |      35 |      52 |      | 1994-11-29\n(3 rows)\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/09.-Borrados/","title":"09.-Borrados","text":"<p>Las filas se pueden quitar de una mesa usando el  <code>DELETE</code>comando. Supongamos que ya no est\u00e1 interesado en el clima de Hayward. Entonces  puede hacer lo siguiente para eliminar esas filas de la tabla:</p> <pre><code>DELETE FROM weather WHERE city = 'Hayward';\n</code></pre> <p>Todos los registros meteorol\u00f3gicos pertenecientes a Hayward se retiran.</p> <pre><code>SELECT * FROM weather;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n(2 rows)\n</code></pre> <p>Uno debe ser cauto de las declaraciones de la forma</p> <pre><code>DELETE FROM tablename;\n</code></pre> <p>Sin una cualificaci\u00f3n,  <code>DELETE</code>eliminar\u00e1 todas las filas de la mesa dada, dej\u00e1ndola vac\u00eda. El sistema no solicitar\u00e1 confirmaci\u00f3n antes de hacer esto.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>En el cap\u00edtulo anterior hemos cubierto los fundamentos de la utilizaci\u00f3n  SQLpara almacenar y acceder a sus datos en PostgreSQL. Ahora discutiremos algunas caracter\u00edsticas m\u00e1s avanzadas de  SQLque simplifica la gesti\u00f3n y previene la p\u00e9rdida o corrupci\u00f3n de sus datos. Finalmente, veremos algunas extensiones de PostgreSQL.</p> <p>Este cap\u00edtulo se referir\u00e1 en ocasiones a los ejemplos encontrados en  para cambiarlos o mejorarlos, por lo que ser\u00e1 \u00fatil haber le\u00eddo ese  cap\u00edtulo. Algunos ejemplos de este cap\u00edtulo tambi\u00e9n se pueden encontrar  en  <code>advanced.sql</code>en el directorio de tutoriales. Este archivo tambi\u00e9n contiene algunos  datos de muestra para cargar, lo que no se repite aqu\u00ed. (Para saber la  para usar el expediente.)</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/02.-Vistas/","title":"02.-Vistas","text":"<p>Consulte de nuevo a las consultas de la Secci\u00f3n 2.6. Supongamos que la lista combinada de los registros meteorol\u00f3gicos y la  ubicaci\u00f3n de la ciudad es de particular inter\u00e9s para su aplicaci\u00f3n, pero no quiere escribir la consulta cada vez que lo necesite. Puede crear  una vista sobre la consulta, que da un nombre a la consulta que se puede referir como una tabla ordinaria:</p> <pre><code>CREATE VIEW myview AS\n    SELECT name, temp_lo, temp_hi, prcp, date, location\n        FROM weather, cities\n        WHERE city = name;\n\nSELECT * FROM myview;\n</code></pre> <p>Hacer un uso liberal de las opiniones es un aspecto clave del buen  dise\u00f1o de la base de datos SQL. Las vistas le permiten encapsular los  detalles de la estructura de sus tablas, lo que podr\u00eda cambiar a medida  que su aplicaci\u00f3n evoluciona, detr\u00e1s de interfaces consistentes.</p> <p>Las vistas se pueden utilizar en casi cualquier lugar se puede  utilizar una tabla real. Construir la vista sobre otras vistas no es  raros.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/03.-Claves%20for%C3%A1neas/","title":"03.-Claves for\u00e1neas","text":"<p>Recordemos el  <code>weather</code>y  <code>cities</code>cuadros del cap\u00edtulo 2. Considere el siguiente problema: Usted desea asegurarse de que nadie puede insertar filas en el  <code>weather</code>mesa que no tiene una entrada a juego en el  <code>cities</code>mesa. Esto se llama mantener la integridad referencial de sus datos. En los sistemas de bases de datos simplist\u00e1s esto se implementar\u00eda (si no lo hace) examinando primero la  <code>cities</code>tabla para comprobar si existe un registro de coincidencia, y luego insertar o rechazar el nuevo  <code>weather</code>Registros. Este enfoque tiene una serie de problemas y es muy inconveniente, por lo que PostgreSQL puede hacer esto por usted.</p> <p>La nueva declaraci\u00f3n de las tablas se ver\u00eda as\u00ed:</p> <pre><code>CREATE TABLE cities (\n        name     varchar(80) primary key,\n        location point\n);\n\nCREATE TABLE weather (\n        city      varchar(80) references cities(name),\n        temp_lo   int,\n        temp_hi   int,\n        prcp      real,\n        date      date\n);\n</code></pre> <p>Ahora intenta insertar un registro inv\u00e1lido:</p> <pre><code>INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');\n</code></pre> <pre><code>ERROR:  insert or update on table \"weather\" violates foreign key constraint \"weather_city_fkey\"\nDETAIL:  Key (city)=(Berkeley) is not present in table \"cities\".\n</code></pre> <p>El comportamiento de las teclas extranjeras puede estar finamente  sintonizado con su aplicaci\u00f3n. No iremos m\u00e1s all\u00e1 de este simple ejemplo en este tutorial, sino que nos referimos al  para m\u00e1s informaci\u00f3n. Hacer un uso correcto de las claves extranjeras  definitivamente mejorar\u00e1 la calidad de sus aplicaciones de base de  datos, por lo que se le anima encarecidamente a aprender sobre ellas.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/04.-Transacciones/","title":"04.-Transacciones","text":"<p>Las transacciones son un concepto fundamental de todos los sistemas de bases de datos. El punto esencial de una transacci\u00f3n es que agrupa m\u00faltiples pasos en una  operaci\u00f3n \u00fanica, todo o nada. Los estados intermedios entre los pasos no son visibles para otras transacciones simult\u00e1neas, y si se produce  alg\u00fan fallo que impide que la transacci\u00f3n se complete, entonces ninguno  de los pasos afecta a la base de datos en absoluto.</p> <p>Por ejemplo, considere una base de datos bancaria que contenga  saldos para diversas cuentas de clientes, as\u00ed como saldos totales de  dep\u00f3sitos para sucursales. Supongamos que queremos registrar un pago de  $100.00 de la cuenta de Alice a la cuenta de Bob. Simplificando  escandalosamente, los comandos SQL para esto podr\u00edan parecer:</p> <pre><code>UPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nUPDATE branches SET balance = balance - 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\nUPDATE branches SET balance = balance + 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');\n</code></pre> <p>Los detalles de estos comandos no son importantes aqu\u00ed; el punto  importante es que hay varias actualizaciones separadas involucradas para lograr esta operaci\u00f3n bastante simple. Los oficiales de nuestro banco  querr\u00e1n estar seguros de que o todas estas actualizaciones ocurren, o  ninguna de ellas sucede. Ciertamente no har\u00eda por un fallo del sistema  que result\u00f3 en que Bob recibiera $100.00 que no fue debitado de Alice.  Alice tampoco seguir\u00eda siendo una clienta feliz si fuera cargada sin que Bob fuera acreditado. Necesitamos una garant\u00eda de que si algo sale mal a lo largo de la operaci\u00f3n, ninguno de los pasos ejecutados hasta ahora  entrar\u00e1 en vigor. Agrupar las actualizaciones en una transacci\u00f3n nos da esta garant\u00eda. Se dice que una transacci\u00f3n es at\u00f3mica: desde el punto de vista de otras transacciones, o bien ocurre completamente o no en absoluto.</p> <p>Tambi\u00e9n queremos una garant\u00eda de que una vez que una transacci\u00f3n  sea completada y reconocida por el sistema de bases de datos, de hecho  se haya registrado permanentemente y no se pierda incluso si se produce  un accidente poco despu\u00e9s. Por ejemplo, si estamos grabando un retiro de efectivo por parte de Bob, no queremos ninguna posibilidad de que el  adeudo a su cuenta desaparezca en un accidente justo despu\u00e9s de salir  por la puerta del banco. Una base de datos transaccional garantiza que  todas las actualizaciones realizadas por una transacci\u00f3n se registran en el almacenamiento permanente (es decir, en el disco) antes de que se  informe de la transacci\u00f3n.</p> <p>Otra propiedad importante de las bases de datos transaccionales  est\u00e1 estrechamente relacionada con la noci\u00f3n de actualizaciones  at\u00f3micas: cuando varias transacciones se ejecutan simult\u00e1neamente, cada  una no deber\u00eda ser capaz de ver los cambios incompletos realizados por  otros. Por ejemplo, si una transacci\u00f3n est\u00e1 ocupada por un total de  todos los saldos de la sucursal, no har\u00eda para que incluyera el adeudo  de la sucursal de Alice, pero no el cr\u00e9dito a la sucursal de Bob, ni  viceversa. As\u00ed que las transacciones deben ser todo o nada no s\u00f3lo en  t\u00e9rminos de su efecto permanente en la base de datos, sino tambi\u00e9n en  t\u00e9rminos de su visibilidad a medida que suceden. Las actualizaciones  realizadas hasta ahora por una transacci\u00f3n abierta son invisibles a  otras transacciones hasta que la transacci\u00f3n se complete, con lo cual  todas las actualizaciones se hacen visibles simult\u00e1neamente.</p> <p>En PostgreSQL, una transacci\u00f3n se establece alrededor de los comandos SQL de la transacci\u00f3n con  <code>BEGIN</code>y  <code>COMMIT</code>comandos. As\u00ed que nuestra transacci\u00f3n bancaria en realidad se ver\u00eda como:</p> <pre><code>BEGIN;\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\n-- etc etc\nCOMMIT;\n</code></pre> <p>Si, a lo largo de la transacci\u00f3n, decidimos que no queremos  comprometernos (quiz\u00e1s nos acabamos de notar que el saldo de Alice sali\u00f3 negativo), podemos emitir el comando  <code>ROLLBACK</code>en vez de <code>COMMIT</code>, y todas nuestras actualizaciones hasta ahora ser\u00e1n canceladas.</p> <p>PostgreSQL realmente trata cada declaraci\u00f3n de SQL como si se ejecutara dentro de una transacci\u00f3n. Si no emites un  <code>BEGIN</code>comando, entonces cada declaraci\u00f3n individual tiene un  <code>BEGIN</code>y (si tiene \u00e9xito)  <code>COMMIT</code>Envuelto alrededor de ella. Un grupo de declaraciones rodeados de  <code>BEGIN</code>y  <code>COMMIT</code>A veces se llama bloque de transacciones.</p> <p>Nota Algunas bibliotecas clientes emiten  <code>BEGIN</code>y  <code>COMMIT</code>comandos autom\u00e1ticamente, para que pueda obtener el efecto de los bloques de  transacciones sin preguntar. Coma control la documentaci\u00f3n de la  interfaz que est\u00e1 utilizando.</p> <p>Es posible controlar las declaraciones en una transacci\u00f3n de una manera m\u00e1s granular a trav\u00e9s del uso de puntos de ahorro. Savepoints le permite descartar selectivamente partes de la  transacci\u00f3n, al tiempo que compromete el resto. Despu\u00e9s de definir un  punto de salvaci\u00f3n con <code>SAVEPOINT</code>, puede si es necesario volver al punto de salvado con <code>ROLLBACK TO</code>. Todos los cambios de base de datos de la transacci\u00f3n entre definir el  punto de reserva y volver a ella se descartan, pero los cambios antes  del punto de salvado se mantienen.</p> <p>Despu\u00e9s de volver a un punto de salva, se sigue definiendo, por lo  que puede volver a \u00e9l varias veces. Por el contrario, si usted est\u00e1  seguro de que no tendr\u00e1 que volver a un punto de salvado en particular  de nuevo, se puede liberar, por lo que el sistema puede liberar algunos  recursos. Tenga en cuenta que la liberaci\u00f3n o la vuelta a un punto de  ahorro liberar\u00e1 autom\u00e1ticamente todos los puntos de ahorro que se  definieron despu\u00e9s de \u00e9l.</p> <p>Todo esto est\u00e1 sucediendo dentro del bloque de transacciones, por  lo que nada de esto es visible para otras sesiones de base de datos.  Cuando y si usted comete el bloque de transacciones, las acciones  comprometidas se hacen visibles como una unidad a otras sesiones,  mientras que las acciones de la espalda enrollada nunca se hacen  visibles en absoluto.</p> <p>Recordando la base de datos del banco, supongamos que debitamos  $100.00 de la cuenta de Alice, y la cuenta de acreditar a Bob, s\u00f3lo para encontrar m\u00e1s tarde que deber\u00edamos haber acreditado la cuenta de Wally. Podr\u00edamos hacerlo usando puntos de ahorro como este:</p> <pre><code>BEGIN;\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nSAVEPOINT my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\n-- oops ... forget that and use Wally's account\nROLLBACK TO my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Wally';\nCOMMIT;\n</code></pre> <p>Este ejemplo es, por supuesto, demasiado simplificado, pero hay  mucho control posible en un bloque de transacciones a trav\u00e9s del uso de  puntos de ahorro. Adem\u00e1s,  <code>ROLLBACK TO</code>es la \u00fanica manera de recuperar el control de un bloque de transacciones  que fue puesto en estado abortado por el sistema debido a un error, a  falta de rodarlo completamente y empezar de nuevo.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/05.-Funciones%20de%20ventanas/","title":"05.-Funciones de ventanas","text":"<p>Una funci\u00f3n de ventana realiza un c\u00e1lculo a trav\u00e9s de un conjunto de filas de tablas que de  alguna manera est\u00e1n relacionadas con la fila actual. Esto es comparable  al tipo de c\u00e1lculo que se puede hacer con una funci\u00f3n agregada. Sin  embargo, las funciones de las ventanas no hacen que las filas se agrupen en una sola fila de salida como las llamadas agregadas no de ventana.  En cambio, las filas conservan sus identidades separadas. Detr\u00e1s de las  escenas, la funci\u00f3n de la ventana es capaz de acceder a algo m\u00e1s que la  fila actual del resultado de la consulta.</p> <p>Aqu\u00ed hay un ejemplo que muestra c\u00f3mo comparar el salario de cada empleado con el salario promedio en su departamento:</p> <pre><code>SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;\n</code></pre> <pre><code>  depname  | empno | salary |          avg\n-----------+-------+--------+-----------------------\n develop   |    11 |   5200 | 5020.0000000000000000\n develop   |     7 |   4200 | 5020.0000000000000000\n develop   |     9 |   4500 | 5020.0000000000000000\n develop   |     8 |   6000 | 5020.0000000000000000\n develop   |    10 |   5200 | 5020.0000000000000000\n personnel |     5 |   3500 | 3700.0000000000000000\n personnel |     2 |   3900 | 3700.0000000000000000\n sales     |     3 |   4800 | 4866.6666666666666667\n sales     |     1 |   5000 | 4866.6666666666666667\n sales     |     4 |   4800 | 4866.6666666666666667\n(10 rows)\n</code></pre> <p>Las tres primeras columnas de salida provienen directamente de la tabla <code>empsalary</code>, y hay una fila de salida para cada fila en la tabla. La cuarta columna  representa un promedio tomado en todas las filas de tabla que tienen lo  mismo  <code>depname</code>valor como la fila actual. (En realidad es la misma funci\u00f3n que la no-ventada  <code>avg</code>agregado, pero el  <code>OVER</code>cl\u00e1usula hace que sea tratada como una funci\u00f3n de la ventana y calculada a trav\u00e9s del marco de la ventana.)</p> <p>Una llamada de funci\u00f3n de ventana siempre contiene un  <code>OVER</code>cl\u00e1usula directamente siguiendo el nombre y los argumentos de la funci\u00f3n de la  ventana. Esto es lo que lo distingue sint\u00e1cticamente de una funci\u00f3n  normal o agregado no de ventana. El  <code>OVER</code>la cl\u00e1usula determina exactamente c\u00f3mo se dividen las filas de la consulta para su procesamiento por la funci\u00f3n de la ventana. El  <code>PARTITION BY</code>cl\u00e1usula dentro  <code>OVER</code>divide las filas en grupos, o particiones, que comparten los mismos valores de la  <code>PARTITION BY</code>la expresi\u00f3n (s). Para cada fila, la funci\u00f3n de la ventana se calcula a  trav\u00e9s de las filas que caen en la misma partici\u00f3n que la fila actual.</p> <p>Tambi\u00e9n puede controlar el orden en el que las filas se procesan por funciones de ventana usando  <code>ORDER BY</code>dentro <code>OVER</code>. (La ventana  <code>ORDER BY</code>ni siquiera tiene que coincidir con el orden en el que las filas son de salida.) He aqu\u00ed un ejemplo:</p> <pre><code>SELECT depname, empno, salary,\n       rank() OVER (PARTITION BY depname ORDER BY salary DESC)\nFROM empsalary;\n</code></pre> <pre><code>  depname  | empno | salary | rank\n-----------+-------+--------+------\n develop   |     8 |   6000 |    1\n develop   |    10 |   5200 |    2\n develop   |    11 |   5200 |    2\n develop   |     9 |   4500 |    4\n develop   |     7 |   4200 |    5\n personnel |     2 |   3900 |    1\n personnel |     5 |   3500 |    2\n sales     |     1 |   5000 |    1\n sales     |     4 |   4800 |    2\n sales     |     3 |   4800 |    2\n(10 rows)\n</code></pre> <p>Como se muestra aqu\u00ed, el  <code>rank</code>funci\u00f3n produce un rango num\u00e9rico para cada distinto  <code>ORDER BY</code>valor en la partici\u00f3n de la fila actual, utilizando el orden definido por el  <code>ORDER BY</code>cl\u00e1usula.  <code>rank</code>no necesita un par\u00e1metro expl\u00edcito, porque su comportamiento est\u00e1 totalmente determinado por la  <code>OVER</code>cl\u00e1usula.</p> <p>Las filas consideradas por una funci\u00f3n de ventana son las de la tabla virtual . producida por la consulta's  <code>FROM</code>cl\u00e1usula filtrada por su <code>WHERE</code>, <code>GROUP BY</code>, y  <code>HAVING</code>cl\u00e1usulas, si las hay. Por ejemplo, una fila eliminada porque no cumple con la  <code>WHERE</code>la condici\u00f3n no se ve por ninguna funci\u00f3n de ventana. Una consulta puede  contener m\u00faltiples funciones de ventana que cortan los datos de  diferentes maneras usando diferentes  <code>OVER</code>cl\u00e1usulas, pero todas act\u00faan sobre la misma colecci\u00f3n de filas definidas por esta tabla virtual.</p> <p>Ya vimos eso.  <code>ORDER BY</code>se puede omitir si el orden de las filas no es importante. Tambi\u00e9n es posible omitir <code>PARTITION BY</code>, en cuyo caso hay una sola partici\u00f3n que contiene todas las filas.</p> <p>Hay otro concepto importante asociado a las funciones de la  ventana: para cada fila, hay un conjunto de filas dentro de su partici\u00f3n llamada marco de la ventana. Algunas funciones de ventana act\u00faan s\u00f3lo en las filas del marco de la  ventana, en lugar de toda la partici\u00f3n. Por defecto, si  <code>ORDER BY</code>se suministra entonces el marco consiste en todas las filas desde el  inicio de la partici\u00f3n hasta la fila actual, adem\u00e1s de cualquier fila  siguiente que sean iguales a la fila actual de acuerdo con el  <code>ORDER BY</code>cl\u00e1usula. Cuando  <code>ORDER BY</code>se omite el marco predeterminado consiste en todas las filas en la partici\u00f3n. 1 Aqu\u00ed hay un ejemplo de uso <code>sum</code>:</p> <pre><code>SELECT salary, sum(salary) OVER () FROM empsalary;\n</code></pre> <pre><code> salary |  sum\n--------+-------\n   5200 | 47100\n   5000 | 47100\n   3500 | 47100\n   4800 | 47100\n   3900 | 47100\n   4200 | 47100\n   4500 | 47100\n   4800 | 47100\n   6000 | 47100\n   5200 | 47100\n(10 rows)\n</code></pre> <p>Arriba, ya que no hay  <code>ORDER BY</code>en el  <code>OVER</code>cl\u00e1usula, el marco de la ventana es el mismo que la partici\u00f3n, que por falta de  <code>PARTITION BY</code>es toda la tabla; en otras palabras, cada suma se toma sobre toda la tabla y por lo tanto obtenemos el mismo resultado para cada fila de salida.  Pero si a\u00f1adimos un  <code>ORDER BY</code>cl\u00e1usula, obtenemos resultados muy diferentes:</p> <pre><code>SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;\n</code></pre> <pre><code> salary |  sum\n--------+-------\n   3500 |  3500\n   3900 |  7400\n   4200 | 11600\n   4500 | 16100\n   4800 | 25700\n   4800 | 25700\n   5000 | 30700\n   5200 | 41100\n   5200 | 41100\n   6000 | 47100\n(10 rows)\n</code></pre> <p>Aqu\u00ed la suma se toma del primer (menor) sueldo hasta el actual,  incluyendo cualquier duplicado de la actual (adunice los resultados para los salarios duplicados).</p> <p>Las funciones de la ventana s\u00f3lo se permiten en la  <code>SELECT</code>lista y la  <code>ORDER BY</code>cl\u00e1usula de la consulta. Est\u00e1n prohibidos en otros lugares, como en <code>GROUP BY</code>,  <code>HAVING</code>y  <code>WHERE</code>cl\u00e1usulas. Esto se debe a que l\u00f3gicamente se ejecutan despu\u00e9s de la tramitaci\u00f3n de esas cl\u00e1usulas. Adem\u00e1s, las funciones de la ventana se ejecutan despu\u00e9s de funciones de agregados no de ventana. Esto significa que es v\u00e1lido  incluir una llamada de funci\u00f3n agregada en los argumentos de una funci\u00f3n de ventana, pero no viceversa.</p> <p>Si hay una necesidad de filtrar o agrupar filas despu\u00e9s de que se  realizan los c\u00e1lculos de la ventana, puede utilizar un subseleccionado.  Por ejemplo:</p> <pre><code>SELECT depname, empno, salary, enroll_date\nFROM\n  (SELECT depname, empno, salary, enroll_date,\n          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n     FROM empsalary\n  ) AS ss\nWHERE pos &lt; 3;\n</code></pre> <p>La consulta anterior s\u00f3lo muestra las filas de la consulta interior teniendo  <code>rank</code>menos de 3.</p> <p>Cuando una consulta implica m\u00faltiples funciones de ventana, es posible escribir cada una con una separada  <code>OVER</code>cl\u00e1usula, pero esto es duplicado y propenso a errores si se quiere el mismo  comportamiento de escaparate para varias funciones. En su lugar, cada  comportamiento de ventanas puede ser nombrado en un  <code>WINDOW</code>cl\u00e1usula y luego referenciada en <code>OVER</code>. Por ejemplo:</p> <pre><code>SELECT sum(salary) OVER w, avg(salary) OVER w\n  FROM empsalary\n  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n</code></pre> <p>Se ver\u00e1n m\u00e1s detalles sobre las funciones de la ventana m\u00e1s adelante</p> <ol> <li> <p>Hay opciones para definir el marco de la ventana de otras maneras, pero este tutorial no los cubre. Para m\u00e1s detalles v\u00e9ase.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/06.-Herencia/","title":"06.-Herencia","text":"<p>La herencia es un concepto de bases de datos orientadas a objetos.  Abre interesantes nuevas posibilidades de dise\u00f1o de bases de datos.</p> <p>Vamos a crear dos tablas: Una tabla  <code>cities</code>y una mesa <code>capitals</code>. Naturalmente, las capitales tambi\u00e9n son ciudades, as\u00ed que quieres  alguna manera de mostrar las capitales impl\u00edcitamente cuando listas  todas las ciudades. Si eres realmente listo podr\u00edas inventar alg\u00fan  esquema como este:</p> <pre><code>CREATE TABLE capitals (\n  name       text,\n  population real,\n  elevation  int,    -- (in ft)\n  state      char(2)\n);\n\nCREATE TABLE non_capitals (\n  name       text,\n  population real,\n  elevation  int     -- (in ft)\n);\n\nCREATE VIEW cities AS\n  SELECT name, population, elevation FROM capitals\n    UNION\n  SELECT name, population, elevation FROM non_capitals;\n</code></pre> <p>Esto funciona bien en cuanto a consultas va, pero se pone feo cuando necesitas actualizar varias filas, para una cosa.</p> <p>Una mejor soluci\u00f3n es la siguiente:</p> <pre><code>CREATE TABLE cities (\n  name       text,\n  population real,\n  elevation  int     -- (in ft)\n);\n\nCREATE TABLE capitals (\n  state      char(2) UNIQUE NOT NULL\n) INHERITS (cities);\n</code></pre> <p>En este caso, una fila de  <code>capitals</code>hereda todas las columnas (<code>name</code>, <code>population</code>, y <code>elevation</code>) de su progenitor, <code>cities</code>. El tipo de la columna  <code>name</code>es <code>text</code>, un tipo nativo PostgreSQL para cadenas de caracteres de longitud variable. El  <code>capitals</code>tabla tiene una columna adicional, <code>state</code>, que muestra su abreviatura estatal. En PostgreSQL, una tabla puede heredar de cero o m\u00e1s otras tablas.</p> <p>Por ejemplo, la siguiente consulta encuentra los nombres de todas  las ciudades, incluidas las capitales de los estados, que se encuentran  en una elevaci\u00f3n de m\u00e1s de 500 pies:</p> <pre><code>SELECT name, elevation\n  FROM cities\n  WHERE elevation &gt; 500;\n</code></pre> <p>que devuelve:</p> <pre><code>   name    | elevation\n-----------+-----------\n Las Vegas |      2174\n Mariposa  |      1953\n Madison   |       845\n(3 rows)\n</code></pre> <p>Por otro lado, la siguiente consulta encuentra todas las ciudades  que no son capitales de estado y est\u00e1n situadas en una elevaci\u00f3n de m\u00e1s  de 500 pies:</p> <pre><code>SELECT name, elevation\n    FROM ONLY cities\n    WHERE elevation &gt; 500;\n</code></pre> <pre><code>   name    | elevation\n-----------+-----------\n Las Vegas |      2174\n Mariposa  |      1953\n(2 rows)\n</code></pre> <p>Aqu\u00ed el  <code>ONLY</code>antes de  <code>cities</code>indica que la consulta debe ser atropaleada s\u00f3lo el  <code>cities</code>tablas y no tablas a continuaci\u00f3n  <code>cities</code>en la jerarqu\u00eda de herencias. Muchas de las \u00f3rdenes que ya hemos discutido. <code>SELECT</code>, <code>UPDATE</code>, y  <code>DELETE</code>- apoyar esto  <code>ONLY</code>notaci\u00f3n.</p> <p>Nota</p> <p>Aunque la herencia es a menudo \u00fatil, no se ha integrado con  limitaciones \u00fanicas o con claves for\u00e1neas, lo que limita su utilidad.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/07.-Conclusi%C3%B3n/","title":"07.-Conclusi\u00f3n","text":"<p>PostgreSQL tiene muchas caracter\u00edsticas no tocadas en esta introducci\u00f3n, que se ha orientado hacia los nuevos usuarios de SQL. Estas caracter\u00edsticas se discuten con m\u00e1s detalle en adelante.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/","title":"Index","text":"<p>Esta parte describe el uso de la  SQLlenguaje en PostgreSQL. Empezamos con la descripci\u00f3n de la sintaxis general de SQL, entonces explicar c\u00f3mo crear las estructuras para mantener los datos,  c\u00f3mo poblar la base de datos y c\u00f3mo consultarlo. La parte media enumera  los tipos de datos disponibles y las funciones para su uso en  SQLcomandos. El resto trata varios aspectos que son importantes para sintonizar una base de datos para un rendimiento \u00f3ptimo.</p> <p>La informaci\u00f3n en esta parte se arregla para que un usuario  novato pueda seguirla de punta para obtener una comprensi\u00f3n completa de  los temas sin tener que referirse demasiado tiempo. Los cap\u00edtulos est\u00e1n  destinados a ser aut\u00f3nomos, para que los usuarios avanzados puedan leer  los cap\u00edtulos individualmente como ellos elijan. La informaci\u00f3n en esta  parte se presenta de manera narrativa en unidades de actualidad. Los  lectores que buscan una descripci\u00f3n completa de un comando en particular deben ver la Parte VI.</p> <p>Los lectores de esta parte deben saber c\u00f3mo conectarse a una base de datos PostgreSQL y emitir  SQLcomandos. Se anima a los lectores que no est\u00e1n familiarizados con estos temas a leer la Parte I primero.  SQLLos comandos se introducen t\u00edpicamente usando el terminal interactivo PostgreSQL psql, pero otros programas que tienen una funcionalidad similar tambi\u00e9n se pueden utilizar. </p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/","title":"Index","text":"<p>La entrada SQL consiste en una secuencia de comandos. Un comando se compone de una secuencia de tokens, terminada por un puntomico (   . El final de la corriente de entrada tambi\u00e9n termina un comando. Qu\u00e9  fichas son v\u00e1lidas depende de la sintaxis del comando en particular.</p> <p>Un token puede ser una palabra clave, un identificador, un identificador cotizado, un literal (o constante), o un s\u00edmbolo de caracteres especial. Los fichas  normalmente se separan por espacio en blanco (espacio, pesta\u00f1a,  newline), pero no tienen por qu\u00e9 ser si no hay ambiguedad (que  generalmente es s\u00f3lo el caso si un car\u00e1cter especial est\u00e1 adyacente a  alg\u00fan otro tipo simb\u00f3lico).</p> <p>Por ejemplo, lo siguiente es (synt\u00e1cticamente) la entrada SQL v\u00e1lida:</p> <pre><code>SELECT * DESDE MITABLE;\nActualizaci\u00f3n MY-TABLE SET A = 5;\nINSERT INTO MALL VALUE (3, 'hola all\u00ed');\n</code></pre> <p>Esta es una secuencia de tres comandos, uno por l\u00ednea (aunque esto  no se requiere; m\u00e1s de un comando puede estar en una l\u00ednea, y los  comandos pueden ser divididos \u00fatilmente a trav\u00e9s de las l\u00edneas).</p> <p>Adem\u00e1s, los comentarios pueden ocurrir en la entrada de SQL. No son fichas, son efectivamente equivalentes al espacio en blanco.</p> <p>La sintaxis SQL no es muy consistente con respecto a qu\u00e9 fichas  identifican los comandos y cu\u00e1les son operandos o par\u00e1metros. Las  primeras fichas son generalmente el nombre de comando, as\u00ed que en el  ejemplo anterior normalmente hablar\u00edamos de un \"SELECT\", un \"ActADE\", y un INSERTcomando INSERT. Pero, por ejemplo, el  <code>UPDATE</code>El mando siempre requiere un  <code>SET</code>token aparecer en una determinada posici\u00f3n, y esta variaci\u00f3n particular de  <code>INSERT</code>tambi\u00e9n requiere un  <code>VALUES</code>para estar completa. Las reglas de sintaxis precisas para cada comando se describen en la Parte VI.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/01.-Identificadores%20y%20palabras%20clave/","title":"01.-Identificadores y palabras clave","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/01.-Identificadores%20y%20palabras%20clave/#411-identificadores-y-palabras-claves","title":"4.1.1. Identificadores y Palabras Claves","text":"<p>fichas como <code>SELECT</code>, <code>UPDATE</code>, o  <code>VALUES</code>en el ejemplo anterior hay ejemplos de palabras clave, es decir, palabras que tienen un significado fijo en el idioma SQL. Las fichas  <code>MY_TABLE</code>y  <code>A</code>son ejemplos de identificadores. Identan nombres de tablas, columnas u otros objetos de base de datos,  dependiendo del comando en el que se utilicen. Por lo tanto, a veces  simplemente se les llaman nombres. Las palabras clave y los identificadores tienen la misma estructura  l\u00e9xica, lo que significa que no se puede saber si un token es un  identificador o una palabra clave sin conocer el idioma. En el ap\u00e9ndice C se puede encontrar una lista completa de palabras clave.</p> <p>Los identificadores SQL y las palabras clave deben comenzar con una letra (<code>a</code>- -<code>z</code>, pero tambi\u00e9n letras con marcas diacr\u00edticas y letras no latinas) o un subrayado (<code>_</code>). Los caracteres posteriores en un identificador o palabra clave pueden ser letras, subrayados, d\u00edgitos (<code>0</code>- -<code>9</code>), o signos en d\u00f3lares (<code>$</code>). Tenga en cuenta que los signos en d\u00f3lares no est\u00e1n permitidos en los  identificadores de acuerdo con la letra del est\u00e1ndar SQL, por lo que su  uso podr\u00eda hacer que las aplicaciones sean menos port\u00e1tiles. El est\u00e1ndar SQL no definir\u00e1 una palabra clave que contenga d\u00edgitos o arranques o  termines con un subrayado, por lo que los identificadores de este  formulario son seguros contra posibles conflictos con futuras  extensiones del est\u00e1ndar.</p> <p>El sistema no utiliza m\u00e1s que <code>NAMEDATALEN</code>-1 bytes de un identificador; nombres m\u00e1s largos se pueden escribir en comandos, pero ser\u00e1n truncados. Por defecto,  <code>NAMEDATALEN</code>es de 64 por lo que la longitud m\u00e1xima del identificador es de 63 bytes.  Si este l\u00edmite es problem\u00e1tico, se puede elevar cambiando la  <code>NAMEDATALEN</code>constante en <code>src/include/pg_config_manual.h</code>.</p> <p>Las palabras clave y los identificadores no con citas son insensibles a los casos. Por lo tanto:</p> <pre><code>Actualizaci\u00f3n MY-TABLE SET A = 5;\n</code></pre> <p>puede escribirse de manera equivalente como:</p> <pre><code>uPDaTE my-TabLE SeT a = 5;\n</code></pre> <p>Una convenci\u00f3n que se utiliza a menudo es para escribir palabras  clave en el caso superior y nombres en el caso inferior, por ejemplo:</p> <pre><code>Actualizaci\u00f3n de miable SET a = 5;\n</code></pre> <p>Hay un segundo tipo de identificador: el identificador delimitado o identificador cotizado. Est\u00e1 formado adjuntando una secuencia arbitraria de caracteres en dobles citas (<code>\"</code>). Un identificador delimitado es siempre un identificador, nunca una palabra clave. As\u00ed que  <code>\"select\"</code>podr\u00eda utilizarse para referirse a una columna o tabla llamada . select , mientras que un no cotizado   se tomar\u00eda como una palabra clave y, por lo tanto, provocar\u00eda un error  de parse cuando se usara cuando se espera una tabla o nombre de columna. El ejemplo se puede escribir con identificadores citados como este:</p> <pre><code>Actualizaci\u00f3n de la SET \"a\" = 5;\n</code></pre> <p>Los identificadores cotizados pueden contener cualquier car\u00e1cter, excepto el car\u00e1cter con c\u00f3digo cero. (Para incluir una doble cita,  escriba dos comillas dobles.) Esto permite la construcci\u00f3n de nombres de tablas o columnas que de otra manera no ser\u00edan posibles, como aquellos  que contienen espacios o ampersands. La limitaci\u00f3n de longitud todav\u00eda  se aplica.</p> <p>Citar un identificador tambi\u00e9n lo hace sensible al caso, mientras que los nombres no cotizados siempre se doblan a min\u00fasculas. Por  ejemplo, los identificadores <code>FOO</code>, <code>foo</code>, y  <code>\"foo\"</code>son considerados los mismos por PostgreSQL, pero  <code>\"Foo\"</code>y  <code>\"FOO\"</code>son diferentes de estos tres y entre s\u00ed. (El plegado de nombres no cotizado al caso inferior en PostgreSQL es incompatible con el est\u00e1ndar SQL, que dice que los nombres no cotizado deben plegarse a la caja superior. As\u00ed,  <code>foo</code>debe ser equivalente a  <code>\"FOO\"</code>no  <code>\"foo\"</code>seg\u00fan el est\u00e1ndar. Si quieres escribir aplicaciones port\u00e1tiles, se te  aconseja citar siempre un nombre en particular o nunca citarlo.)</p> <p>Una variante de identificadores cotizados permite incluir los  caracteres de Unicode escapados identificados por sus puntos de c\u00f3digo.  Esta variante comienza con  <code>U&amp;</code>(\u00faper o min\u00fasculo U seguido de ampersand) inmediatamente antes de la doble  cita de apertura, sin ning\u00fan espacio en el medio, por ejemplo <code>U&amp;\"foo\"</code>. (Tenga en cuenta que esto crea una ambiguedad con el operador <code>&amp;</code>. Utilice espacios alrededor del operador para evitar este problema.)  Dentro de las citas, los caracteres de Unicode se pueden especificar en  forma escapada escribiendo una reacci\u00f3n seguida por el n\u00famero de punto  de c\u00f3digo hexadecimal de cuatro d\u00edgitos o alternativamente una reacci\u00f3n  tras una se\u00f1al plus seguida de un n\u00famero de punto de c\u00f3digo hexadecimal  de seis d\u00edgitos. Por ejemplo, el identificador  <code>\"data\"</code>podr\u00eda escribirse como</p> <pre><code>U&amp;\"d.0061t.000061\"\n</code></pre> <p>El siguiente ejemplo menos trivial escribe la palabra rusa \" slon\" (elefante) en letras cir\u00edlicos:</p> <pre><code>U&amp;\"-0441-043B-043E-043D\"\n</code></pre> <p>Si se desea un car\u00e1cter de escape diferente al de la reacci\u00f3n, se puede especificar usando el  <code>UESCAPE</code>cl\u00e1usula despu\u00e9s de la cadena, por ejemplo:</p> <pre><code>U&amp;\"d-0061t-000061\" UESCAPE ''\n</code></pre> <p>El personaje de escape puede ser cualquier personaje que no sea  un d\u00edgito hexadecimal, el signo m\u00e1s, una sola cita, una comici\u00f3n doble, o un car\u00e1cter de espacio blanco. Tenga en cuenta que el car\u00e1cter de  escape est\u00e1 escrito en comillas individuales, no comillas dobles,  despu\u00e9s de <code>UESCAPE</code>.</p> <p>Para incluir el car\u00e1cter de escape en el identificador literalmente, escr\u00edbalo dos veces.</p> <p>Ya sea el formulario de escape de 4 d\u00edgitos o de 6 d\u00edgitos se  puede utilizar para especificar pares de alquiler UTF-16 para componer  caracteres con puntos de c\u00f3digo m\u00e1s grandes que U-FFFF, aunque la  disponibilidad de la forma de 6 d\u00edgitos t\u00e9cnicamente hace esto  innecesario. (Los pares de sorroga no se almacenan directamente, sino  que se combinan en un solo punto de c\u00f3digo.)</p> <p>Si la codificaci\u00f3n del servidor no es UTF-8, el punto de c\u00f3digo  Unicode identificado por una de estas secuencias de escape se convierte  en la codificaci\u00f3n del servidor real; se informa un error si eso no es  posible.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/","title":"02.-Constantes","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#412-constantes","title":"4.1.2. Constantes","text":"<p>Hay tres tipos de constantes de tipo impl\u00edcita en PostgreSQL: cuerdas, bits y n\u00fameros. Los constantes tambi\u00e9n se pueden especificar  con tipos expl\u00edcitos, que pueden permitir una representaci\u00f3n m\u00e1s precisa y un manejo m\u00e1s eficiente por parte del sistema. Estas alternativas se  discuten en las subsecciones siguientes.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4121-string-constants","title":"4.1.2.1. String Constants","text":"<p>Una constante de cadena en SQL es una secuencia arbitraria de caracteres limitado por comillas simples (<code>'</code>), por ejemplo <code>'This is a string'</code>. Para incluir un personaje de una sola cita dentro de una constante de  cuerda, escriba dos comillas \u00fanicas adyacentes, por ejemplo, <code>'Dianne''s horse'</code>. Tenga en cuenta que esto no es lo mismo que un personaje de doble cotizaci\u00f3n (<code>\"</code>).</p> <p>Dos constantes de cuerda que s\u00f3lo est\u00e1n separadas por el espacio blanco con al menos una nueva l\u00ednea son concatenadas y tratadas eficazmente como si la cuerda hubiera sido escrita como una constante. Por ejemplo:</p> <pre><code>SELECT 'foo'\n\"bar\";\n</code></pre> <p>equivalente a:</p> <pre><code>SELECT 'foobar';\n</code></pre> <p>pero:</p> <pre><code>SELECT 'foo' 'bar';\n</code></pre> <p>no es sintaxis v\u00e1lida. (Este comportamiento ligeramente extra\u00f1o es especificado por SQL; PostgreSQL est\u00e1 siguiendo el est\u00e1ndar.)</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4122-constantes-de-cuerda-con-c-style-escapes","title":"4.1.2.2 Constantes de cuerda con C-Style Escapes","text":"<p>PostgreSQL tambi\u00e9n acepta las constantes de  cadena , que son una extensi\u00f3n del est\u00e1ndar SQL. Una constante de la cadena de escape se especifica escribiendo la carta  <code>E</code>(caso superior o inferior) justo antes de la cita \u00fanica de apertura, por ejemplo, <code>E'foo'</code>. (Cuando contin\u00fae una cuerda de escape constante a trav\u00e9s de las l\u00edneas, escriba  <code>E</code>s\u00f3lo antes de la primera cita de apertura.) Dentro de una cuerda de escape, un personaje de reacci\u00f3n (<code>\\</code>) comienza una secuencia de escape de  similar a C, en la que la combinaci\u00f3n de la reacci\u00f3n y los siguientes  caracteres (s) representan un valor de byte especial, como se muestra en .</p> <p>Cuadro 4.1. Retola de las secuencias de escape</p> Retablos de Escape Sequence Interpretaci\u00f3n <code>\\b</code> espacio trasero <code>\\f</code> pienso en el pienso <code>\\n</code> nueva l\u00ednea <code>\\r</code> Retornaje del transporte <code>\\t</code> pesta\u00f1a <code>\\*</code>o<code>*</code>, <code>\\*</code>oo<code>*</code>,  <code>\\*</code>ooo<code>*</code>( <code>o</code>= 0-7) valor de byte octal <code>\\x*</code>h<code>*</code>,  <code>\\x*</code>hh<code>*</code>( <code>h</code>= 0,9, A-F) Valor hexadecimal de byte <code>\\u*</code>xxxx<code>*</code>,  <code>\\U*</code>xxxxxxxx<code>*</code>( <code>x</code>= 0,9, A-F) 16 o 32 bits hexadecimal El valor de car\u00e1cter de Unicode <p>Cualquier otro personaje despu\u00e9s de una reacci\u00f3n es tomado  literalmente. As\u00ed, para incluir un personaje de reacci\u00f3n, escribir dos  backslashes (<code>\\\\</code>). Adem\u00e1s, una sola cita se puede incluir en una cuerda de escape escribiendo <code>\\'</code>, adem\u00e1s de la forma normal de <code>''</code>.</p> <p>Es su responsabilidad que las secuencias de byte que crea,  especialmente cuando se utilizan los escapes octales o hexadecimales,  compongan caracteres v\u00e1lidos en la codificaci\u00f3n del conjunto de  caracteres del servidor. Una alternativa \u00fatil es utilizar Unicode  escapes o la sintaxis alternativa de escape Unicode, explicado en la Secci\u00f3n 4.1.2.3 ; entonces el servidor comprobar\u00e1 que la conversi\u00f3n de caracteres es posible.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#precaucion","title":"Precauci\u00f3n","text":"<p>Si el par\u00e1metro de configuraci\u00f3n est\u00e1ndar.conformidad.strings es <code>off</code>, entonces PostgreSQL reconoce escapes de reacci\u00f3n en constantes regulares y de cuerdas de escape. Sin embargo, a partir de PostgreSQL 9.1, el predeterminado es <code>on</code>, lo que significa que las fugas de reacci\u00f3n se reconocen s\u00f3lo en las  constantes de la cuerda de escape. Este comportamiento es m\u00e1s compatible con los est\u00e1ndares, pero podr\u00eda romper aplicaciones que se basan en el  comportamiento hist\u00f3rico, donde las fugas de reacci\u00f3n siempre fueron  reconocidas. Como soluci\u00f3n, puedes establecer este par\u00e1metro en <code>off</code>, pero es mejor migrar lejos de usar escapes de reacci\u00f3n. Si necesitas  usar un escape de reacci\u00f3n para representar un personaje especial,  escribe la constante de cuerda con un <code>E</code>.</p> <p>Adem\u00e1s de <code>standard_conforming_strings</code>, los par\u00e1metros de configuraci\u00f3n escapen.advertida y contrada-resistencia-cuerno tratamiento de espaldas contradas en constantes de cuerda.</p> <p>El car\u00e1cter con el c\u00f3digo cero no puede estar en una constante de cadena.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4123-string-constants-con-unicode-escapes","title":"4.1.2.3. String Constants con Unicode Escapes","text":"<p>PostgreSQL tambi\u00e9n admite otro tipo de sintaxis de escape para cadenas que permite especificar caracteres de Unicode arbitrarios por punto de c\u00f3digo.  Comienza con una constante de cuerda de escape Unicode  <code>U&amp;</code>(\u00faltima carta de caso U seguida de ampersand) inmediatamente antes de la cita  de apertura, sin ning\u00fan espacio en el medio, por ejemplo <code>U&amp;'foo'</code>. (Tenga en cuenta que esto crea una ambiguedad con el operador <code>&amp;</code>. Utilice espacios alrededor del operador para evitar este problema.)  Dentro de las citas, los caracteres de Unicode se pueden especificar en  forma escapada escribiendo una reacci\u00f3n seguida por el n\u00famero de punto  de c\u00f3digo hexadecimal de cuatro d\u00edgitos o alternativamente una reacci\u00f3n  tras una se\u00f1al plus seguida de un n\u00famero de punto de c\u00f3digo hexadecimal  de seis d\u00edgitos. Por ejemplo, la cadena  <code>'data'</code>podr\u00eda escribirse como</p> <pre><code>U&amp;'d-0061t-000061'\n</code></pre> <p>El siguiente ejemplo menos trivial escribe la palabra rusa \" slon\" (elefante) en letras cir\u00edlicos:</p> <pre><code>U&amp;'-0441-043B-043E-043D'\n</code></pre> <p>Si se desea un car\u00e1cter de escape diferente al de la reacci\u00f3n, se puede especificar usando el  <code>UESCAPE</code>cl\u00e1usula despu\u00e9s de la cadena, por ejemplo:</p> <pre><code>U&amp;'d.0061t.000061' UESCAPE ''\n</code></pre> <p>El personaje de escape puede ser cualquier personaje que no sea un d\u00edgito hexadecimal, el signo m\u00e1s, una sola cita, una comici\u00f3n doble, o un car\u00e1cter de espacio blanco.</p> <p>Para incluir el personaje de escape en la cuerda literalmente, escr\u00edbalo dos veces.</p> <p>Ya sea el formulario de escape de 4 d\u00edgitos o de 6 d\u00edgitos se  puede utilizar para especificar pares de alquiler UTF-16 para componer  caracteres con puntos de c\u00f3digo m\u00e1s grandes que U-FFFF, aunque la  disponibilidad de la forma de 6 d\u00edgitos t\u00e9cnicamente hace esto  innecesario. (Los pares de sorroga no se almacenan directamente, sino  que se combinan en un solo punto de c\u00f3digo.)</p> <p>Si la codificaci\u00f3n del servidor no es UTF-8, el punto de c\u00f3digo Unicode identificado por una de estas secuencias de escape se convierte en la codificaci\u00f3n del servidor real; se informa un error si eso no es  posible.</p> <p>Adem\u00e1s, la sintaxis de escape de Unicode para las constantes de cadena s\u00f3lo funciona cuando se encende el par\u00e1metro de configuraci\u00f3n est\u00e1ndar. Esto se debe a que de lo contrario esta sintaxis podr\u00eda confundir a los clientes que analizan las declaraciones de SQL hasta el punto de que  podr\u00eda conducir a inyecciones SQL y problemas de seguridad similares. Si el par\u00e1metro est\u00e1 listo para desactivar, esta sintaxis ser\u00e1 rechazada  con un mensaje de error.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4124-constants-de-cuerda-de-cuerda-de-dolar","title":"4.1.2.4. Constants de cuerda de cuerda de D\u00f3lar","text":"<p>Si bien la sintaxis est\u00e1ndar para especificar constantes de  cadena es generalmente conveniente, puede ser dif\u00edcil de entender cuando la cuerda deseada contiene muchas comillas individuales, ya que cada  una de ellas debe ser duplicada. Para permitir m\u00e1s consultas legibles en tales situaciones, PostgreSQL proporciona otra manera, llamada \"---- cita de d\u00f3lares, para escribir constantes de cadena. Una constante de cuerda cotizado en d\u00f3lares consiste en un signo de d\u00f3lar (<code>$</code>), una etiqueta opcional de cero o m\u00e1s caracteres, otro signo de d\u00f3lar, una secuencia  arbitraria de caracteres que compone el contenido de cuerda, un signo de d\u00f3lar, la misma etiqueta que comenz\u00f3 esta cotizaci\u00f3n en d\u00f3lares, y un  signo de d\u00f3lar. Por ejemplo, aqu\u00ed hay dos maneras diferentes de  especificar la cadena. El caballo de Dianne.</p> <pre><code>$$Cierdo de Danina$$\n$SmeTag$Dianne's horse$SomeTag$\n</code></pre> <p>Observe que dentro de la cadena cotizado por el d\u00f3lar, las  citas simples se pueden usar sin necesidad de ser escapada. De hecho,  nunca se escapan personajes dentro de una cuerda cotizado en d\u00f3lares: el contenido de cuerdas siempre se escribe literalmente. Los contraspaldas no son especiales, y tampoco los signos de d\u00f3lares, a menos que sean  parte de una secuencia que coinja con la etiqueta de apertura.</p> <p>Es posible anidar constantes de cuerda con citas en d\u00f3lares  eligiendo diferentes etiquetas en cada nivel de anidaci\u00f3n. Esto se  utiliza m\u00e1s com\u00fanmente en las definiciones de funciones de escritura.  Por ejemplo:</p> <pre><code>$function$\nBEGIN\n    RETURN ($1 - $q$[-t.r.n.v]$q$2).\nEND;\n$function$\n</code></pre> <p>Aqu\u00ed, la secuencia  <code>$q$[\\t\\r\\n\\v\\\\]$q$</code>representa una cuerda literal con el d\u00f3lar <code>[\\t\\r\\n\\v\\\\]</code>, que ser\u00e1 reconocido cuando el cuerpo de la funci\u00f3n sea ejecutado por PostgreSQL. Pero como la secuencia no coincide con el d\u00f3lar exterior citando delimitador <code>$function$</code>, es s\u00f3lo algunos m\u00e1s caracteres dentro de la constante en lo que respecta a la cuerda externa.</p> <p>La etiqueta, si la hay, de una cadena con cita en d\u00f3lares sigue las mismas reglas que un identificador no citado, excepto que no puede  contener un signo de d\u00f3lar. Las etiquetas son sensibles, por lo que  <code>$tag$String content$tag$</code>es correcto, pero  <code>$TAG$String content$tag$</code>No lo es.</p> <p>Una cadena con el d\u00f3lar que sigue una palabra clave o  identificador debe separarse de \u00e9l por espacio en blanco; de lo  contrario, el delimitador de d\u00f3lares que citar\u00eda el delimitador se  tomar\u00eda como parte del identificador anterior.</p> <p>La cita de d\u00f3lares no es parte del est\u00e1ndar SQL, pero a menudo  es una manera m\u00e1s conveniente de escribir literales de cuerda  complicados que la sintaxis de cotizaci\u00f3n \u00fanica compatible con el  est\u00e1ndar. Es particularmente \u00fatil cuando se representan constantes de  cuerda dentro de otras constantes, como a menudo se necesita en las  definiciones de funci\u00f3n de procedimiento. Con una sola cita de sintaxis, cada reacci\u00f3n en el ejemplo anterior tendr\u00eda que ser escrito como  cuatro contrasueldos, que se reducir\u00edan a dos barras de fondo en el par  en parar la constante de la cadena original, y luego a una cuando la  constante de la cadena interna se repara durante la ejecuci\u00f3n de la  funci\u00f3n.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4125-bit-string-constants","title":"4.1.2.5. Bit-String Constants","text":"<p>Las constantes de cuerda de cuerda parecen constantes de cuerda regulares con un  <code>B</code>(caso superior o inferior) inmediatamente antes de la cita de apertura (sin espacio en blanco intervenida), por ejemplo, <code>B'1001'</code>. Los \u00fanicos personajes permitidos dentro de las constantes de la cuerda de bits son  <code>0</code>y <code>1</code>.</p> <p>Alternativamente, las constantes de bit-cadeo se pueden especificar en la notaci\u00f3n hexadecimal, utilizando un liderazgo  <code>X</code>(\u00fabre o minustada), por ejemplo, <code>X'1FF'</code>. Esta notaci\u00f3n es equivalente a una constante de bit-string con cuatro d\u00edgitos binarios para cada d\u00edgito hexadecimal.</p> <p>Ambas formas de constante de bit-cadeing pueden continuar a  trav\u00e9s de las l\u00edneas de la misma manera que las constantes regulares de  cuerda. La cita en d\u00f3lares no se puede utilizar en una constante de  cuerdas.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4126-numeric-constants","title":"4.1.2.6. Numeric Constants","text":"<p>Se aceptan constantes num\u00e9ricas en estas formas generales:</p> <pre><code>digitsdigits.[digits][e-]digits]\n[digits] ].digits[e-]digits]\ndigitse[-]digits\n</code></pre> <p>d\u00f3nde  <code>digits</code>es uno o m\u00e1s d\u00edgitos decimales (0 a 9). Al menos un d\u00edgito debe ser antes o despu\u00e9s del punto decimal, si se utiliza uno. Al menos un d\u00edgito debe  seguir el marcador exponencial (<code>e</code>), si uno est\u00e1 presente. No puede haber espacios u otros caracteres  incrustados en la constante, excepto por subrayados, que se pueden  utilizar para la agrupaci\u00f3n visual como se describe a continuaci\u00f3n.  Tenga en cuenta que cualquier signo de ventaja o menos no se considera  realmente parte de la constante; es un operador aplicado a la constante.</p> <p>Estos son algunos ejemplos de constantes num\u00e9ricas v\u00e1lidas:</p> <p>\u200b       42       3.5        </p> <p>.001       5e2       1.925e-3</p> <p>Adem\u00e1s, se aceptan constantes en n\u00fameros enteros no decimales en estos formularios:</p> <pre><code>0x\nhexdigits0o\noctdigits0bbindigits\n</code></pre> <p>d\u00f3nde  <code>hexdigits</code>es uno o m\u00e1s d\u00edgitos hexadecimales (0-9, A-F),  <code>octdigits</code>es uno o m\u00e1s d\u00edgitos octales (0-7), y  <code>bindigits</code>es uno o m\u00e1s d\u00edgitos binarios (0 o 1). Los d\u00edgitos hexadeciales y los  prefijos de radix pueden ser en may\u00fasculas o inferior. Tenga en cuenta  que s\u00f3lo los enteros pueden tener formularios no decimosmales, no  n\u00fameros con partes fraccionarias.</p> <p>Estos son algunos ejemplos de constantes v\u00e1lidas no decimales enteros:</p> <p>\u200b       0b100101       0B10011001       0o273       0O755       0x42f       0XFFFF</p> <p>Para la agrupaci\u00f3n visual, se pueden insertar subrayados entre  d\u00edgitos. Estos no tienen ning\u00fan efecto m\u00e1s sobre el valor de la  constante. Por ejemplo:</p> <p>\u200b       1o500o000o       0b10001000-00000000       0o1o755       0xFFFF       1.618o034</p> <p>No se permiten puntar en el inicio o al final de una constante  num\u00e9rica o un grupo de d\u00edgitos (es decir, inmediatamente antes o despu\u00e9s del punto decimal o el marcador exponente), y no se permite m\u00e1s de un  subrayado en una fila.</p> <p>Una constante num\u00e9rica que no contiene ni un punto decimal ni un exponente se presume que es de tipo  <code>integer</code>si su valor encaja en el tipo  <code>integer</code>(32 bits); de lo contrario se presume que es de tipo  <code>bigint</code>si su valor encaja en el tipo  <code>bigint</code>(64 bits); de lo contrario, se considera que es de tipo <code>numeric</code>. Los estantes que contienen puntos decimales y/o exponentes siempre se presumen inicialmente que son de tipo <code>numeric</code>.</p> <p>El tipo de datos inicialmente asignado de una constante  num\u00e9rica es s\u00f3lo un punto de partida para los algoritmos de resoluci\u00f3n  de tipo. En la mayor\u00eda de los casos la constante se coacciar\u00e1  autom\u00e1ticamente al tipo m\u00e1s apropiado dependiendo del contexto. Cuando  sea necesario, puede forzar un valor num\u00e9rico a ser interpretado como un tipo de datos espec\u00edfico al lanzarlo. Por ejemplo, puedes forzar un valor num\u00e9rico para ser tratado como tipo  <code>real</code>(<code>float4</code>) por escrito:</p> <pre><code>REAL '1.23' - estilo de cuerda\n1.23::REAL -- estilo PostgreSQL (hist\u00f3rico)\n</code></pre> <p>Estos son en realidad s\u00f3lo casos especiales de las notaciones generales de casting discutidas a continuaci\u00f3n.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/02.-Constantes/#4127-constantes-de-otros-tipos","title":"4.1.2.7. Constantes de otros tipos","text":"<p>Una constante de tipo arbitrario se puede introducir utilizando cualquiera de las siguientes notaciones:</p> <pre><code> type\"string\"\n\"string':\ntypeCAST ('stringAS  type)\n</code></pre> <p>El texto de la cadena de la constante se pasa a la rutina de conversi\u00f3n de entrada para el tipo llamado <code>type</code>. El resultado es una constante del tipo indicado. El elenco expl\u00edcito  puede omitirse si no hay ambiguedad en cuanto al tipo que debe ser la  constante (por ejemplo, cuando se asigna directamente a una columna de  tabla), en cuyo caso se coacita autom\u00e1ticamente.</p> <p>La constante de la cadena se puede escribir usando la notaci\u00f3n SQL regular o citas en d\u00f3lares.</p> <p>Tambi\u00e9n es posible especificar una coacci\u00f3n de tipo mediante una sintaxis similar a la funci\u00f3n:</p> <pre><code> typename( ( 'string\" \" )\n</code></pre> <p>pero no todos los nombres de tipo se pueden utilizar de esta manera; consulte la Secci\u00f3n 4.2.9 para m\u00e1s detalles.</p> <p>El <code>::</code>, <code>CAST()</code>, y las sintaxis de la funci\u00f3n-llama tambi\u00e9n se pueden utilizar para  especificar conversiones de expresiones arbitrarias en el momento del  tiempo de ejecuci\u00f3n, como se examina en la secci\u00f3n 4.2.9. Para evitar la ambiguuidad sint\u00e1ctica, el  <code>*</code>type<code>* '*</code>string<code>*'</code>la sintaxis s\u00f3lo se puede utilizar para especificar el tipo de una constante literal simple. Otra restricci\u00f3n a la  <code>*</code>type<code>* '*</code>string<code>*'</code>sintaxis es que no funciona para los tipos de array; use  <code>::</code>o o  <code>CAST()</code>para especificar el tipo de constante de array.</p> <p>El  <code>CAST()</code>sintaxis se ajusta a SQL. El  <code>*</code>type<code>* '*</code>string<code>*'</code>Sintaxis es una generalizaci\u00f3n de la norma: SQL especifica esta sintaxis s\u00f3lo para unos pocos tipos de datos, pero PostgreSQL lo permite para todo tipo. La sintaxis con  <code>::</code>es el uso hist\u00f3rico de PostgreSQL, al igual que la sintaxis de la funci\u00f3n-llama.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/03.-Operadores/","title":"03.-Operadores","text":"<p>4.1.3. Operadores</p> <p>Un nombre de operador es una secuencia de hasta <code>NAMEDATALEN</code>caracteres -1 (63 por defecto) de la siguiente lista:</p> <p>\u200b     - *  / * = * % y *  *  *  * * ?</p> <p>Sin embargo, hay algunas restricciones a los nombres de los operadores:</p> <ul> <li> <p><code>--</code>y  <code>/*</code>no puede aparecer en ninguna parte en un nombre del operador, ya que ser\u00e1n tomados como el comienzo de un comentario.</p> </li> <li> <p>Un nombre de operador de car\u00e1cter m\u00faltiple no puede terminar en  <code>+</code>o o <code>-</code>, a menos que el nombre contenga tambi\u00e9n al menos uno de estos caracteres:</p> </li> </ul> <p>\u200b             - ? % y *  *  *  *  ?</p> <p>Por ejemplo,  <code>@-</code>es un nombre permitido del operador, pero  <code>*-</code>No lo es. Esta restricci\u00f3n permite a PostgreSQL analizar consultas compatibles con SQL sin necesidad de espacios entre tokens.</p> <p>Cuando se trabaja con nombres de operadores no est\u00e1ndar SQL, por  lo general tendr\u00e1 que separar a los operadores adyacentes con espacios  para evitar la ambiguedad. Por ejemplo, si ha definido un operador de  prefijo nombrado <code>@</code>, no puedes escribir <code>X*@Y</code>; usted debe escribir  <code>X* @Y</code>para asegurarse de que PostgreSQL lo lee como dos nombres de operador no uno.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/03.-Operadores/#414-personajes-especiales","title":"4.1.4. Personajes especiales","text":"<p>Algunos personajes que no son alfanum\u00e9ricos tienen un significado especial que es diferente de ser operador. Los detalles sobre el uso se pueden encontrar en el lugar donde se describe el elemento de sintaxis  respectiva. Esta secci\u00f3n s\u00f3lo existe para aconsejar la existencia y  resumir los prop\u00f3sitos de estos personajes.</p> <ul> <li>Una se\u00f1al de d\u00f3lar (<code>$</code>) seguido de d\u00edgitos se utiliza para representar un par\u00e1metro posicional  en el cuerpo de una definici\u00f3n de funci\u00f3n o una declaraci\u00f3n preparada.  En otros contextos el signo del d\u00f3lar puede ser parte de un  identificador o una constante de cuerda cosida en d\u00f3lares.</li> <li>Parentesis (<code>()</code>) tener su significado habitual de las expresiones de grupo y hacer  cumplir precedencia. En algunos casos se requieren entre par\u00e9ntesis como parte de la sintaxis fija de un comando SQL en particular.</li> <li>Brackets (<code>[]</code>) se utilizan para seleccionar los elementos de un array. V\u00e9ase la secci\u00f3n 8.15 para m\u00e1s informaci\u00f3n sobre los arrays.</li> <li>Comas (<code>,</code>) se utilizan en algunas construcciones sint\u00e1cticas para separar los elementos de una lista.</li> <li>El punto y coma (<code>;</code>) pone fin a un comando SQL. No puede aparecer en ninguna parte dentro de un comando, excepto dentro de un identificador constante o cotizado de  cadena.</li> <li>El colon (<code>:</code>) se utiliza para seleccionar las rodajas de los arrays. (V\u00e9ase la secci\u00f3n 8.15.) En ciertos dialectos SQL (como SQL empedernido), el colon se utiliza para prefijar nombres variables.</li> <li>El asterisco (<code>*</code>) se utiliza en algunos contextos para denotar todos los campos de una  fila de mesa o valor compuesto. Tambi\u00e9n tiene un significado especial  cuando se utiliza como argumento de una funci\u00f3n agregada, a saber, que  el agregado no requiere ning\u00fan par\u00e1metro expl\u00edcito.</li> <li>El per\u00edodo (<code>.</code>) se utiliza en constantes num\u00e9ricas, y para separar los nombres de esquema, tabla y columna.</li> </ul>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/04.-Comentarios/","title":"04.-Comentarios","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/04.-Comentarios/#415-comentarios","title":"4.1.5. Comentarios","text":"<p>Un comentario es una secuencia de caracteres que comienzan con  dobles guiones y se extienden hasta el final de la l\u00ednea, por ejemplo:</p> <pre><code>-- Este es un comentario est\u00e1ndar SQL\n</code></pre> <p>Alternativamente, se pueden utilizar comentarios de bloques al estilo C:</p> <pre><code>/* comentario multil\u00ednea\n * con anidaci\u00f3n: /* anidado de bloque comentario */\n *\n</code></pre> <p>donde el comentario comienza con  <code>/*</code>y se extiende a la ocurrencia a juego de <code>*/</code>. Estos comentarios de bloquean nido, como se especifica en el est\u00e1ndar  SQL, pero a diferencia de C, de modo que uno puede comentar bloques m\u00e1s  grandes de c\u00f3digo que podr\u00edan contener comentarios de bloques  existentes.</p> <p>Un comentario se elimina de la secuencia de entrada antes de un  an\u00e1lisis de sintaxis y es reemplazado efectivamente por espacio en  blanco.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/05.-Precedencia%20de%20Operadores/","title":"05.-Precedencia de Operadores","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/05.-Precedencia%20de%20Operadores/#416-operadora-precedencia","title":"4.1.6. Operadora Precedencia","text":"<p>La Tabla 4.2 muestra la precedencia y asociatividad de los operadores en PostgreSQL. La mayor\u00eda de los operadores tienen la misma precedencia y son de  izquierdas. La precedencia y asociatividad de los operadores se conscura en el analizador. A\u00f1adir par\u00e9ntesis si desea que una expresi\u00f3n con  varios operadores se analice de otra manera que no sea lo que implican  las reglas anteriores.</p> <p>Cuadro 4.2. Operadora Precedencia (m\u00e1s alta a m\u00e1s bajo)</p> Operador/Elemento Asociatividad Descripci\u00f3n <code>.</code> a la izquierda separador de nombres de mesa/columna <code>::</code> a la izquierda PostgreSQL -style typecast <code>[</code> <code>]</code> a la izquierda selecci\u00f3n de elementos de array <code>+</code> <code>-</code> derecho, unry plus, unry menos <code>^</code> a la izquierda exponenciaci\u00f3n <code>*</code> <code>/</code> <code>%</code> a la izquierda multiplicaci\u00f3n, divisi\u00f3n, modulo <code>+</code> <code>-</code> a la izquierda adici\u00f3n, resta (cual otro operador) a la izquierda todos los dem\u00e1s operadores nativos y definidos por el usuario <code>BETWEEN</code> <code>IN</code> <code>LIKE</code> <code>ILIKE</code> <code>SIMILAR</code> rango de contenci\u00f3n, membres\u00eda fija, combinaci\u00f3n de cuerdas <code>&lt;</code> <code>&gt;</code> <code>=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;&gt;</code> operadores de comparaci\u00f3n <code>IS</code> <code>ISNULL</code> <code>NOTNULL</code> <code>IS TRUE</code>, <code>IS FALSE</code>, <code>IS NULL</code>, <code>IS DISTINCT FROM</code>, etc. <code>NOT</code> derecho, negaci\u00f3n l\u00f3gica <code>AND</code> a la izquierda conjunci\u00f3n l\u00f3gica <code>OR</code> a la izquierda disyunci\u00f3n l\u00f3gica <p>Tenga en cuenta que las normas de preceder del operador tambi\u00e9n  se aplican a los operadores definidos por el usuario que tengan los  mismos nombres que los operadores incorporados mencionados  anteriormente. Por ejemplo, si usted define un \u201c+\u201doperador para alg\u00fan tipo \u201c+\u201dde datos personalizado tendr\u00e1 la misma precedencia que el operador incorporado, no importa lo que haga el tuyo.</p> <p>Cuando se utiliza un nombre de operador calificado de esquema en el  <code>OPERATOR</code>sintaxis, como por ejemplo en:</p> <pre><code>SELECT 3 OPEROCEr (pg-catalog.) 4;\n</code></pre> <p>el  <code>OPERATOR</code>constructo se toma para tener la precedencia por defecto que se muestra en el cuadro 4.2 para cualquier otro operador. Esto es cierto no importa qu\u00e9 operador espec\u00edfico aparezca dentro <code>OPERATOR()</code>.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/01.-Estructura%20l%C3%A9xica/05.-Precedencia%20de%20Operadores/#nota","title":"Nota","text":"<p>Versiones PostgreSQL antes de 9.5 utilizaron reglas de precedencia del operador ligeramente diferentes. En particular,   <code>&lt;=``&gt;=</code>y  <code>&lt;&gt;</code>utilizado para ser tratados como operadores gen\u00e9ricos;  <code>IS</code>las pruebas utilizadas para tener una mayor prioridad, y  <code>NOT BETWEEN</code>y las construcciones conexas actuaron de manera incoherente, siendo tomadas en algunos casos como con la prioridad de  <code>NOT</code>en lugar de <code>BETWEEN</code>. Estas reglas fueron cambiadas para un mejor cumplimiento de la norma  SQL y para reducir la confusi\u00f3n de un tratamiento inconsistente de  construcciones l\u00f3gicamente equivalentes. En la mayor\u00eda de los casos,  estos cambios no resultar\u00e1n en ning\u00fan cambio de comportamiento, o tal  vez en tales fallas de operador que se pueden resolver a\u00f1adiendo par\u00e9ntesis. Sin embargo, hay casos de  esquina en los que una consulta podr\u00eda cambiar el comportamiento sin que se reporte ning\u00fan error de parsing.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/","title":"Index","text":"<p>Las expresiones de valor se utilizan en una variedad de contextos, como en la lista de destino de la  <code>SELECT</code>comando, como nuevos valores de columna en  <code>INSERT</code>o o <code>UPDATE</code>, o en condiciones de b\u00fasqueda en una serie de comandos. El resultado de una expresi\u00f3n de valor se llama a veces un escalar, para distinguirlo del resultado de una expresi\u00f3n de tabla (que es una  tabla). Por lo tanto, las expresiones de valor tambi\u00e9n se llaman expresiones escalaras (o incluso simplemente expresiones). La sintaxis de la expresi\u00f3n permite el c\u00e1lculo de valores de partes  primitivas usando aritm\u00e9tica, l\u00f3gica, configuraci\u00f3n y otras operaciones.</p> <p>Una expresi\u00f3n de valor es una de las siguientes:</p> <ul> <li>Un valor constante o literal</li> <li>Una columna de referencia</li> <li>Una referencia de par\u00e1metros posicionales, en el cuerpo de una definici\u00f3n de funci\u00f3n o declaraci\u00f3n preparada</li> <li>Una expresi\u00f3n subscripti</li> <li>Una expresi\u00f3n de selecci\u00f3n de campo</li> <li>Una invocaci\u00f3n de operador</li> <li>Una llamada de funci\u00f3n</li> <li>Una expresi\u00f3n agregada</li> <li>Llama de funci\u00f3n de ventana</li> <li>Un elenco tipo</li> <li>Una expresi\u00f3n de cotejar</li> <li>Una subecuencia escalar</li> <li>Un constructor de matrices</li> <li>Un constructor de filas</li> <li>Otra expresi\u00f3n de valor entre par\u00e9ntesis (utilizada para las subexpresiones de grupo y sobrediferencia)</li> </ul> <p>Adem\u00e1s de esta lista, hay una serie de construcciones que pueden  clasificarse como una expresi\u00f3n pero no siguen ninguna regla general de  sintaxis. Estos generalmente tienen la sem\u00e1ntica de una funci\u00f3n u  operador y se explican en la ubicaci\u00f3n apropiada en el cap\u00edtulo 9. Un ejemplo es el  <code>IS NULL</code>cl\u00e1usula.</p> <p>Ya hemos discutido las constantes en la secci\u00f3n 4.1.2. En las secciones siguientes se examinan las opciones restantes.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/01.-Referencias%20de%20columnas/","title":"01.-Referencias de columnas","text":"<p>Una columna puede ser referenciada en el formulario:</p> <pre><code>correlation.columnname\n</code></pre> <p><code>correlation</code>es el nombre de una tabla (posiblemente cualificada con un nombre de  esquema), o un alias para una tabla definida por medio de una  <code>FROM</code>cl\u00e1usula. El nombre de correlaci\u00f3n y el punto separador se pueden omitir si el  nombre de la columna es \u00fanico en todas las tablas que se utilizan en la  consulta actual. (V\u00e9ase tambi\u00e9n el cap\u00edtulo 7).</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/02.-Par%C3%A1metros%20de%20posici%C3%B3n/","title":"02.-Par\u00e1metros de posici\u00f3n","text":"<p>Se utiliza una referencia del par\u00e1metro posicional para indicar un  valor que se suministra externamente a una instrucci\u00f3n SQL. Los  par\u00e1metros se utilizan en las definiciones de la funci\u00f3n SQL y en  consultas preparadas. Algunas bibliotecas de clientes tambi\u00e9n admiten  especificar los valores de datos por separado de la cadena de comandos  SQL, en cuyo caso se utilizan par\u00e1metros para referirse a los valores de datos fuera de l\u00ednea. La forma de referencia de un par\u00e1metro es:</p> <pre><code>$number\n</code></pre> <p>Por ejemplo, considere la definici\u00f3n de una funci\u00f3n, <code>dept</code>, como:</p> <pre><code>CREATE FUNCTION dept(texto) RETURNS dept\n    AS $$ SELECT * DESDE Dept DOHERE name = $1 $$\n    LANGUAGE SQL;\n</code></pre> <p>Aqu\u00ed el  <code>$1</code>hace referencia al valor del primer argumento de la funci\u00f3n cuando se invoca la funci\u00f3n.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/03.-Suscriptores/","title":"03.-Suscriptores","text":"<p>Si una expresi\u00f3n produce un valor de un tipo de array, entonces  un elemento espec\u00edfico del valor de array puede ser extra\u00eddo por escrito</p> <pre><code>expression[subscript]\n</code></pre> <p>o varios elementos adyacentes (una rebanada de matriz -) se pueden extraer por escrito</p> <pre><code>expression[lower_subscript:upper_subscript]\n</code></pre> <p>(Ah\u00ed, los corchetes  <code>[ ]</code>est\u00e1n destinados a aparecer literalmente.) Cada uno  <code>subscript</code>es en s\u00ed misma una expresi\u00f3n, que se redondear\u00e1 al valor entero m\u00e1s cercano.</p> <p>En general la matriz  <code>expression</code>debe ser entre par\u00e9ntesis, pero los par\u00e9ntesis se pueden omitir cuando la  expresi\u00f3n a subscripte es s\u00f3lo una referencia de columna o par\u00e1metro  posicional. Adem\u00e1s, m\u00faltiples subscripts se pueden concatenar cuando la  matriz original es multidimensional. Por ejemplo:</p> <pre><code>mytable.arraycolumn[4]\nmytable.two-d-column[17][34]\n$1[10:42]\n(arrayfunction (a,b))[42]\n</code></pre> <p>Los par\u00e9ntesis en el \u00faltimo ejemplo son requeridos. V\u00e9ase Secci\u00f3n 8.15 para m\u00e1s informaci\u00f3n sobre los arrays.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/04.-Selecci%C3%B3n%20de%20Campo/","title":"04.-Selecci\u00f3n de Campo","text":"<p>Si una expresi\u00f3n produce un valor de un tipo compuesto (tipo de  fila), entonces un campo espec\u00edfico de la fila se puede extraer por  escrito</p> <pre><code>expression.fieldname\n</code></pre> <p>En general la fila  <code>expression</code>Debe ser entre par\u00e9ntesis, pero los par\u00e9ntesis pueden omitirse cuando la  expresi\u00f3n que se seleccionar\u00e1 es s\u00f3lo una referencia de tabla o  par\u00e1metro posicional. Por ejemplo:</p> <pre><code>mytable.mycolumn\n$1.somecolumn\n(glifunction (a,b)).col3\n</code></pre> <p>(Por lo tanto, una referencia de columna cualificada es en  realidad s\u00f3lo un caso especial de la sintaxis de selecci\u00f3n de campo.) Un caso especial importante es la extracci\u00f3n de un campo de una columna de tabla de un tipo compuesto:</p> <pre><code>(compositecol).somefieldfield\n(mytable.compositecol).somefield\n</code></pre> <p>Los par\u00e9ntesis se requieren aqu\u00ed para demostrar que  <code>compositecol</code>es un nombre de columna, no un nombre de tabla, o que  <code>mytable</code>es un nombre de tabla no un nombre de esquema en el segundo caso.</p> <p>Usted puede pedir todos los campos de un valor compuesto por la escritura <code>.*</code>:</p> <pre><code>(compositecol).*\n</code></pre> <p>Esta notaci\u00f3n se comporta de manera diferente dependiendo del contexto; v\u00e9ase la secci\u00f3n 8.16.5 para m\u00e1s detalles.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/05.-Invocatorias%20de%20operador/","title":"05.-Invocatorias de operador","text":"<p>Hay dos posibles sintaxis para una invocaci\u00f3n de operador:</p> <code>expression</code><code>operator</code><code>expression</code>(operador de infixbinario) <code>operator</code><code>expression</code>(operador prefijo unitario) <p>donde el  <code>operator</code>token sigue las reglas de sintaxis de la Secci\u00f3n 4.1.3, o es una de las palabras clave <code>AND</code>, <code>OR</code>, y <code>NOT</code>, o es un nombre de operador cualificado en la forma:</p> <pre><code>OPERATOR(schema.operatorname)\n</code></pre> <p>Qu\u00e9 operadores particulares existen y si no son binarios o  binarios depende de lo que los operadores hayan sido definidos por el  sistema o por el usuario. El cap\u00edtulo 9 describe a los operadores incorporados.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/06.-Llamadas%20de%20funci%C3%B3n/","title":"06.-Llamadas de funci\u00f3n","text":"<p>La sintaxis para una llamada de funci\u00f3n es el nombre de una  funci\u00f3n (posiblemente calificada con un nombre de esquema), seguida de  su lista de argumentos adjunta entre par\u00e9ntesis:</p> <pre><code> function_name( expression[,  expression... ]] )\n</code></pre> <p>Por ejemplo, la siguiente calcula la ra\u00edz cuadrada de 2:</p> <pre><code>sqrt(2)\n</code></pre> <p>La lista de funciones incorporadas est\u00e1 en el Cap\u00edtulo 9. El usuario puede a\u00f1adir otras funciones.</p> <p>Al emitir consultas en una base de datos donde algunos usuarios desconf\u00edan de otros usuarios, observen precauciones de seguridad de la  al escribir llamadas de funci\u00f3n.</p> <p>Los argumentos pueden tener nombres adjuntos opcionalmente. V\u00e9ase la secci\u00f3n 4.3 para m\u00e1s detalles.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/06.-Llamadas%20de%20funci%C3%B3n/#nota","title":"Nota","text":"<p>Una funci\u00f3n que toma un solo argumento de tipo compuesto puede  llamarse opcionalmente usando sintaxis de selecci\u00f3n de campo, y a la  inversa la selecci\u00f3n de campo se puede escribir en estilo funcional. Es  decir, las anotaciones  <code>col(table)</code>y  <code>table.col</code>son intercambiables. Este comportamiento no es est\u00e1ndar SQL, pero se proporciona en PostgreSQL porque permite el uso de funciones para emular campos computados. Para m\u00e1s informaci\u00f3n v\u00e9ase la secci\u00f3n 8.16.5.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/07.-Expresiones%20agregadas/","title":"07.-Expresiones agregadas","text":"<p>Una expresi\u00f3n agregada representa la aplicaci\u00f3n de una funci\u00f3n agregada a trav\u00e9s de las filas  seleccionadas por una consulta. Una funci\u00f3n agregada reduce m\u00faltiples  entradas a un solo valor de salida, como la suma o media de los insumos. La sintaxis de una expresi\u00f3n agregada es una de las siguientes:</p> <pre><code> aggregate_name( expression[ , ... ] [  order_by_clause]) [ FILTER (DADRE)  filter_clause) ]\n aggregate_name(Todo  expression[ , ... ] [  order_by_clause]) [ FILTER (DADRE)  filter_clause) ]\n aggregate_name(DISTINCT  expression[ , ... ] [  order_by_clause]) [ FILTER (DADRE)  filter_clause) ]\n aggregate_name( *) [ FILTER (DRETRO)  filter_clause) ]\n aggregate_name( [  expression[ , ... ] ] ] ) CONIN GRUPO (  order_by_clause[ FILTER (AQUI  filter_clause) ]\n</code></pre> <p>d\u00f3nde  <code>aggregate_name</code>es un agregado previamente definido (posiblemente calificado con un nombre de esquema) y  <code>expression</code>es cualquier expresi\u00f3n de valor que no contenga una expresi\u00f3n agregada o una llamada de funci\u00f3n de la ventana. La opcional  <code>order_by_clause</code>y  <code>filter_clause</code>se describen a continuaci\u00f3n.</p> <p>La primera forma de expresi\u00f3n agregada invoca el agregado una vez para cada fila de entrada. La segunda forma es la misma que la primera, desde  <code>ALL</code>es  el predeterminado. La tercera forma invoca el agregado una vez por cada  valor distinto de la expresi\u00f3n (o distinto conjunto de valores, para  expresiones m\u00faltiples) que se encuentra en las filas de entrada. La  cuarta forma invoca el agregado una vez para cada fila de entrada; ya  que no se especifica ning\u00fan valor de entrada en particular, generalmente s\u00f3lo es \u00fatil para el  <code>count(*)</code>funci\u00f3n agregada. El \u00faltimo formulario se utiliza con funciones agregadas ordenadas, que se describen a continuaci\u00f3n.</p> <p>La mayor\u00eda de las funciones agregadas ignoran los insumos nulos,  de modo que las filas en las que una o m\u00e1s de las expresiones (s) rinden null se descartan. Esto puede ser asumido como verdadero, a menos que  se especifique lo contrario, para todos los agregados incorporados.</p> <p>Por ejemplo,  <code>count(*)</code>produce el n\u00famero total de filas de entradas;  <code>count(f1)</code>c) rinde el n\u00famero de filas de entradas en las que  <code>f1</code>no es nido, desde entonces  <code>count</code>ignora nulos; y  <code>count(distinct f1)</code>produce el n\u00famero de distintos valores no nulos de <code>f1</code>.</p> <p>Normalmente, las filas de entrada se alimentan a la funci\u00f3n  agregada en un orden no especificado. En muchos casos esto no importa;  por ejemplo,  <code>min</code>produce el mismo resultado sin importar en qu\u00e9 orden reciba las entradas. Sin embargo, algunas funciones agregadas (como  <code>array_agg</code>y <code>string_agg</code>) producir resultados que dependen del ordenamiento de las filas de entrada. Cuando se utiliza dicho agregado, la opcional  <code>order_by_clause</code>se puede utilizar para especificar el pedido deseado. El  <code>order_by_clause</code>tiene la misma sintaxis que para un nivel de consulta  <code>ORDER BY</code>cl\u00e1usula, como se describe en la secci\u00f3n 7.5, excepto que sus expresiones son siempre expresiones justas y no pueden ser nombres o n\u00fameros de salida-columna. Por ejemplo:</p> <pre><code>SELECT array.agg(a ORDEN POR b DESC) DESDE tabla;\n</code></pre> <p>Cuando se trate de funciones agregadas de m\u00faltiples arb p\u00e1rrafo, tenga en cuenta que el  <code>ORDER BY</code>la cl\u00e1usula va despu\u00e9s de todos los argumentos agregados. Por ejemplo, escriba esto:</p> <pre><code>SELECT string-agg (a, ',' ORDEnte BY a) DESDE tabla;\n</code></pre> <p>Esto no es as\u00ed:</p> <pre><code>SELECT string-agg(a ORDEN POR una, ',') DESDE tabla; -- incorrecto\n</code></pre> <p>Este \u00faltimo es sint\u00e1cticamente v\u00e1lido, pero representa una llamada de una funci\u00f3n agregada de un solo lenguaje con dos  <code>ORDER BY</code>llaves (la segunda es bastante in\u00fatil ya que es una constante).</p> <p>Si  <code>DISTINCT</code>se especifica adem\u00e1s de un <code>order_by_clause</code>, entonces todo el  <code>ORDER BY</code>las expresiones deben coincidir con los argumentos regulares del agregado;  es decir, no se puede ordenar en una expresi\u00f3n que no est\u00e1 incluida en  el  <code>DISTINCT</code>lista.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/07.-Expresiones%20agregadas/#nota","title":"Nota","text":"<p>La capacidad de especificar ambas  <code>DISTINCT</code>y  <code>ORDER BY</code>en una funci\u00f3n agregada es una extensi\u00f3n PostgreSQL.</p> <p>Colocaci\u00f3n  <code>ORDER BY</code>Dentro de la lista de argumentos regulares del agregado, como se ha descrito  hasta ahora, se utiliza al ordenar las filas de entrada para agregados  estad\u00edsticos y de uso general, para los que el pedido es opcional. Hay  una subclase de funciones agregadas llamadas agregados ordenados para los cuales un  <code>order_by_clause</code>se requiere, por lo general porque el c\u00e1lculo del agregado es s\u00f3lo sensato en  t\u00e9rminos de un pedido espec\u00edfico de sus filas de entrada. Ejemplos  t\u00edpicos de agregados ordenados incluyen c\u00e1lculos de rango y percentil.  Para un agregado ordenado, el  <code>order_by_clause</code>est\u00e1 escrito dentro <code>WITHIN GROUP (...)</code>, como se muestra en la alternativa de sintaxis final anterior. Las expresiones en el  <code>order_by_clause</code>se eval\u00faan una vez por fila de entradas al igual que los argumentos agregados regulares, ordenados seg\u00fan el <code>order_by_clause</code>'s requisitos, y alimentados a la funci\u00f3n agregada como argumentos de entrada. (Esto no es diferente al caso de un no- <code>WITHIN GROUP</code><code>order_by_clause</code>, que no se trata como argumentos (s) a la funci\u00f3n agregada.) Los argumentos expresiones anteriores <code>WITHIN GROUP</code>, en su caso, se denominan argumentos directos para distinguirlos de los argumentos agregados enumerados en el <code>order_by_clause</code>. A diferencia de los argumentos agregados regulares, los argumentos  directos se eval\u00faan s\u00f3lo una vez por llamada agregada, no una vez por  fila de entrada. Esto significa que pueden contener variables s\u00f3lo si  esas variables est\u00e1n agrupadas por <code>GROUP BY</code>; esta restricci\u00f3n es la misma que si los argumentos directos no  estuvieran dentro de una expresi\u00f3n agregada en absoluto. Los argumentos  directos se utilizan t\u00edpicamente para cosas como fracciones percentiles, que s\u00f3lo tienen sentido como un c\u00e1lculo de un solo valor por  agregaci\u00f3n. La lista de argumentos directos puede estar vac\u00eda; en este  caso, escribir s\u00f3lo  <code>()</code>no <code>(*)</code>. (PostgreSQL aceptar\u00e1 cualquiera de las ortaciones, pero s\u00f3lo la primera manera se ajusta al est\u00e1ndar SQL.)</p> <p>Un ejemplo de una llamada agregada ordenada es:</p> <pre><code>SELECT percentile.cont. (0.5) GRUPO CONIN (ORDER BY income) DESDE hogares;\n percentile.cont\n----------------\n           50489\n</code></pre> <p>que obtiene el percentil 50o, o valor medio de la  <code>income</code>columna de la tabla <code>households</code>. Aqu\u00ed,  <code>0.5</code>es un argumento directo; no tendr\u00eda sentido que la fracci\u00f3n percentil fuera un valor que variara a trav\u00e9s de las filas.</p> <p>Si  <code>FILTER</code>se especifica, entonces s\u00f3lo las filas de entrada para las que el  <code>filter_clause</code>las evaluaciones a la verdadera se alimentan a la funci\u00f3n agregada; otras filas se descartan. Por ejemplo:</p> <pre><code>SELECT\n    conteo (\"*) AS sin filtrar,\n    conteo(*) FILTER (WHERE i 5) AS filtrado\nDESDE Generaseries (1,10) AS s(i);\n sin filtrar .\n-----------------------\n         10 4\n(1 fila)\n</code></pre> <p>Las funciones agregadas predefinidas se describen en . El usuario puede a\u00f1adir otras funciones agregadas.</p> <p>Una expresi\u00f3n agregada s\u00f3lo puede aparecer en la lista de resultados o  <code>HAVING</code>cl\u00e1usula de una  <code>SELECT</code>comando. Est\u00e1 prohibido en otras cl\u00e1usulas, como <code>WHERE</code>, porque esas cl\u00e1usulas se eval\u00faan l\u00f3gicamente antes de que se forme los resultados de los agregados.</p> <p>Cuando una expresi\u00f3n agregada aparece en una subcoquer\u00eda (ver secci\u00f3n 4.2.11 y secci\u00f3n 9.23), el agregado se eval\u00faa normalmente sobre las filas de la subcr\u00e1til. Pero se produce una excepci\u00f3n si los argumentos del agregado (y  <code>filter_clause</code>si alguno) contiene s\u00f3lo variables de nivel externo: el agregado pertenece al nivel externo m\u00e1s cercano, y se eval\u00faa sobre las filas de esa  consulta. La expresi\u00f3n agregada en su conjunto es entonces una  referencia externa para la subquer\u00eda en la que aparece, y act\u00faa como una constante sobre cualquier evaluaci\u00f3n de esa subcoquer\u00eda. La restricci\u00f3n de aparecer s\u00f3lo en la lista de resultados o  <code>HAVING</code>cl\u00e1usula se aplica con respecto al nivel de consulta al que pertenece el agregado.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/08.-Llamadas%20de%20funci%C3%B3n%20de%20ventanas/","title":"08.-Llamadas de funci\u00f3n de ventanas","text":"<p>Una llamada de funci\u00f3n de la ventana representa la aplicaci\u00f3n de una funci\u00f3n similar a la de agregado sobre  alguna parte de las filas seleccionadas por una consulta. A diferencia  de las llamadas agregadas no de ventana, esto no est\u00e1 ligado a la  agrupaci\u00f3n de las filas seleccionadas en una sola fila de salida. Sin  embargo, la funci\u00f3n de la ventana tiene acceso a todas las filas que  formar\u00edan parte del grupo actual de acuerdo con la especificaci\u00f3n de  agrupaci\u00f3n ( <code>PARTITION BY</code>lista) de la llamada de la funci\u00f3n de la ventana. La sintaxis de una llamada de funci\u00f3n de la ventana es una de las siguientes:</p> <pre><code> function_name( expression[,  expression... ]]) [ FILTER (DADRE)  filter_clause) ] OVER \n window_namefunction_name( expression[,  expression... ]]) [ FILTER (DADRE)  filter_clause) ] OVER (  window_definition)\n function_name( *) [ FILTER (DRETRO)  filter_clause) ] OVER \n window_namefunction_name( *) [ FILTER (DRETRO)  filter_clause) ] OVER (  window_definition)\n</code></pre> <p>d\u00f3nde  <code>window_definition</code>tiene la sintaxis</p> <pre><code>[  existing_window_name]\n[ PARTITION BY  expression[, ...] ]\n[ ORDEN por  expression[ASC - DESC - USING  operator] [ NULLS - FIRST . LAST . ] [, ...] ]\n[  frame_clause]\n</code></pre> <p>La opcional  <code>frame_clause</code>puede ser uno de</p> <pre><code>* RANGE ROWS - GRUPOS -  frame_start[  frame_exclusion]\nRANGE - ROWS - GRUPOS BETWEEN - BETWEEN  frame_startY  frame_end[  frame_exclusion]\n</code></pre> <p>d\u00f3nde  <code>frame_start</code>y  <code>frame_end</code>puede ser uno de</p> <pre><code>PRECED UNBOUNDEDING\n offsetPRECEDING\nCURRENTE ROW\n offsetSEGUNDO\nUNBOUNDED SEGUNDO\n</code></pre> <p>y  <code>frame_exclusion</code>puede ser uno de</p> <pre><code>EXCLUDE CURRENT ROW\nGRUPO EXCLUDE\nTIES EXCLUDE\nEXCLUDE NO OTROS\n</code></pre> <p>Aqu\u00ed,  <code>expression</code>representa cualquier expresi\u00f3n de valor que no contenga en s\u00ed misma llamadas de funci\u00f3n de la ventana.</p> <p><code>window_name</code>es una referencia a una especificaci\u00f3n de ventana designada definida en la consulta de  <code>WINDOW</code>cl\u00e1usula. Alternativamente, un lleno  <code>window_definition</code>se puede administrar entre par\u00e9ntesis, usando la misma sintaxis que para definir una ventana nombrada en el  <code>WINDOW</code>cl\u00e1usula; consulte la p\u00e1gina de referencia SELECT para m\u00e1s detalles. Vale la pena se\u00f1alar eso.  <code>OVER wname</code>no es exactamente equivalente a <code>OVER (wname ...)</code>; este \u00faltimo implica copiar y modificar la definici\u00f3n de la ventana, y  ser\u00e1 rechazada si la especificaci\u00f3n de la ventana de referencia incluye  una cl\u00e1usula marco.</p> <p>El  <code>PARTITION BY</code>la cl\u00e1usula agrupa las filas de la consulta en particiones, que se procesan por separado por la funci\u00f3n de la ventana.  <code>PARTITION BY</code>trabaja de manera similar a un nivel de consulta  <code>GROUP BY</code>cl\u00e1usula, excepto que sus expresiones son siempre expresiones justas y no pueden  ser nombres o n\u00fameros de columna de salida. Sin <code>PARTITION BY</code>, todas las filas producidas por la consulta se tratan como una sola partici\u00f3n. El  <code>ORDER BY</code>cl\u00e1usula determina el orden en que las filas de una partici\u00f3n son procesadas por la funci\u00f3n de la ventana. Funciona de manera similar a un nivel de  consulta  <code>ORDER BY</code>cl\u00e1usula, pero tampoco puede utilizar nombres o n\u00fameros de columna de salida. Sin <code>ORDER BY</code>, las filas se procesan en un orden no especificado.</p> <p>El  <code>frame_clause</code>especifica el conjunto de filas que constituyen el marco de la ventana, que es un subconjunto de la partici\u00f3n actual, para aquellas funciones  de ventana que act\u00faan en el marco en lugar de toda la partici\u00f3n. El  conjunto de filas en el marco puede variar dependiendo de qu\u00e9 fila es la fila actual. El marco se puede especificar en <code>RANGE</code>,  <code>ROWS</code>o o  <code>GROUPS</code>modo; en cada caso, se ejecuta desde el  <code>frame_start</code>a la <code>frame_end</code>. Si  <code>frame_end</code>se omite, el fin de los defectos de la <code>CURRENT ROW</code>.</p> <p>A  <code>frame_start</code>de  <code>UNBOUNDED PRECEDING</code>significa que el marco comienza con la primera fila de la partici\u00f3n, y de manera similar a  <code>frame_end</code>de  <code>UNBOUNDED FOLLOWING</code>significa que el marco termina con la \u00faltima fila de la partici\u00f3n.</p> <p>En  <code>RANGE</code>o o  <code>GROUPS</code>modo, a  <code>frame_start</code>de  <code>CURRENT ROW</code>significa que el marco comienza con la primera fila de pares de la fila actual (una fila que la ventana es  <code>ORDER BY</code>las cl\u00e1usulas clasifican como equivalente a la fila actual), mientras que a  <code>frame_end</code>de  <code>CURRENT ROW</code>significa que el marco termina con la \u00faltima fila de pares de la fila actual. En  <code>ROWS</code>modo,  <code>CURRENT ROW</code>simplemente significa la fila actual.</p> <p>En el   <code>offset</code><code>PRECEDING</code>y   <code>offset</code><code>FOLLOWING</code>opciones de marco, el  <code>offset</code>debe ser una expresi\u00f3n que no contenga ninguna variable, funciones agregadas o funciones de ventana. El significado de la  <code>offset</code>depende del modo de marco:</p> <ul> <li>En  <code>ROWS</code>modo, el  <code>offset</code>debe producir un n\u00famero entero no n\u00edti, no negativo, y la opci\u00f3n significa  que el marco comienza o termina el n\u00famero especificado de filas antes o  despu\u00e9s de la fila actual.</li> <li>En  <code>GROUPS</code>modo, el  <code>offset</code>de nuevo debe ceder un n\u00famero entero no negativo, no negativo, y la opci\u00f3n significa que el marco comienza o termina el n\u00famero especificado de grupos de pares antes o despu\u00e9s del grupo de pares de la fila actual, donde un grupo de pares es un conjunto de filas que son equivalentes en el  <code>ORDER BY</code>ordenando. (Debe haber un  <code>ORDER BY</code>cl\u00e1usula en la definici\u00f3n de ventana a utilizar  <code>GROUPS</code>modo.)</li> <li>En  <code>RANGE</code>modo, estas opciones requieren que la  <code>ORDER BY</code>cl\u00e1usula especificar exactamente una columna. El  <code>offset</code>especifica la diferencia m\u00e1xima entre el valor de esa columna en la fila actual y  su valor en las filas anteriores o siguientes del marco. Tipo de datos  de la  <code>offset</code>la expresi\u00f3n var\u00eda dependiendo del tipo de datos de la columna de pedido.  Para las columnas de pedido num\u00e9ricos es t\u00edpicamente del mismo tipo que  la columna de pedido, pero para las columnas de pedido de fecha es un <code>interval</code>. Por ejemplo, si la columna de pedido es de tipo  <code>date</code>o o <code>timestamp</code>, uno podr\u00eda escribir <code>RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING</code>. El  <code>offset</code>Todav\u00eda se requiere que no sea nenal y no negativo, aunque el significado de no negativo depende de su tipo de datos.</li> </ul> <p>En cualquier caso, la distancia al final del marco est\u00e1 limitada  por la distancia al final de la partici\u00f3n, de modo que para las filas  cerca de los extremos de partici\u00f3n el marco podr\u00eda contener menos filas  que en otros lugares.</p> <p>Note que en ambos  <code>ROWS</code>y  <code>GROUPS</code>modo,  <code>0 PRECEDING</code>y  <code>0 FOLLOWING</code>son equivalentes a <code>CURRENT ROW</code>. Esto normalmente se mantiene en  <code>RANGE</code>modo tambi\u00e9n, para un significado espec\u00edfico de tipo de datos apropiado de cerozero.</p> <p>El  <code>frame_exclusion</code>la opci\u00f3n permite excluir las filas alrededor de la fila actual del marco, incluso si se incluir\u00edan de acuerdo con las opciones de inicio de  fotogramas y final de marco.  <code>EXCLUDE CURRENT ROW</code>excluye la fila actual del marco.  <code>EXCLUDE GROUP</code>excluye la fila actual y sus pares de pedidos del marco.  <code>EXCLUDE TIES</code>excluye a cualquier par de la fila actual del marco, pero no la fila actual en s\u00ed.  <code>EXCLUDE NO OTHERS</code>Simplemente especifica expl\u00edcitamente el comportamiento predeterminado de no excluir la fila actual o sus pares.</p> <p>La opci\u00f3n de enmarcado por defecto es <code>RANGE UNBOUNDED PRECEDING</code>, que es lo mismo que <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>. Con <code>ORDER BY</code>, esto establece el marco para ser todas las filas de la partici\u00f3n de arranque a trav\u00e9s de la \u00faltima fila actual  <code>ORDER BY</code>par. Sin <code>ORDER BY</code>, esto significa que todas las filas de la partici\u00f3n est\u00e1n incluidas en  el marco de la ventana, ya que todas las filas se convierten en pares de la fila actual.</p> <p>Restricciones son que  <code>frame_start</code>no puede ser <code>UNBOUNDED FOLLOWING</code>,  <code>frame_end</code>no puede ser <code>UNBOUNDED PRECEDING</code>, y el  <code>frame_end</code>la elecci\u00f3n no puede aparecer antes en la lista anterior de  <code>frame_start</code>y  <code>frame_end</code>opciones que la  <code>frame_start</code>La elecci\u00f3n lo hace, por ejemplo.  <code>RANGE BETWEEN CURRENT ROW AND *</code>offset<code>* PRECEDING</code>no est\u00e1 permitido. Pero, por ejemplo,  <code>ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING</code>est\u00e1 permitido, aunque nunca seleccionar\u00eda ninguna fila.</p> <p>Si  <code>FILTER</code>se especifica, entonces s\u00f3lo las filas de entrada para las que el  <code>filter_clause</code>Las evaluaciones a la verdad se alimentan a la funci\u00f3n de la ventana; se  descartan otras filas. S\u00f3lo funciones de ventana que son agregados  aceptan un  <code>FILTER</code>cl\u00e1usula.</p> <p>Las funciones de ventana incorporadas se describen en la Tabla 9.64. El usuario puede a\u00f1adir otras funciones de ventana. Adem\u00e1s, cualquier  agregado general o estad\u00edstico incorporado o definido por el usuario se  puede utilizar como una funci\u00f3n de ventana. (Los agregados de conjuntos  ordenados e hipot\u00e9ticas no se pueden utilizar actualmente como funciones de ventanas.)</p> <p>Las sintaxis usando  <code>*</code>se utilizan para llamar a funciones agregadas sin par\u00e1metro como funciones de ventana, por ejemplo <code>count(*) OVER (PARTITION BY x ORDER BY y)</code>. El asterisco (<code>*</code>) habitualmente no se utiliza para funciones espec\u00edficas de la ventana. Funciones espec\u00edficas de la ventana no permiten  <code>DISTINCT</code>o o  <code>ORDER BY</code>para ser usados dentro de la lista de argumentos de funci\u00f3n.</p> <p>Las llamadas de la funci\u00f3n de ventanas s\u00f3lo se permiten en el  <code>SELECT</code>lista y la  <code>ORDER BY</code>cl\u00e1usula de la consulta.</p> <p>Puede encontrarse m\u00e1s informaci\u00f3n sobre las funciones de la ventana en la secci\u00f3n 3.5, secci\u00f3n 9.22 y en la secci\u00f3n 7.2.5.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/09.-Tipos%20de%20fusi%C3%B3n/","title":"09.-Tipos de fusi\u00f3n","text":"<p>Un yeso especifica una conversi\u00f3n de un tipo de datos a otro. PostgreSQL acepta dos sintaxis equivalentes para el moldes de tipo:</p> <pre><code>CAST (  expressionAS  type)\nexpression::type\n</code></pre> <p>El  <code>CAST</code>sintaxis se ajusta a SQL; la sintaxis con  <code>::</code>es el uso hist\u00f3rico de PostgreSQL.</p> <p>Cuando un elenco se aplica a una expresi\u00f3n de valor de un tipo  conocido, representa una conversi\u00f3n de tipo de tiempo corrido. El elenco s\u00f3lo tendr\u00e1 \u00e9xito si se ha definido una operaci\u00f3n de conversi\u00f3n de tipo adecuada. Observe que esto es sutilmente diferente del uso de moldes  con constantes, como se muestra en la Secci\u00f3n 4.1.2.7. Un elenco aplicado a una cadena sin adornable literal representa la  asignaci\u00f3n inicial de un tipo a un valor constante literal, por lo que  tendr\u00e1 \u00e9xito para cualquier tipo (si el contenido de la cadena literal  son sintaxis de entrada aceptable para el tipo de datos).</p> <p>Por lo general, se puede omitir un elenco expl\u00edcito si no hay  ambiguedad en cuanto al tipo que debe producir una expresi\u00f3n de valor  (por ejemplo, cuando se asigna a una columna de tabla); el sistema  aplicar\u00e1 autom\u00e1ticamente un tipo fundido en tales casos. Sin embargo, el casting autom\u00e1tico s\u00f3lo se hace para los elencos que est\u00e1n marcados. OK para aplicar impl\u00edcitamente en los cat\u00e1logos de sistemas. Otros elencos deben ser invocados con  sintaxis expl\u00edcita de fundici\u00f3n. Esta restricci\u00f3n pretende evitar que se apliquen en silencio las conversiones sorprendentes.</p> <p>Tambi\u00e9n es posible especificar un molno tipo usando una sintaxis similar a una funci\u00f3n:</p> <pre><code> typename(  expression)\n</code></pre> <p>Sin embargo, esto s\u00f3lo funciona para tipos cuyos nombres tambi\u00e9n son v\u00e1lidos como nombres de funci\u00f3n. Por ejemplo,  <code>double precision</code>no se puede utilizar de esta manera, sino el equivalente  <code>float8</code>- Puede. Tambi\u00e9n, los nombres <code>interval</code>, <code>time</code>, y  <code>timestamp</code>S\u00f3lo se puede utilizar de esta manera si se citan dos veces, debido a  conflictos sint\u00e1cticas. Por lo tanto, el uso de la sintaxis de fundici\u00f3n similar a la funci\u00f3n conduce a inconsistencias y probablemente debe ser evitado.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/09.-Tipos%20de%20fusi%C3%B3n/#nota","title":"Nota","text":"<p>La sintaxis tipo funci\u00f3n es de hecho s\u00f3lo una llamada de  funci\u00f3n. Cuando una de las dos sintaxis de fundici\u00f3n est\u00e1ndar se utiliza para hacer una conversi\u00f3n en tiempo de ejecuci\u00f3n, invocar\u00e1 internamente una funci\u00f3n registrada para realizar la conversi\u00f3n. Por convenci\u00f3n,  estas funciones de conversi\u00f3n tienen el mismo nombre que su tipo de  salida, y por lo tanto la sintaxis de funci\u00f3n no es m\u00e1s que una invocaci\u00f3n directa de la funci\u00f3n de conversi\u00f3n  subyacente. Obviamente, esto no es algo en lo que una aplicaci\u00f3n  port\u00e1til deba confiar. Para m\u00e1s detalles, v\u00e9ase CREATE CAST.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/10.-Expresiones%20de%20la%20colaci%C3%B3n/","title":"10.-Expresiones de la colaci\u00f3n","text":"<p>El  <code>COLLATE</code>cl\u00e1usula anula la recopilaci\u00f3n de una expresi\u00f3n. Se adjunta a la expresi\u00f3n que se aplica a:</p> <pre><code> exprCOLLATE collation\n</code></pre> <p>d\u00f3nde  <code>collation</code>es un identificador posiblemente calificado de esquema. El  <code>COLLATE</code>la cl\u00e1usula se une m\u00e1s apretada que los operadores; los par\u00e9ntesis pueden utilizarse cuando sea necesario.</p> <p>Si no se especifica expl\u00edcitamente la recopilaci\u00f3n, el sistema de base de datos deriva un cocoteo de las columnas involucradas en la  expresi\u00f3n, o predetermina la recopilaci\u00f3n por defecto de la base de  datos si no hay ninguna columna involucrada en la expresi\u00f3n.</p> <p>Los dos usos comunes de la  <code>COLLATE</code>la cl\u00e1usula est\u00e1 anulada el orden de la clase en un  <code>ORDER BY</code>cl\u00e1usula, por ejemplo:</p> <pre><code>SELECT a, b, c DESDE tbl WHERE ... ORDEN POR una \"C\" COLLATE;\n</code></pre> <p>y la cocoteo de una funci\u00f3n u llamada al operador que tenga resultados sensibles a la localidad, por ejemplo:</p> <pre><code>SELECT * DESDE Tbl WHERE a \"foo\" COLLATE \"C\";\n</code></pre> <p>Tenga en cuenta que en este \u00faltimo caso el  <code>COLLATE</code>se adjunta a un argumento de entrada del operador al que deseamos afectar. No importa qu\u00e9 argumento del operador o funci\u00f3n llame a la  <code>COLLATE</code>la cl\u00e1usula se adjunta a, porque la cocoteraci\u00f3n aplicada por el operador o la funci\u00f3n se deriva considerando todos los argumentos, y un expl\u00edcito  <code>COLLATE</code>cl\u00e1usula anular\u00e1 las colisiones de todos los dem\u00e1s argumentos. (Attaching non-matching  <code>COLLATE</code>cl\u00e1usulas a m\u00e1s de un argumento, sin embargo, es un error. Para m\u00e1s detalles, v\u00e9ase la secci\u00f3n 24.2.) As\u00ed, esto da el mismo resultado que el ejemplo anterior:</p> <pre><code>SELECT * DESDE Tbl AQUI un \"C\" COLLATE . 'foo';\n</code></pre> <p>Pero esto es un error:</p> <pre><code>SELECT * DESDE Tbl WHERE (a \"foo\") COLLATE \"C\";\n</code></pre> <p>porque intenta aplicar una recopilaci\u00f3n al resultado de la  <code>&gt;</code>operador, del tipo de datos no colatable <code>boolean</code>.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/11.-Sucoquesas%20de%20escalar/","title":"11.-Sucoquesas de escalar","text":"<p>Una subcoquea escalar es un ordinario  <code>SELECT</code>consulta entre par\u00e9ntesis que devuelve exactamente una fila con una columna. (V\u00e9ase el  para obtener informaci\u00f3n sobre las consultas de redacci\u00f3n.) El  <code>SELECT</code>La consulta se ejecuta y el valor devuelto \u00fanico se utiliza en la  expresi\u00f3n de valor circundante. Es un error utilizar una consulta que  devuelve m\u00e1s de una fila o m\u00e1s de una columna como una subecha escalar.  (Pero si, durante una ejecuci\u00f3n en particular, la subcoquer\u00eda no  devuelve filas, no hay error; el resultado escalar se toma como nulo.)  La subcoquer\u00eda puede referirse a variables de la consulta circundante,  que actuar\u00e1 como constantes durante cualquier evaluaci\u00f3n de la  subcoquer\u00eda. V\u00e9ase tambi\u00e9n la Secci\u00f3n 9.23 para otras expresiones que implican subcomitos.</p> <p>Por ejemplo, lo siguiente encuentra la mayor poblaci\u00f3n de la ciudad en cada estado:</p> <pre><code>Nombre de SELECT, (SELECT max(pop) De las ciudades D\u00f3nde las ciudades.state = states.name)\n    De los Estados;\n</code></pre>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/11.-Sucoquesas%20de%20escalar/#_1","title":"11.-Sucoquesas de escalar","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/12.-Constructores%20de%20Array/","title":"12.-Constructores de Array","text":""},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/12.-Constructores%20de%20Array/#_1","title":"12.-Constructores de Array","text":"<p>Un constructor de array es una expresi\u00f3n que construye un valor  de matriz usando valores para sus elementos miembros. Un simple  constructor de matriz consiste en la palabra clave <code>ARRAY</code>, un soporte cuadrado izquierdo <code>[</code>, una lista de expresiones (separadas por comas) para los valores de  elementos de array, y finalmente un soporte cuadrado derecho <code>]</code>. Por ejemplo:</p> <pre><code>SELECT ARRAY[1,2,3-4];\n  matriz\n-------\n 1,2,7\n(1 fila)\n</code></pre> <p>Por defecto, el tipo de elemento de matriz es el tipo com\u00fan de  expresiones miembros, determinada usando las mismas reglas que para  <code>UNION</code>o o  <code>CASE</code>construcciones (v\u00e9ase la secci\u00f3n 10.5). Puede anular esto lanzando expl\u00edcitamente el constructor de matriz al tipo deseado, por ejemplo:</p> <pre><code>SELECT ARRAY[1,2,22.7]::integer[];\n  matriz\n---------\n - 1.223.\n(1 fila)\n</code></pre> <p>Esto tiene el mismo efecto que lanza cada expresi\u00f3n al tipo de  elemento de matriz individualmente. Para m\u00e1s informaci\u00f3n sobre el  casting, v\u00e9ase la secci\u00f3n 4.2.9.</p> <p>Los valores de matriz multidimensional se pueden construir  mediante constructores de matrices de anidaci\u00f3n. En los constructores  interiores, la palabra clave  <code>ARRAY</code>se puede omitir. Por ejemplo, estos producen el mismo resultado:</p> <pre><code>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];\n     matriz\n- A---------------\n . . . . . . . . . . . . . . . . . . . . . . .\n(1 fila)\n\nSELECT ARRAY[[1,2],[3,4]];\n     matriz\n- A---------------\n . . . . . . . . . . . . . . . . . . . . . . .\n(1 fila)\n</code></pre> <p>Dado que los arrays multidimensionales deben ser rectangulares,  los constructores interiores al mismo nivel deben producir sub-arrays de dimensiones id\u00e9nticas. Cualquier yarde aplicado al exterior  <code>ARRAY</code>El constructor se propaga autom\u00e1ticamente a todos los constructores internos.</p> <p>Los elementos de constructor de matrices multidimensionales  pueden ser cualquier cosa que produzca una matriz del tipo apropiado, no s\u00f3lo un sub- <code>ARRAY</code>Construir. Por ejemplo:</p> <pre><code>CREATE TABLE arr(f1 int[], f2 int[]);\n\nINSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[5,6],[7,8]]);\n\nSELECT ARRAY[f1, f2, 'o9,10o,11,12'::int[]] DESDE arr;\n                     matriz\n---------------------------------------------------------------------------\n .. .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n(1 fila)\n</code></pre> <p>Usted puede construir una matriz vac\u00eda, pero como es imposible  tener un array sin tipo, debe expl\u00edcitamente lanzar su matriz vac\u00eda al  tipo deseado. Por ejemplo:</p> <pre><code>SELECT ARRAY[]:integer[];\n matriz\n------\n -\n(1 fila)\n</code></pre> <p>Tambi\u00e9n es posible construir un array a partir de los resultados  de una subcoquer\u00eda. En este modo, el constructor de matriz est\u00e1 escrito  con la palabra clave  <code>ARRAY</code>seguido de una subcunci\u00f3n entre par\u00e9ntesis. Por ejemplo:</p> <pre><code>SELECT ARRAY(SELECT oid FROM pg.proc WHERE proname LIKE LIKE 'bytea%');\n                              matriz\n---------------------------------------------------------------------------------------------------------------------------\n 2011,1954,1948,1952,1951,1951,191950,2005,1949,1953,2006,31,2412\n(1 fila)\n\nSELECT ARRAY(SELECT ARRAY[i, i*2] DESDE Generaseries (1.5) AS a(i));\n              matriz\n----------------------------------\n 1,2,2,4, 3,6, 4,8, , 5,10o.\n(1 fila)\n</code></pre> <p>La subcoche debe devolver una sola columna. Si la columna de  salida de la sutrocuria es de tipo no de rayos, el array unidimensional  resultante tendr\u00e1 un elemento para cada fila en el resultado de la  subcocher\u00eda, con un tipo de elemento que coincide con el de la columna  de salida de la subcoquer\u00eda. Si la columna de salida de la subcoquer\u00eda  es de tipo de array, el resultado ser\u00e1 un array del mismo tipo pero una  dimensi\u00f3n superior; en este caso todas las filas de subcoquer\u00eda deben  producir matrices de dimensionalidad id\u00e9ntica, de lo contrario el  resultado no ser\u00eda rectangular.</p> <p>Los sub\u00edndices de un valor de matriz construido con  <code>ARRAY</code>siempre empieza con uno. Para m\u00e1s informaci\u00f3n sobre arrays, v\u00e9ase la secci\u00f3n 8.15.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/13.-Constructores%20de%20filas/","title":"13.-Constructores de filas","text":"<p>Un constructor de filas es una expresi\u00f3n que construye un valor de  fila (tambi\u00e9n llamado valor compuesto) usando valores para sus campos  miembros. Un constructor de filas consiste en la palabra clave <code>ROW</code>, un par\u00e9ntesis izquierdo, cero o m\u00e1s expresiones (separadas por comas)  para los valores del campo de fila, y finalmente un par\u00e9ntesis derecho.  Por ejemplo:</p> <pre><code>SELECT ROW (1,2,5, \"esta es una prueba\";\n</code></pre> <p>La palabra clave  <code>ROW</code>es opcional cuando hay m\u00e1s de una expresi\u00f3n en la lista.</p> <p>Un constructor de filas puede incluir la sintaxis <code>rowvalue</code><code>.*</code>, que se ampliar\u00e1 a una lista de los elementos del valor de la fila, tal como se produce cuando la  <code>.*</code>sintaxis se utiliza en el nivel superior de un  <code>SELECT</code>lista (v\u00e9ase la secci\u00f3n 8.16.5). Por ejemplo, si se tabla  <code>t</code>tiene columnas  <code>f1</code>y <code>f2</code>, estos son los mismos:</p> <pre><code>SELECT ROW(t.*, 42) DESDE t;\nSELECT ROW(t.f1, t.f2, 42) DESDE t;\n</code></pre>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/13.-Constructores%20de%20filas/#nota","title":"Nota","text":"<p>Antes de PostgreSQL 8.2, el  <code>.*</code>la sintaxis no se ampli\u00f3 en los constructores de filas, por lo que la escritura  <code>ROW(t.*, 42)</code>cre\u00f3 una fila de dos campos cuyo primer campo fue otro valor de fila. El  nuevo comportamiento suele ser m\u00e1s \u00fatil. Si necesitas el viejo  comportamiento de los valores de fila anidada, escribe el valor de la  fila interior sin <code>.*</code>, por ejemplo <code>ROW(t, 42)</code>.</p> <p>Por defecto, el valor creado por un  <code>ROW</code>expresi\u00f3n es de tipo de registro an\u00f3nimo. Si es necesario, se puede fundir a un  tipo compuesto nombrado, ya sea el tipo de fila de una tabla, o un tipo  compuesto creado con <code>CREATE TYPE AS</code>. Un elenco expl\u00edcito podr\u00eda ser necesario para evitar la ambiguedad. Por ejemplo:</p> <pre><code>CREATE TABLE mytable(f1 int, f2 float, f3 texto;\n\nCREATE FUNCTION getf1(mable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n\n-- No se necesita el elenco ya que s\u00f3lo existe un getf1()\nSELECT getf1(ROW (1,2,5, 'esto es una prueba');\n getf1\n------\n     1\n(1 fila)\n\nCREATE TIPO mycretipo AS (f1 int, f2 texto, f3 num\u00e9rico);\n\nCREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n\nAhora necesitamos un lade\u00f1o para indicar qu\u00e9 funci\u00f3n llamar:\nSELECT getf1(ROW (1,2,5, 'esto es una prueba');\nERROR: funci\u00f3n getf1(record) no es \u00fanica\n\nSELECT getf1($1,2.5, 'esto es una prueba')::mitable);\n getf1\n------\n     1\n(1 fila)\n\nSELECT getf1(CAST(LLW (11,\" esto es una prueba\", 2.5) AS myrowtype);\n getf1\n------\n    11\n(1 fila)\n</code></pre> <p>Los constructores de filas se pueden utilizar para construir  valores compuestos para ser almacenados en una columna de tabla de tipo  compuesto, o para ser pasados a una funci\u00f3n que acepta un par\u00e1metro  compuesto. Adem\u00e1s, es posible comparar dos valores de fila o probar una  fila con  <code>IS NULL</code>o o <code>IS NOT NULL</code>, por ejemplo:</p> <pre><code>SELECT ROW (1,2.5, 'esto es un ensayo') = ROW (1, 3, 'no el mismo');\n\nSELECT ROW(table.*) IS NULL FROM table; -- detecta filas de todo nen\u00f3cidos\n</code></pre> <p>Para m\u00e1s detalles, v\u00e9ase la secci\u00f3n 9.24. Los constructores de filas tambi\u00e9n pueden utilizarse en relaci\u00f3n con subcoquer\u00edas, como se examina en la secci\u00f3n 9.23.</p>"},{"location":"02.-%20El%20lenguaje%20SQL/01.-Sintaxis%20SQL/02.-Expresiones%20de%20valor/14.-Reglas%20de%20evaluaci%C3%B3n%20de%20la%20expresi%C3%B3n/","title":"14.-Reglas de evaluaci\u00f3n de la expresi\u00f3n","text":"<p>El orden de evaluaci\u00f3n de subexpresiones no est\u00e1 definido. En  particular, las entradas de un operador o funci\u00f3n no se eval\u00faan  necesariamente de izquierda a derecha o en cualquier otro pedido fijo.</p> <p>Adem\u00e1s, si el resultado de una expresi\u00f3n se puede determinar  evaluando s\u00f3lo algunas partes de ella, entonces otras subexpresiones  podr\u00edan no ser evaluadas en absoluto. Por ejemplo, si uno escribi\u00f3:</p> <pre><code>SELECT true O algo de ();\n</code></pre> <p>entonces  <code>somefunc()</code>(probablemente) no ser\u00eda llamada en absoluto. Lo mismo ser\u00eda si uno escribiera:</p> <pre><code>SELECT somefunc () O cierto;\n</code></pre> <p>Tenga en cuenta que esto no es lo mismo que el cortocircuito de izquierda a derecha de los operadores booleanos que se encuentra en algunos lenguajes de programaci\u00f3n.</p> <p>Como consecuencia, no es prudente utilizar funciones con efectos  secundarios como parte de expresiones complejas. Es especialmente  peligroso confiar en los efectos secundarios o en el orden de evaluaci\u00f3n en  <code>WHERE</code>y  <code>HAVING</code>cl\u00e1usulas, ya que esas cl\u00e1usulas se reprocesan ampliamente como parte de la  elaboraci\u00f3n de un plan de ejecuci\u00f3n. Expresiones boolenas (<code>AND</code>/<code>OR</code>/ <code>NOT</code>combinaciones) en esas cl\u00e1usulas se pueden reorganizar de cualquier manera permitida por las leyes del \u00e1lgebra booleana.</p> <p>Cuando es esencial forzar el orden de evaluaci\u00f3n, a  <code>CASE</code>La construcci\u00f3n (ver Secci\u00f3n 9.18) se puede utilizar. Por ejemplo, esta es una manera poco confiable de tratar de evitar la divisi\u00f3n por cero en un  <code>WHERE</code>cl\u00e1usula:</p> <pre><code>SELECT ... DONE x 0 Y y/x 1.5;\n</code></pre> <p>Pero esto es seguro:</p> <pre><code>SELECT ... D\u00f3nde QUIEN CUANDO x . 0 THEN y/x . 1.5 ELSE falso END;\n</code></pre> <p>A  <code>CASE</code>La construcci\u00f3n utilizada en esta moda derrotar\u00e1 los intentos de  optimizaci\u00f3n, por lo que s\u00f3lo debe hacerse cuando sea necesario. (En  este ejemplo en particular, ser\u00eda mejor eludir el problema escribiendo  <code>y &gt; 1.5*x</code>en su lugar.)</p> <p><code>CASE</code>Sin embargo, no es una cura para este tipo de cuestiones. Una limitaci\u00f3n de la t\u00e9cnica ilustrada anteriormente es que no impide la evaluaci\u00f3n  temprana de las continuas subexpresiones. Como se describe en la secci\u00f3n 38.7, las funciones y los operadores marcaron  <code>IMMUTABLE</code>se puede evaluar cuando la consulta est\u00e1 planeada en lugar de cuando se ejecuta. As\u00ed, por ejemplo</p> <pre><code>SELECT CASE WHEN x 0 THEN x ELSE 1/0FIN DE Pesta p:\n</code></pre> <p>es probable que resulte en un fracaso de divisi\u00f3n por cero debido al planificador tratando de simplificar la subexpresi\u00f3n constante,  incluso si cada fila de la tabla ha  <code>x &gt; 0</code>de modo que el  <code>ELSE</code>brazo nunca entrar\u00eda en el momento corrido.</p> <p>Si bien ese ejemplo en particular puede parecer tonto, los casos  relacionados que obviamente no implican constantes pueden ocurrir en  consultas ejecutadas dentro de funciones, ya que los valores de los  argumentos de la funci\u00f3n y las variables locales se pueden insertar en  consultas como constantes con fines de planificaci\u00f3n. Dentro de las  funciones de PL/pgSQL, por ejemplo, usando un <code>IF</code>- -<code>THEN</code>- - <code>ELSE</code>declaraci\u00f3n para proteger un c\u00f3mputo arriesgo es mucho m\u00e1s segura que simplemente anidarla en un  <code>CASE</code>la expresi\u00f3n.</p> <p>Otra limitaci\u00f3n del mismo tipo es que a  <code>CASE</code>no puede impedir la evaluaci\u00f3n de una expresi\u00f3n agregada contenida en  ella, porque las expresiones agregadas se calculan antes de otras  expresiones en un  <code>SELECT</code>lista o  <code>HAVING</code>se considere la cl\u00e1usula. Por ejemplo, la siguiente consulta puede causar  un error de divisi\u00f3n por cero a pesar de que aparentemente se ha  protegido contra \u00e9l:</p> <pre><code>SELECT CASE WHEN min(employees)\n            THEN avg (expenses / empleados)\n       FIN\n    De los departamentos;\n</code></pre> <p>El  <code>min()</code>y  <code>avg()</code>los agregados se calculan simult\u00e1neamente sobre todas las filas de entrada, as\u00ed que si hay alguna fila  <code>employees</code>igual a cero, el error de divisi\u00f3n por cero se producir\u00e1 antes de que haya alguna oportunidad de probar el resultado de <code>min()</code>. En su lugar, use un  <code>WHERE</code>o o  <code>FILTER</code>cl\u00e1usula para evitar que las filas de entrada problem\u00e1ticas alcancen una funci\u00f3n agregada en primer lugar.</p>"}]}