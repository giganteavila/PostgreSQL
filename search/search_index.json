{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PostgreSQL","text":""},{"location":"#que-es-postgresql","title":"\u00bfQu\u00e9 es PostgreSQL?","text":"<p>PostgreSQL es un potente sistema de bases de datos de c\u00f3digo abierto que utiliza y extiende el lenguaje SQL combinado con muchas caracter\u00edsticas que almacenan y escalan las cargas de datos m\u00e1s complicadas. Los or\u00edgenes de PostgreSQL se remontan a 1986 como parte del proyecto POSTGRES en la Universidad de California en Berkeley y tiene m\u00e1s de 35 a\u00f1os de desarrollo activo en la plataforma central.</p> <p>PostgreSQL se ha ganado una s\u00f3lida reputaci\u00f3n por su arquitectura probada, fiabilidad, integridad de datos, conjunto de caracter\u00edsticas robustas, extensibilidad y la dedicaci\u00f3n de la comunidad de c\u00f3digo abierto detr\u00e1s del software para ofrecer constantemente soluciones eficaces e innovadoras. PostgreSQL se ejecuta en todos los principales sistemas operativos, ha sido compatible con ACID desde 2001, y tiene potentes complementos como el popular extensor de bases de datos geoespaciales PostGIS. No es de extra\u00f1ar que PostgreSQL se haya convertido en la base de datos relacional de c\u00f3digo abierto de elecci\u00f3n para muchas personas y organizaciones.</p> <p>Empezar con el uso de PostgreSQL nunca ha sido m\u00e1s f\u00e1cil: elige un proyecto que quieres construir, y deja que PostgreSQL almacene de forma segura y robusta tus datos.</p>"},{"location":"#por-que-usar-postgresql","title":"\u00bfPor qu\u00e9 usar PostgreSQL?","text":"<p>PostgreSQL viene con muchas caracter\u00edsticas destinadas a ayudar a los desarrolladores a construir aplicaciones, administradores para proteger la integridad de los datos y construir entornos tolerantes a fallos, y ayudarle a administrar sus datos sin importar el conjunto de datos tan grande o peque\u00f1o. Adem\u00e1s de ser de c\u00f3digo libre y abierto, PostgreSQL es muy extensible. Por ejemplo, puede definir sus propios tipos de datos, construir funciones personalizadas, incluso escribir c\u00f3digo de diferentes lenguajes de programaci\u00f3n sin recompilar su base de datos.</p> <p>PostgreSQL trata de ajustarse al est\u00e1ndar SQL donde tal conformidad no contradice las caracter\u00edsticas tradicionales o podr\u00eda conducir a malas decisiones arquitect\u00f3nicas. Muchas de las caracter\u00edsticas requeridas por el est\u00e1ndar SQL son compatibles, aunque a veces con una sintaxis o funci\u00f3n ligeramente diferente. Se pueden esperar nuevos pasos hacia la conformidad con el tiempo. A partir de la versi\u00f3n 16 de septiembre de 2023, PostgreSQL se ajusta al menos a 170 de las 179 funciones obligatorias para la conformidad del n\u00facleo SQL:2023. A partir de este escrito, ninguna base de datos relacional cumple con toda la conformidad con esta norma.</p> <p>A continuaci\u00f3n se muestra una lista no exhaustiva de varias caracter\u00edsticas que se encuentran en PostgreSQL, se a\u00f1aden m\u00e1s en cada versi\u00f3n importante:</p> <ul> <li>Tipos de datos<ul> <li>Primitivas: entero, num\u00e9rico, cadena, booleano</li> <li>Estructurado: Fecha/hora, Array, Range / Multirange, UUID</li> <li>Documento: JSON/JSONB, XML, Clave-valor (Hstore)</li> <li>Geometr\u00eda: Punto, L\u00ednea, C\u00edrculo, Pol\u00edgono</li> <li>Personalizaciones: Composite, Tipos personalizados</li> </ul> </li> <li>Integridad de los datos<ul> <li>UNIQUE, NO NULL</li> <li>Claves primarias</li> <li>Claves for\u00e1neas</li> <li>Restricciones de exclusi\u00f3n</li> <li>Explicit Locks, Advisory Locks</li> </ul> </li> <li>Concurrencia, Rendimiento<ul> <li>Indizaci\u00f3n: \u00c1rbol B, Multicolumna, Expresiones, Partial</li> <li>Indizaci\u00f3n avanzada: GiST, SP-Gist, KNN Gist, GIN, BRIN, Covering indexes, Bloom filters</li> <li>Sofisticado planificador de consultas/optimizador, escaneos de solo \u00edndice, estad\u00edsticas multicolumna</li> <li>Transacciones, Operaciones anidadas (a trav\u00e9s de puntos de ahorro)</li> <li>Control de concurrencia Multi-Versi\u00f3n (MVCC)</li> <li>Paralelizaci\u00f3n de las consultas de lectura y la construcci\u00f3n de \u00edndices de \u00e1rbol B</li> <li>Particionado de tablas</li> <li>Todos los niveles de aislamiento de las transacciones definidos en la norma SQL, incluyendo Serializable</li> <li>Compilati\u00f3n de expresiones Just-In-Time (JIT)</li> </ul> </li> <li>Fiabilidad, Recuperaci\u00f3n de Desastres</li> <li>Write-ahead Logging (WAL)</li> <li>Replication: Asynchronous, Synchronous, Logical</li> <li>Point-in-time-recovery (PITR), active standbys</li> <li>Tablespaces</li> <li>Seguridad<ul> <li>Autenticaci\u00f3n: GSSAPI, SSPI, LDAP, SCRAM-SHA-256, Certificado, y m\u00e1s</li> <li>Sistema de control de acceso robusto</li> <li>Seguridad a nivel de columna y fila</li> <li>La autenticaci\u00f3n multifactor con certificados y un m\u00e9todo adicional</li> </ul> </li> <li>Extensibilidad<ul> <li>Funciones y procedimientos almacenados</li> <li>Lenguajes procedurales: PL/pgSQL, Perl, Python y Tcl. Hay otros lenguajes disponibles a trav\u00e9s de extensiones, por ejemplo. Java, JavaScript (V8), R, Lua y Rust</li> <li>Constructores SQL/JSON y expresiones de ruta</li> <li>Envoltorios de datos extranjeros: con\u00e9ctese a otras bases de datos o flujos con una interfaz SQL est\u00e1ndar</li> <li>Interfaz de almacenamiento personalizable para tablas</li> <li>Muchas extensiones que proporcionan funcionalidad adicional, incluyendo PostGIS</li> </ul> </li> <li>Internacionalizaci\u00f3n, B\u00fasqueda de Texto<ul> <li>Apoyo a conjuntos internacionales de caracteres, por ejemplo, a trav\u00e9s de las recopilaciones de la UCI</li> <li>Cifras de casos insensibles e insensibles a los acentos</li> <li>B\u00fasqueda de texto completo</li> </ul> </li> </ul> <p>Hay muchas m\u00e1s caracter\u00edsticas que se pueden descubrir en la documentaci\u00f3n PostgreSQL. Adem\u00e1s, PostgreSQL es altamente extensible: muchas caracter\u00edsticas, como los \u00edndices, tienen API definidas para que se pueda construir con PostgreSQL tus desaf\u00edos.</p> <p>PostgreSQL ha demostrado ser altamente escalable tanto en la cantidad de datos que puede gestionar y en el n\u00famero de usuarios concurrentes que puede acomodarse. Hay cl\u00fasteres activos PostgreSQL en entornos de producci\u00f3n que manejan muchos terabytes de datos, y sistemas especializados que manejan petabytes.</p>"},{"location":"#alguna-pregunta","title":"\u00bfAlguna pregunta?","text":"<p>El primer lugar al que acudir para cualquier pregunta en PostgreSQL es su documentaci\u00f3n de renombre mundial que discute c\u00f3mo usar PostgreSQL en profundidad.</p> <p>Tambi\u00e9n hay muchas listas de correo donde te puedes conectar y participar en la comunidad. Tambi\u00e9n hay muchos eventos y grupos de usuarios locales donde te puedes conectar con otros usuarios de PostgreSQL.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/","title":"01.-La necesidad de gestionar informaci\u00f3n","text":"<p>En el mundo actual existe una cada vez mayor demanda de gesti\u00f3n de la informaci\u00f3n. No es una demanda nueva, todas las sociedades a lo largo de la historia han tenido esta necesidad. Desde el principio de los tiempos se ha necesitado disponer de herramientas que facilitaran la gesti\u00f3n de los datos ya que, como herramienta, el ser humano al principio s\u00f3lo dispon\u00eda de su memoria y c\u00e1lculo inmediato y, como mucho, de la ayuda de sus dedos.</p> <p>La escritura fue la herramienta que permiti\u00f3 al ser humano almacenar informaci\u00f3n y realizar c\u00e1lculos sobre ella. Adem\u00e1s de permitir compartir esa informaci\u00f3n entre diferentes personas, tambi\u00e9n posibilit\u00f3 que los datos se guardaran de manera continua e incluso estuvieran disponibles para las siguientes generaciones. Los problemas actuales con la privacidad ya aparecieron con la propia escritura y as\u00ed el cifrado de datos es una t\u00e9cnica tan antigua como la propia escritura para conseguir uno de los todav\u00eda requisitos fundamentales de la gesti\u00f3n de datos, la seguridad.</p> <p>Cuanto m\u00e1s se han desarrollado las sociedades, mejores m\u00e9todos se han desarrollado para gestionar la informaci\u00f3n y, a la vez, m\u00e1s datos se han necesitado gestionar. Para poder almacenar datos y cada vez m\u00e1s datos, el ser humano ide\u00f3 nuevas herramientas: archivos, cajones, carpetas y fichas en las que se almacenaban los datos.</p> <p>Antes de la aparici\u00f3n de las computadoras, el tiempo requerido para manipular estos datos era enorme. Sin embargo el proceso de aprendizaje era relativamente sencillo, ya que se usaban elementos que las personas manejaban desde su infancia.</p> <p>Por esa raz\u00f3n, la inform\u00e1tica se adapt\u00f3 para que la terminolog\u00eda en el propio ordenador se pareciera a los t\u00e9rminos de organizaci\u00f3n de datos cl\u00e1sicos. As\u00ed, en inform\u00e1tica se sigue hablado de ficheros, formularios, carpetas, directorios,....</p> <p>En estos \u00faltimos a\u00f1os, la demanda ha crecido a niveles espectaculares debido al acceso multitudinario a Internet y a los enormes flujos de informaci\u00f3n que generan los usuarios. Cada a\u00f1o la necesidad de almacenar informaci\u00f3n crece exponencialmente en un frenes\u00ed que, por ahora, no parece tener fin.</p> <p>Desde la aparici\u00f3n de las primeras computadoras, se intent\u00f3 automatizar la gesti\u00f3n de los datos. El propio nombre Inform\u00e1tica hace referencia al hecho de ser una ciencia que trabaja con informaci\u00f3n. Por ello las bases de datos son una de las aplicaciones m\u00e1s antiguas de la inform\u00e1tica.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/#02-datos-e-informacion","title":"02.-Datos e informaci\u00f3n","text":"<p>Tradicionalmente siempre se ha separado el concepto de dato sobre el de informaci\u00f3n.</p> <p>Un dato es una propiedad en crudo, es decir, sin contextualizar. Por ejemplo S\u00e1nchez y 32 son datos. Desde el punto de vista de la computaci\u00f3n, ambos datos se pueden almacenar. Sin embargo, no podemos considerarlos informaci\u00f3n hasta que no les demos significado. Si decimos que S\u00e1nchez es mi primer apellido y que 32 son los grados cent\u00edgrados de temperatura que hace ahora en la calle, esos datos pasan a ser informaci\u00f3n.</p> <p>La informaci\u00f3n tiene una importancia humana, es interpretable, reconocible, presentable,.. El dato es simplemente el paso previo. Resumiendo: todo dato debe de ser procesado para obtener informaci\u00f3n, y es la informaci\u00f3n lo que nos interesa a los seres humanos.</p> <p>Como veremos m\u00e1s adelante, los datos se convierten en informaci\u00f3n gracias a los metadatos: datos que sirven para describir otros datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/#03-sistemas-de-informacion","title":"03.-Sistemas de Informaci\u00f3n","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/#la-empresa-como-sistema","title":"La empresa como sistema","text":"<p>Seg\u00fan la RAE, la definici\u00f3n de sistema es \u201cConjunto de cosas que ordenadamente relacionadas entre s\u00ed contribuyen a un determinado objeto\u201d .</p> <p>La clientela fundamental del profesional de la inform\u00e1tica es la empresa, sin distinguir entre la empresa privada y las entidades p\u00fablicas. Una empresa est\u00e1 formada por diversos elementos que son comunes: el capital, los recursos humanos, los inmuebles, los servicios que presta, etc. Todos ellos forman el sistema de la empresa.</p> <p>El sistema completo que forma la empresa, por otra parte, se suele dividir en los siguientes subsistemas:</p> <ul> <li> <p>Subsistema productivo. Tambi\u00e9n llamado subsistema real o f\u00edsico. Representa la parte de la empresa encargada de gestionar la producci\u00f3n de la misma.</p> </li> <li> <p>Subsistema financiero. Encargado de la gesti\u00f3n de los bienes econ\u00f3micos de la empresa</p> </li> <li> <p>Subsistema directivo. Encargado de la gesti\u00f3n organizativa de la empresa</p> </li> </ul> <p>Hay que hacer notar que cada subsistema se asocia a un departamento concreto de la empresa.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/#sistemas-de-informacion","title":"Sistemas de Informaci\u00f3n","text":"<p>Los sistemas que aglutinan los elementos que intervienen para gestionar la informaci\u00f3n que manejan los subsistemas empresariales es lo que se conoce como Sistemas de Informaci\u00f3n. Se suele utilizar las siglas SI o IS (de Information Server) para referirse a este concepto.</p> <p>Vale tambi\u00e9n para gestionar la informaci\u00f3n de cualquier sistema, aunque no sea empresarial. Pero la teor\u00eda est\u00e1 basada en el sistema empresarial.</p> <p>Realmente un sistema de informaci\u00f3n s\u00f3lo incluye aquello que nos interesa de la empresa y los elementos necesarios para gestionar esa informaci\u00f3n.</p> <p>Un sistema de informaci\u00f3n gen\u00e9rico est\u00e1 formado por los siguientes elementos:</p> <ul> <li> <p>Recursos f\u00edsicos. Carpetas, documentos, equipamiento, discos,...</p> </li> <li> <p>Recursos humanos. Personal que maneja la informaci\u00f3n</p> </li> <li> <p>Protocolo. Normas que debe cumplir la informaci\u00f3n para que sea manejada (formato de la informaci\u00f3n, modelo para los documentos,...)</p> </li> </ul> <p>Las empresas necesitan implantar estos sistemas de informaci\u00f3n debido a la competencia que las obliga a gestionar de la forma m\u00e1s eficiente sus datos para una mayor calidad en la organizaci\u00f3n de las actividades de los subsistemas empresariales</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/01.-Datos%20y%20archivos/#componentes-de-un-sistema-de-informacion-electronico","title":"Componentes de un Sistema de Informaci\u00f3n Electr\u00f3nico","text":"<p>En el caso de una gesti\u00f3n electr\u00f3nica de la informaci\u00f3n (lo que actualmente se considera un sistema de informaci\u00f3n electr\u00f3nico), los componentes son:</p> <ul> <li> <p>Datos. Se trata de la informaci\u00f3n relevante que almacena y gestiona el sistema de informaci\u00f3n. Ejemplos de datos son: S\u00e1nchez, 12764569F, Calle Mayo 5, Azul\u2026</p> </li> <li> <p>Hardware. Equipamiento f\u00edsico que se utiliza para gestionar los datos. cada uno de los dispositivos electr\u00f3nicos que permiten el funcionamiento del sistema de informaci\u00f3n: servidores, m\u00e1quinas de los clientes, routers, switches, impresoras,\u2026</p> </li> <li> <p>Software. Aplicaciones inform\u00e1ticas que se encargan de la gesti\u00f3n de la base de datos y de las herramientas que facilitan su uso.</p> </li> <li> <p>Recursos humanos. Personal que maneja el sistema de informaci\u00f3n.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/02.-Tipos%20de%20gesti%C3%B3n%20de%20Informaci%C3%B3n%20mediante%20el%20ordenador/","title":"02.-Tipos de gesti\u00f3n de Informaci\u00f3n mediante el ordenador","text":"<p>En la evoluci\u00f3n de los sistemas de informaci\u00f3n ha habido dos puntos determinantes, que han formado los dos tipos fundamentales de sistemas de informaci\u00f3n electr\u00f3nico.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/02.-Tipos%20de%20gesti%C3%B3n%20de%20Informaci%C3%B3n%20mediante%20el%20ordenador/#01-sistemas-de-gestion-de-ficheros","title":"01.-Sistemas de gesti\u00f3n de ficheros","text":"<p>Este tipo de sistemas hace referencia a la forma que inicialmente se desarroll\u00f3 en la inform\u00e1tica para gestionar ficheros (y que a\u00fan se usa). En realidad, es una forma que traduc\u00eda la manera cl\u00e1sica de gestionar sistemas de informaci\u00f3n (con sus archivadores, carpetas,\u2026) al mundo electr\u00f3nico.</p> <p></p> <p>La idea es que los datos se almacenan en ficheros y se crean aplicaciones (cuyo c\u00f3digo posee la empresa que crea dichas aplicaciones) para acceder a los ficheros. Cada aplicaci\u00f3n organiza los datos en los ficheros como le parece mejor y si incorporamos aplicaciones nuevas, \u00e9stas usar\u00e1n sus propios ficheros.</p> <p>Cada aplicaci\u00f3n almacena y utiliza sus propios datos de forma un tanto ca\u00f3tica. La ventaja de este sistema (la \u00fanica ventaja), es que los procesos son independientes por lo que la modificaci\u00f3n de uno no afecta al resto. Pero tiene grandes inconvenientes:</p> <ul> <li> <p>Programaci\u00f3n de aplicaciones compleja. Ya que los programadores se deben de encargar de lo que tiene que hacer la aplicaci\u00f3n y adem\u00e1s de estructurar los datos en disco.</p> </li> <li> <p>Datos redundantes. Ya que se repiten continuamente. Podr\u00eda, por ejemplo, ocurrir que una segunda aplicaci\u00f3n utilice datos de personales, que resulta que ya estaban almacenados en los ficheros de una primera aplicaci\u00f3n, pero como ambas son independientes, los datos se repetir\u00e1n.</p> </li> <li> <p>Datos inconsistentes. En relaci\u00f3n con el problema anterior, ya que un proceso cambia sus datos y no los del resto. Por lo que la misma informaci\u00f3n puede tener distintos valores seg\u00fan qu\u00e9 aplicaci\u00f3n acceda a \u00e9l.</p> </li> <li> <p>Dif\u00edcil acceso a los datos. Cada vez que se requiera una consulta no prevista inicialmente, hay que modificar el c\u00f3digo de las aplicaciones o incluso crear una nueva aplicaci\u00f3n. Esto hace imposible pensar en nuevas consultas e instant\u00e1neamente obtener sus resultados; inviable para aplicaciones que requieren grandes capacidades de consultas y an\u00e1lisis de datos.</p> </li> <li> <p>Coste de almacenamiento elevado. Al almacenarse varias veces el mismo dato, se requiere m\u00e1s espacio en los discos. Adem\u00e1s, las aplicaciones tambi\u00e9n ocupan mucho al tener que pensar en todas las posibles consultas sobre los datos que la organizaci\u00f3n precisa.</p> </li> <li> <p>Dependencia de los datos a nivel f\u00edsico. Para poder saber c\u00f3mo se almacenan los datos, es decir qu\u00e9 estructura se utiliza de los mismos, necesitamos ver el c\u00f3digo de la aplicaci\u00f3n; es decir el c\u00f3digo y los datos no son independientes.</p> </li> <li> <p>Dificultad para el acceso simult\u00e1neo a los datos. El acceso simult\u00e1neo requiere que varios usuarios al puedan acceder a la misma informaci\u00f3n. Con este tipo de sistemas es extremadamente dif\u00edcil conseguir esta capacidad.</p> </li> <li> <p>Dificultad para administrar la seguridad del sistema. Ya que cada aplicaci\u00f3n se crea independientemente. Es, por tanto, muy dif\u00edcil establecer criterios de seguridad uniformes. Es decir, los permisos que cada usuario tiene sobre los datos, se establecen de forma muy confusa (y nada uniforme ya que cada aplicaci\u00f3n puede variar la seguridad).</p> </li> </ul> <p>Se consideran tambi\u00e9n sistemas de gesti\u00f3n de ficheros, a los sistemas que utilizan programas ofim\u00e1ticos (como procesadores de texto u hojas de c\u00e1lculo por ejemplo) para gestionar sus datos. Esta \u00faltima idea, la utilizan muchas peque\u00f1as empresas para gestionar los datos, debido al presupuesto limitado del que disponen. Gestionar la informaci\u00f3n de esta forma produce los mismos (si no m\u00e1s) problemas.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/02.-Tipos%20de%20gesti%C3%B3n%20de%20Informaci%C3%B3n%20mediante%20el%20ordenador/#02-sistemas-de-bases-de-datos","title":"02.-Sistemas de Bases de Datos","text":"<p>En este tipo de sistemas, los datos se centralizan en una base de datos com\u00fan a todas las aplicaciones. Un software llamado Sistema Gestor de Bases de Datos (SGBD) es el que realmente accede a los datos y se encarga de gestionarlos. Las aplicaciones que creen los programadores, no acceden directamente a los datos, de modo que la base de datos es com\u00fan para todas las aplicaciones.</p> <p>De esta forma, hay, al menos, dos capas a la hora de acceder a los datos. Las aplicaciones se abstraen sobre la forma de acceder a los datos, dejando ese problema al SGBD. As\u00ed se pueden concentrar exclusivamente en la tarea de conseguir una interfaz de acceso a los datos para los usuarios.</p> <p></p> <p>Cuando una aplicaci\u00f3n modifica un dato, la modificaci\u00f3n ser\u00e1 visible inmediatamente para el resto de aplicaciones; ya que todas utilizar\u00e1n la misma base de datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/02.-Tipos%20de%20gesti%C3%B3n%20de%20Informaci%C3%B3n%20mediante%20el%20ordenador/#ventajas","title":"Ventajas","text":"<ul> <li> <p>Independencia de los datos y los programas. Esto permite modificar los datos sin modificar el c\u00f3digo de las aplicaciones y viceversa.</p> </li> <li> <p>Menor redundancia. Este modelo no requiere que los datos se repitan para cada aplicaci\u00f3n que los requiera., en su lugar se dise\u00f1an los datos de forma independiente a las aplicaciones. Los programadores de aplicaciones deber\u00e1n conocer la estructura creada para los datos y la forma en la que deben acceder a ellos.</p> </li> <li> <p>Integridad de los datos. Al estar centralizados, es m\u00e1s dif\u00edcil que haya datos incoherentes. Es decir, que una aplicaci\u00f3n muestre informaci\u00f3n distinta al resto de aplicaciones, ya que los datos son los mismos para todas.</p> </li> <li> <p>Mayor seguridad en los datos. El SGBD es el encargado de la seguridad y se puede centrar en ella de forma independiente a las aplicaciones. Como las aplicaciones deben atravesar la capa del SGBD para llegar a los datos, no se podr\u00e1n saltar la seguridad.</p> </li> <li> <p>Visiones distintas seg\u00fan el usuario. Nuevamente, centralizar los datos facilita crear pol\u00edticas que permitan que los usuarios vean la informaci\u00f3n de la base de datos de forma distinta.</p> </li> <li> <p>Datos m\u00e1s documentados. Las bases de datos tienen mucho mejor gestionados los metadatos, que permiten describir la informaci\u00f3n de la base de datos y que pueden ser consultados por las aplicaciones.</p> </li> <li> <p>Acceso a los datos m\u00e1s eficiente. Esta forma de organizar los datos produce un resultado m\u00e1s \u00f3ptimo en rendimiento ya que los sistemas gestores centralizan el acceso pudiendo ejecutar pol\u00edticas diferentes en funci\u00f3n de la demanda.</p> </li> <li> <p>Menor espacio de almacenamiento. Puesto que hay muy poca redundancia.</p> </li> <li> <p>Acceso simult\u00e1neo a los datos. Nuevamente el SGBD tiene m\u00e1s capacidad de conseguir esto. Cuando hay varias aplicaciones que intentan acceder a los datos en los sistemas orientados a los ficheros, compiten por los datos y es f\u00e1cil el bloqueo mutuo. En el caso de los sistemas orientados a bases de datos, toda petici\u00f3n pasa la capa del SGBD y esto permite evitar los bloqueos.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/02.-Tipos%20de%20gesti%C3%B3n%20de%20Informaci%C3%B3n%20mediante%20el%20ordenador/#desventajas","title":"Desventajas","text":"<ul> <li> <p>Instalaci\u00f3n costosa. El control y administraci\u00f3n de bases de datos requiere de un software y hardware poderoso.</p> </li> <li> <p>Requiere personal cualificado. Debido a la dificultad de manejo de este tipo de sistemas.</p> </li> <li> <p>Implantaci\u00f3n larga y dif\u00edcil. En relaci\u00f3n a los puntos anteriores. La adaptaci\u00f3n del personal y del equipamiento es mucho m\u00e1s complicada y lleva bastante tiempo.</p> </li> <li> <p>Ausencia de est\u00e1ndares totales. Lo cual significa una excesiva dependencia hacia los sistemas comerciales del mercado. Aunque, hoy en d\u00eda, hay un funcionamiento base y un lenguaje de gesti\u00f3n (SQL) que desde hace tiempo se considera est\u00e1ndar (al menos en las bases de datos relacionales).</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/","title":"01.-Funciones. Lenguajes de los SGBD","text":"<p>Los SGBD tienen que realizar tres tipos de funciones para ser considerados v\u00e1lidos. A continuaci\u00f3n se describen estas tres funciones.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#funcion-de-descripcion-o-definicion","title":"Funci\u00f3n de descripci\u00f3n o definici\u00f3n","text":"<p>Permite al dise\u00f1ador de la base de datos crear las estructuras apropiadas para integrar adecuadamente los datos. Se dice que esta funci\u00f3n es la que permite definir las tres estructuras de la base de datos (relacionadas con los tres niveles de abstracci\u00f3n de las mismas).</p> <ul> <li> <p>Estructura interna</p> </li> <li> <p>Estructura conceptual</p> </li> <li> <p>Estructura externa</p> </li> </ul> <p>M\u00e1s adelante se explican estas tres estructuras, relacionadas con las tres formas (o niveles) de ver la base de datos.</p> <p>Realmente la funci\u00f3n de definici\u00f3n gestiona los metadatos. Los metadatos son la estructura de la dispone el sistema de base de datos para documentar cada dato. Los metadatos tambi\u00e9n son datos que se almacenan en la propia base de datos; pero su finalidad es describir los datos.</p> <p>Un metadato nos permite para saber a qu\u00e9 informaci\u00f3n real se refiere cada dato. Por ejemplo: S\u00e1nchez, Rodr\u00edguez y Crespo son datos. Pero Primer Apellido es un metadato que, si est\u00e1 correctamente creado, nos permite determinar que S\u00e1nchez, Rodr\u00edguez y Crespo son primeros apellidos.</p> <p>Dicho de otra forma, sin los metadatos, no podr\u00edamos manejar los datos como informaci\u00f3n relevante. Por ello son fundamentales. Son, de hecho, la base de la creaci\u00f3n de las bases de datos.</p> <p>Los metadatos pueden indicar cuestiones complejas. Por ejemplo, que de los Alumnos almacenamos su dni el cual lo forman 9 caracteres. Incluso podremos indicar que en el dni los 8 primeros son n\u00fameros y el noveno un car\u00e1cter en may\u00fasculas que adem\u00e1s cumple una regla concreta y sirve para identificar al alumno.</p> <p>Por lo tanto, en realidad, la funci\u00f3n de definici\u00f3n sirve para crear, eliminar o modificar metadatos.</p> <p>Resumiendo: con la funci\u00f3n de definici\u00f3n podremos:</p> <ul> <li> <p>Especificar el significado de los datos</p> </li> <li> <p>Organizar la informaci\u00f3n en estructuras m\u00e1s complejas</p> </li> <li> <p>Relacionar los datos de forma precisa</p> </li> <li> <p>Especificar reglas especiales que deben cumplir los datos</p> </li> <li> <p>Crear todos los elementos estructurales de la base de datos (incluidos los usuarios)</p> </li> </ul> <p>Un lenguaje conocido como lenguaje de descripci\u00f3n de datos o DDL (Data Description Language), es el que permite realizar la funci\u00f3n de definici\u00f3n en las bases de datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#funcion-de-manipulacion","title":"Funci\u00f3n de manipulaci\u00f3n","text":"<p>Permite cambiar y consultar los datos de la base de datos. Se realiza mediante un lenguaje de manipulaci\u00f3n de datos o DML (Data Manipulation Language). Mediante este lenguaje se puede:</p> <ul> <li> <p>A\u00f1adir datos</p> </li> <li> <p>Eliminar datos</p> </li> <li> <p>Modificar datos</p> </li> <li> <p>Consultar datos</p> </li> </ul> <p>Actualmente se suele diferenciar la funci\u00f3n de consulta de datos, diferenci\u00e1ndola del resto de operaciones de manipulaci\u00f3n de datos. Se habla de que la funci\u00f3n de consulta se realiza con un lenguaje de consulta de datos o DQL (Data Query Language).</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#funcion-de-control","title":"Funci\u00f3n de control","text":"<p>Mediante esta funci\u00f3n los administradores poseen mecanismos para proteger los datos. De manera que se permite a cada usuario ver ciertos datos y otros no, o bien usar ciertos recursos concretos de la base de datos y prohibir otros. Es decir, es la funci\u00f3n encargada de establecer los permisos de acceso a los elementos que forman parte de la base de datos.</p> <p>El lenguaje que implementa esta funci\u00f3n es el lenguaje de control de datos o DCL (Data Control Language).</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#02-utilidad-de-los-sgbd","title":"02.-Utilidad de los SGBD","text":"<p>Un sistema gestor de bases de datos o SGBD (aunque se suele utilizar m\u00e1s a menudo en los libros especializados las siglas DBMS procedentes del ingl\u00e9s, Data Base Management System) es el software que permite a los usuarios procesar, describir, administrar y recuperar los datos almacenados en una base de datos.</p> <p>En estos sistemas se proporciona un conjunto coordinado de programas, procedimientos y lenguajes que permiten a los distintos usuarios realizar sus tareas habituales con los datos, garantizando adem\u00e1s la seguridad de los mismos.</p> <p>El \u00e9xito del SGBD reside en mantener la seguridad e integridad de los datos. L\u00f3gicamente tiene que proporcionar herramientas a los distintos usuarios.</p> <p>Adem\u00e1s de las tres funciones principales comentadas anteriormente, hoy en d\u00eda los SGBD son capaces de realizar numerosas operaciones. Para ello proporcionan numerosas herramientas, muchas de ellas permiten trabajar de una forma m\u00e1s c\u00f3moda con las . Las m\u00e1s destacadas son:</p> <ul> <li> <p>Herramientas para la creaci\u00f3n y especificaci\u00f3n del diccionario de datos. El diccionario de datos es la estructura de la base de datos que almacena los metadatos. Es decir el diccionario de datos contiene la descripci\u00f3n de todos los datos de la base de datos.</p> </li> <li> <p>Herramientas para administrar y crear la estructura f\u00edsica de la base de datos. El SGBD proporciona herramientas para especificar la forma en la que se almacenar\u00e1n los datos en la computadora (o computadoras) que alojen la base de datos. Estas herramientas nos permitir\u00e1n dise\u00f1ar una forma de almacenamiento centrada en optimizar el acceso a los datos.</p> </li> <li> <p>Herramientas para la manipulaci\u00f3n de los datos. Nos permitir\u00e1n a\u00f1adir, modificar, suprimir o consultar datos (funci\u00f3n de manipulaci\u00f3n) de la forma m\u00e1s sencilla posible.</p> </li> <li> <p>Herramientas de recuperaci\u00f3n en caso de desastre. Si ocurre un mal funcionamiento del sistema, un fallo en la alimentaci\u00f3n del sistema, errores de red, etc. En ese caso los buenos SGBD poseen y proporcionan mecanismos para que se recupere la m\u00e1xima informaci\u00f3n posible y se asegure su integridad.</p> </li> <li> <p>Herramientas para la creaci\u00f3n y restablecimiento de copias de seguridad. Es una de las tareas fundamentales, ya que permite recuperar la informaci\u00f3n en caso de p\u00e9rdida de datos.</p> </li> <li> <p>Herramientas para la gesti\u00f3n de la comunicaci\u00f3n de la base de datos. Encargadas de configurar el hardware y software de conexi\u00f3n a la red. As\u00ed como los mecanismos necesarios para configurar adecuadamente el software que se encarga de recibir y comunicar las peticiones de los clientes.</p> </li> <li> <p>Herramientas para la creaci\u00f3n de aplicaciones de usuario. Es decir, herramientas para los programadores de aplicaciones, los cuales crean el software con el que los usuarios acceder\u00e1n de forma c\u00f3moda a la base de datos.</p> </li> <li> <p>Herramientas de instalaci\u00f3n y configuraci\u00f3n de la base de datos.</p> </li> <li> <p>Herramientas para la exportaci\u00f3n e importaci\u00f3n de datos a o desde otros sistemas.</p> </li> <li> <p>Herramientas para gestionar la seguridad. Permiten establecer privilegios y permisos diferentes para los usuarios, as\u00ed como impedir el acceso no deseado (funci\u00f3n de control).</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#03-niveles-de-abstraccion-de-una-base-de-datos","title":"03.-Niveles de abstracci\u00f3n de una base de datos","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#introduccion","title":"Introducci\u00f3n","text":"<p>En cualquier software siempre hay dos puntos de vista:</p> <ul> <li> <p>Nivel externo. Esta es la visi\u00f3n del software que tienen los usuarios</p> </li> <li> <p>Nivel interno. Visi\u00f3n de los creadores del software, que determina su forma de funcionar.</p> </li> </ul> <p>Esta separaci\u00f3n distingue al usuario, del programador que ha creado la aplicaci\u00f3n, y es crucial que sea as\u00ed. Del mismo modo una casa se la puede observar desde el punto de vista del inquilino de la misma o bien de las personas que la construyeron. Los primeros ven la funci\u00f3n real de la misma y los constructores nos podr\u00e1n hablar de los materiales empleados por ejemplo.</p> <p>En el caso de las bases de datos hay m\u00e1s niveles, m\u00e1s formas de observar la base de datos y estos niveles son manejados por los distintos usuarios de la base de datos. A eso se le llama los niveles de abstracci\u00f3n porque nos permite efectivamente abstraernos para observar la base de datos en base a diferentes intereses. Los usuarios podr\u00e1n entender la base de datos sin conocer los entresijos t\u00e9cnicos y los administradores podr\u00e1n trabajar con base de datos sin conocer la forma en la que los usuarios realmente a\u00f1aden los datos.</p> <p>Los niveles habituales son:</p> <ul> <li> <p>Nivel f\u00edsico. Nos permite saber la forma en la que est\u00e1 almacenada la base de datos. Por ejemplo en qu\u00e9 discos duros, qu\u00e9 archivos utiliza, de qu\u00e9 tipo son los archivos, bajo qu\u00e9 sistema operativo,\u2026 Este nivel es el que est\u00e1 m\u00e1s cercano a la visi\u00f3n de la base de datos que posee la computadora, por lo que es absolutamente dependiente del hardware y el software (especialmente del Sistema Operativo).</p> </li> <li> <p>Nivel interno. Un poco m\u00e1s cercano a la visi\u00f3n que tenemos las personas. Permite observar la base de datos como un conjunto de estructuras que relacionan la informaci\u00f3n humana con la informaci\u00f3n digital. A este nivel no se depende del hardware concreto que tengamos; es decir, no se habla de discos, servidores, archivos,\u2026 sino de las estructuras que disponemos en nuestro SGBD en particular para organizar los datos.</p> </li> <li> <p>Nivel conceptual. Es el nivel de mayor abstracci\u00f3n y el m\u00e1s importante. Se trata de una visi\u00f3n organizativa de los datos independiente tanto del hardware como del software que tengamos. Es el plano o modelo general de la base de datos y a este nivel es al que trabajan las o los analistas y dise\u00f1adores cuando crean el primer esquema de la base de datos. En ning\u00fan momento queda influido por el SGBD en particular que usemos.</p> </li> <li> <p>Nivel externo. Se trata de la visi\u00f3n de los datos que poseen los usuarios finales de la base de datos. Esa visi\u00f3n es la que obtienen a trav\u00e9s de las aplicaciones. Las aplicaciones creadas por los desarrolladores abstraen la realidad conceptual de modo que el usuario no conoce las relaciones entre los datos, como tampoco conoce d\u00f3nde realmente se est\u00e1n almacenando los datos. Es la forma en la que cualquier persona desea manejar una base de datos a trav\u00e9s de formularios, informes, listas,\u2026</p> </li> </ul> <p>La idea de estos niveles procede de la normalizaci\u00f3n hecha en el modelo ANSI/X3/SPARC y sigue estando muy presente en la gesti\u00f3n actual de las bases de datos.</p> <p>Este modelo dict\u00f3 que podemos pasar de unos modelos a otros de manera casi autom\u00e1tica utilizando un software adecuado. El modelo ANSI llama a ese software procesador de modelos y hoy en d\u00eda es lo que se conoce como herramientas CASE (Computer Aided for Software Engineering, Asistente Computerizado para Ingenier\u00eda del Software). Para cada nivel se realizan esquemas relacionados con ellos. As\u00ed hay esquemas externos (varios), esquema conceptual, esquema interno y esquema f\u00edsico que forman todos los aspectos de la base de datos.</p> <p></p> <p>En la Ilustraci\u00f3n se observa la distancia que poseen los usuarios de la base de datos respecto a la realidad f\u00edsica de la base de datos (representada con el cilindro). La f\u00edsica son los datos en crudo, es decir en formato binario dentro del disco o discos que los contienen. El esquema f\u00edsico es el que se realiza pensando m\u00e1s en esa realidad y los esquemas externos los que se crean pensando en la visi\u00f3n de los usuarios.</p> <p>Las dos columnas que aparecen en la imagen reflejan dos fronteras a tener en cuenta:</p> <ul> <li> <p>Independencia L\u00f3gica. Los esquemas de los niveles conceptual y externo son independientes del software concreto de base de datos que usemos; no dependen en absoluto de \u00e9l. Por ello esos esquemas nos valdr\u00edan para cualquier SGBD que utilicemos.</p> </li> <li> <p>Independencia F\u00edsica. La da la barrera entre el esquema f\u00edsico y el interno e indica que el esquema interno es independiente del hardware concreto que usemos. El esquema f\u00edsico se dise\u00f1a en base a un hardware concreto, pero \u00e9l interno no. Eso permite concentrarse en detalles m\u00e1s conceptuales.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#04-recursos-humanos-de-las-bases-de-datos","title":"04.-Recursos humanos de las bases de datos","text":"<p>Intervienen (como ya se ha comentado) muchas personas en el desarrollo y manipulaci\u00f3n de una base de datos. Se describen, a continuaci\u00f3n, los actores m\u00e1s importantes.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#informaticos","title":"Inform\u00e1ticos","text":"<p>L\u00f3gicamente, son los profesionales que definen y preparan la base de datos. Pueden ser:</p> <ul> <li> <p>Directivos. Organizadores y coordinadores del proyecto a desarrollar y m\u00e1ximos responsables del mismo. Esto significa que son los encargados de decidir los recursos que se pueden utilizar, planificar el tiempo y las tareas, la atenci\u00f3n al usuario y de dirigir las entrevistas y reuniones pertinentes.</p> <p>Son especialistas en gesti\u00f3n de recursos, tanto materiales como humanos.</p> </li> <li> <p>Analistas. Son los encargados de controlar el desarrollo de la base de datos aprobada por la direcci\u00f3n. Dirigen a los desarrolladores y operadores. Normalmente son, adem\u00e1s, los dise\u00f1adores de la base de datos: es decir, crean el esquema conceptual de la misma.</p> </li> <li> <p>Administradores de las bases de datos. Encargados de crear el esquema interno de la base de datos. Tambi\u00e9n gestionan el correcto funcionamiento del SGBD. Sus tareas incluyen la planificaci\u00f3n de copia de seguridad, gesti\u00f3n de usuarios y permisos, optimizaci\u00f3n del rendimiento, monitorizaci\u00f3n de problemas y creaci\u00f3n de los objetos de la base de datos.</p> </li> <li> <p>Desarrolladores o programadores. Encargados de la realizaci\u00f3n de las aplicaciones de usuario para que estos accedan a la base de datos.</p> </li> <li> <p>Equipo de mantenimiento. Tambi\u00e9n se les llama operadores. Encargados de dar soporte a los usuarios en el trabajo diario (suelen incorporar adem\u00e1s tareas administrativas como la creaci\u00f3n de copias de seguridad por ejemplo o el arreglo de problemas de red por ejemplo).</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#usuarios","title":"Usuarios","text":"<ul> <li> <p>Expertos Realizan operaciones avanzadas sobre la base de datos. Normalmente conocen el lenguaje de manipulaci\u00f3n de datos (DML) para acceder a la base de datos. Son usuarios, por lo tanto, con conocimientos inform\u00e1ticos que se encargan en las empresas de los clientes de algunas acciones m\u00e1s complejas sobre la base de datos que las que realizan los usuarios habituales.</p> </li> <li> <p>Habituales. Utilizan las aplicaciones creadas por los desarrolladores para consultar y actualizar los datos. Son los que trabajan en la empresa a diario con estas herramientas y el objetivo fundamental de todo el desarrollo de la base de datos.</p> </li> <li> <p>Ocasionales. Son usuarios que utilizan un acceso m\u00ednimo a la base de datos a trav\u00e9s de una aplicaci\u00f3n que permite consultar ciertos datos. Ser\u00edan por ejemplo los usuarios que consultan el horario de trenes a trav\u00e9s de Internet. Aunque se les llama ocasionales son el n\u00facleo del trabajo con la base de datos ya que son los que m\u00e1s la utilizan (ya que son sus usuarios m\u00e1s numerosos) y son, por ejemplo, los que visitan la base de datos para realizar compras o para informarse del negocio representado en la base de datos.</p> </li> </ul> <p></p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#05-proceso-de-creacion-y-manipulacion-de-una-base-de-datos","title":"05.-Proceso de creaci\u00f3n y manipulaci\u00f3n de una base de datos","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#fase-de-creacion","title":"Fase de creaci\u00f3n:","text":"<ol> <li> <p>El analista o dise\u00f1ador crea el esquema conceptual. En muchas ocasiones, utilizando una herramienta CASE para dise\u00f1ar el esquema de forma m\u00e1s c\u00f3moda.</p> </li> <li> <p>El administrador de la base de datos (DBA) recoge ese esquema y crea el esquema interno de la base de datos. Tambi\u00e9n se encarga, previamente, de determinar el SGBD id\u00f3neo y de configurar el software del SGBD as\u00ed como de establecer las pol\u00edticas de copia de seguridad.</p> </li> <li>Los desarrolladores tambi\u00e9n recogen el esquema conceptual y utilizan las aplicaciones necesarias para generar los esquemas externos, que realmente se traducir\u00e1n en programas y aplicaciones, que necesitan los usuarios.</li> </ol>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#fase-de-manipulacion","title":"Fase de manipulaci\u00f3n:","text":"<p>Ocurre con la base de datos ya creada y en funcionamiento.</p> <ol> <li>El usuario realiza una operaci\u00f3n sobre la base de datos (una consulta, modifica o a\u00f1ade un dato, etc.)</li> <li>Las aplicaciones las traducen a su forma conceptual utilizando el diccionario de datos, que posee todos los metadatos necesarios.</li> <li>El esquema conceptual es traducido por la SGBD a su forma interna, nuevamente con ayuda del Diccionario de Datos.</li> <li>EL SGBD se comunica con el Sistema Operativo para pedir que acceda al disco (estamos, por lo tanto ya en el nivel f\u00edsico) y recoja los datos requeridos (siempre con ayuda del Diccionario de Datos).</li> <li>El Sistema Operativo accede al almacenamiento f\u00edsico correspondiente y devuelve los datos al SGBD.</li> <li>El SGBD transforma los datos internos en datos conceptuales y los entrega a la aplicaci\u00f3n.</li> <li>La aplicaci\u00f3n muestra los datos habi\u00e9ndolos traducido a una forma (externa) amigable y apta para ser entregada al usuario que hizo la petici\u00f3n.</li> </ol>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#06-estructura-multicapa","title":"06.-Estructura multicapa","text":"<p>El proceso que realiza un SGBD para acceder a los datos est\u00e1 en realidad formado por varias capas que act\u00faan como interface. El usuario nunca accede a los datos directamente. Estas capas son las que consiguen implementar los niveles de abstracci\u00f3n de la base de datos.</p> <p>Fue el propio organismo ANSI (en su modelo ANSI/X3/SPARC) la que introdujo una mejora de su modelo de bases de datos en 1988 a trav\u00e9s de un grupo de trabajo llamado UFTG (User Facilities Task Group, grupo de trabajo para las facilidades de usuario). Este modelo toma como objeto principal al usuario habitual de la base de datos y modela el funcionamiento de la base de datos en una sucesi\u00f3n de capas cuya finalidad es ocultar y proteger la parte interna de las bases de datos.</p> <p>Desde esta \u00f3ptica, para llegar a los datos hay que pasar una serie de capas que desde la parte m\u00e1s externa poco a poco van entrando m\u00e1s en la realidad f\u00edsica de la base de datos.</p> <p>Este marco sigue teniendo vigencia actualmente e indica que el acceso a los datos no es instant\u00e1neo, que los datos est\u00e1n protegidos de los usuarios que pasan (sin saberlo) por varias capas de proceso antes de que sus peticiones a la base de datos sean atendidas.</p> <p>Se explican las capas en detalle</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#aplicaciones-de-usuario","title":"Aplicaciones de usuario","text":"<p>Es la capa a la que acceden los usuarios. Proporciona el SGBD a los usuarios un acceso m\u00e1s sencillo a los datos. Son, en definitiva, las p\u00e1ginas web y los programas con las que los usuarios manejan la base de datos. Permite abstraer la realidad de la base de datos a las usuarias y usuarios, mostrando la informaci\u00f3n de una forma m\u00e1s humana.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#capa-de-acceso-a-datos","title":"Capa de acceso a datos","text":"<p>La capa de acceso a datos es la que permite comunicar a las aplicaciones de usuario con el diccionario de datos. Es un software (un driver o controlador, en realidad) que se encarga traducir las peticiones del usuario para que lleguen de forma correcta a la base de datos y \u00e9sta pueda responder de forma adecuada.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#diccionario-de-datos","title":"Diccionario de datos","text":"<p>Se trata de una estructura interna del SGBD que contiene todos los metadatos. Esta estructura es la que permite pasar de un nivel a otro.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#nucleo","title":"N\u00facleo","text":"<p>El n\u00facleo de la base de datos es la capa encargada de traducir todas las instrucciones requeridas y prepararlas para su correcta interpretaci\u00f3n por parte del sistema. Realiza la traducci\u00f3n f\u00edsica de las peticiones.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#sistema-operativo","title":"Sistema operativo","text":"<p>Es una capa externa al software SGBD pero es la \u00fanica capa que realmente accede a los datos en s\u00ed. En realidad los SGBD no acceden directamente al disco, sino que piden al Sistema Operativo que lo haga, ya que es el que maneja el sistema de discos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#07-funcionamiento-del-sgbd","title":"07.-Funcionamiento del SGBD","text":"<p>La siguiente ilustraci\u00f3n presenta el funcionamiento t\u00edpico de un SGBD. En ella se reproduce la comunicaci\u00f3n entre un usuario que desea acceder a los datos y el SGBD:</p> <p></p> <ol> <li>Los usuarios utilizan una aplicaci\u00f3n para acceder a los datos. Estamos en el nivel externo de la base de datos, por lo que la propia aplicaci\u00f3n traduce la petici\u00f3n que hizo el usuario de forma sencilla, a una petici\u00f3n entendible por la capa de acceso a los datos.</li> <li> <p>El proceso cliente es el software de acceso a la base de datos y que est\u00e1 instalado en el lado del cliente. Se encarga simplemente de recoger y enviar la petici\u00f3n (comprobando antes si hay comunicaci\u00f3n con el servidor de la base de datos).</p> </li> <li> <p>A trav\u00e9s de la red (normalmente) el proceso cliente se comunica con el proceso servidor, que es el software de comunicaci\u00f3n instalado en el lado del servidor. Ambos procesos (cliente y servidor) forman la capa de acceso a los datos.</p> </li> <li> <p>Estando ya en el servidor, la petici\u00f3n pasa al software del Sistema Gestor de Bases de Datos (habr\u00e1 aqu\u00ed, como se ha visto en el apartado anterior una traducci\u00f3n de datos, desde el nivel externo al nivel interno).</p> </li> <li> <p>El SGBD, comprobando el diccionario de datos, comprueba si la petici\u00f3n es correcta.</p> </li> <li> <p>El SGBD tambi\u00e9n revisa el diccionario de datos (si la petici\u00f3n es correcta) para saber con exactitud en qu\u00e9 archivos y en qu\u00e9 parte dentro de ellos, se encuentran los datos requeridos</p> </li> <li> <p>Con la informaci\u00f3n sobre d\u00f3nde est\u00e1n los datos, el SGBD hace una petici\u00f3n al Sistema Operativo, que es el que tiene capacidad realmente de acceder a los archivos de datos. Por ello la petici\u00f3n del SGBD se traduce al formato utilizado por el Sistema Operativo.El Sistema Operativo accede a los datos.</p> </li> <li> <p>El Sistema Operativo recibe los datos.</p> </li> <li> <p>Se entregan los datos al Sistema Gestor de Bases de Datos o, si ha habido un error al acceder a los datos, se indica el error ocurrido.</p> </li> <li> <p>El SGBD traduce los datos a una forma m\u00e1s conceptual y se los entrega al proceso servidor.</p> </li> <li> <p>Los datos se entregan al proceso cliente.</p> </li> <li> <p>Los datos llegan a la aplicaci\u00f3n.</p> </li> <li> <p>La aplicaci\u00f3n de usuario traduce los datos recibidos en informaci\u00f3n presentada de la forma m\u00e1s conveniente para el usuario.</p> </li> </ol>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#08-formas-de-ejecucion-de-un-sgbd","title":"08.-Formas de ejecuci\u00f3n de un SGBD","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#sgbd-monocapa","title":"SGBD monocapa","text":"<p>Se trata de Sistemas Gestores instalados en una m\u00e1quina desde la que se conectan los propios usuarios y administradores. Es decir, todo el sistema est\u00e1 en una sola m\u00e1quina.</p> <p></p> <p>Es un modelo que s\u00f3lo se utiliza con bases de datos peque\u00f1as y poca cantidad de conexiones. La popular Access de Microsoft es considerada un sistema gestor monocapa (aunque tiene algunas posibilidades para utilizar en dos capas).</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#sgbd-bicapa","title":"SGBD bicapa","text":"<p>Usa un modelo de funcionamiento tipo cliente/servidor. La base de datos y el sistema gestor se alojan en un servidor al cual se conectan los usuarios desde m\u00e1quinas clientes. Un software de comunicaciones se encarga de permitir el acceso a trav\u00e9s de la red. Los clientes deben instalar el software cliente de acceso seg\u00fan las instrucciones de configuraci\u00f3n del administrador.</p> <p>Hay dos posibilidades:</p> <ul> <li> <p>Arquitectura cliente/servidor \u00fanico. Un solo servidor gestiona la base de datos, todos los clientes se conectan a \u00e9l para realizar las peticiones a la base de datos.</p> </li> <li> <p>Arquitectura cliente/multiservidor. La base de datos se distribuye entre varios servidores. El cliente no sabe realmente a qu\u00e9 servidor se conecta; el software de control de comunicaciones se encargar\u00e1 de dirigir al usuario al servidor adecuado. De forma l\u00f3gica, es como si se tratara de un solo servidor aunque f\u00edsicamente sean muchos (el cliente no percibe que haya m\u00e1s de un servidor).</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/03.-Funcionamiento%20de%20un%20SGBD/#sgbd-de-tres-o-mas-capas","title":"SGBD de tres o m\u00e1s capas","text":"<p>En este caso entre el cliente y el servidor hay al menos una capa intermedia (puede haber varias). Esa capa (o capas) se encarga de recoger las peticiones de los clientes y luego de comunicarse con el servidor (o servidores) de bases de datos para recibir la respuesta y enviarla al cliente.</p> <p>El caso t\u00edpico es que la capa intermedia sea un servidor web, que recibe las peticiones a trav\u00e9s de aplicaciones web; de este modo para conectarse a la base de datos, el usuario solo requiere un navegador web, que es un software muy habitual en cualquier m\u00e1quina y por lo tanto no requiere una instalaci\u00f3n de software adicional en la m\u00e1quina cliente.</p> <p></p> <p>Este modelo es el que m\u00e1s se est\u00e1 potenciando en la actualidad por motivos de seguridad y portabilidad de la base de datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/","title":"01.-Introducci\u00f3n","text":"<p>Como se ha visto en los apartados anteriores, resulta que cada SGBD puede utilizar un modelo diferente para los datos. Por lo que hay modelos conceptuales diferentes seg\u00fan que SGBD utilicemos. Esto da lugar a un diagrama de trabajo para los profesionales de la base de datos que permite saber qu\u00e9 esquemas hay que realizar (y en qu\u00e9 orden) para crear una base de datos.</p> <p></p> <p>El punto de partida es el uso en el mundo real que tendr\u00e1 la base de datos. Ese punto es en el que est\u00e1n los usuarios y es crucial tenerlo muy claro. El punto final es el almacenamiento f\u00edsico de la base de datos.</p> <p>En este esquema aparece el llamado Esquema L\u00f3gico, que permite pasar de forma m\u00e1s gradual del esquema conceptual al esquema interno.</p> <p>No obstante existen modelos l\u00f3gicos comunes, ya que hay SGBD de diferentes tipos. En la realidad el modelo conceptual cl\u00e1sico se modifica para que existan dos modelos internos: el modelo l\u00f3gico (referido a cualquier SGBD de ese tipo) y el modelo conceptual propiamente interno (aplicable s\u00f3lo a un SGBD en particular). De hecho, en la pr\u00e1ctica, al definir las bases de datos desde el mundo real hasta llegar a los datos f\u00edsicos se pasa por todos los esquemas se\u00f1alados en la Ilustraci\u00f3n.</p> <p>Por lo tanto la diferencia entre los distintos SGBD est\u00e1 en que proporcionan diferentes modelos l\u00f3gicos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#diferencias-entre-el-modelo-logico-y-el-conceptual","title":"Diferencias entre el modelo l\u00f3gico y el conceptual","text":"<ul> <li> <p>El modelo conceptual es independiente del DBMS que se vaya a utilizar. El l\u00f3gico depende de un tipo de SGBD en particular</p> </li> <li> <p>El modelo l\u00f3gico est\u00e1 m\u00e1s cerca del modelo f\u00edsico, el que utiliza internamente el ordenador</p> </li> <li> <p>El modelo conceptual es el m\u00e1s cercano al usuario, el l\u00f3gico es el encargado de establecer el paso entre el modelo conceptual y el modelo f\u00edsico del sistema.</p> </li> </ul> <p>Algunos ejemplos de modelos conceptuales son:</p> <ul> <li> <p>Modelo Entidad Relaci\u00f3n</p> </li> <li> <p>Modelo RM/T</p> </li> <li> <p>Modelo UML</p> </li> </ul> <p>Ejemplos de modelos l\u00f3gicos son:</p> <ul> <li> <p>Modelo Relacional</p> </li> <li> <p>Modelo Codasyl</p> </li> <li> <p>Modelo Jer\u00e1rquico</p> </li> </ul> <p>A continuaci\u00f3n se comentar\u00e1n los modelos l\u00f3gicos m\u00e1s importantes.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#02-modelo-jerarquico","title":"02.-Modelo jer\u00e1rquico","text":"<p>Era utilizado por los primeros SGBD, desde que IBM lo defini\u00f3 para su IMS (Information Management System, Sistema Administrador de Informaci\u00f3n) en 1970. Se le llama tambi\u00e9n modelo en \u00e1rbol debido a que utiliza una estructura en \u00e1rbol para organizar los datos.</p> <p>La informaci\u00f3n se organiza con un jerarqu\u00eda en la que la relaci\u00f3n entre las entidades de este modelo siempre es del tipo padre / hijo. De esta forma hay una serie de nodos que contendr\u00e1n atributos y que se relacionar\u00e1n con nodos hijos de forma que puede haber m\u00e1s de un hijo para el mismo padre (pero un hijo s\u00f3lo tiene un padre).</p> <p></p> <p>Los datos de este modelo se almacenan en estructuras l\u00f3gicas llamadas segmentos. Los segmentos se relacionan entre s\u00ed utilizando arcos.</p> <p>La forma visual de este modelo es de \u00e1rbol invertido, en la parte superior est\u00e1n los padres y en la inferior los hijos.</p> <p>Este esquema est\u00e1 en absoluto desuso ya que no es v\u00e1lido para modelar la mayor\u00eda de problemas de bases de datos. Su virtud era la facilidad de manejo ya que s\u00f3lo existe un tipo de relaci\u00f3n (padre/hijo) entre los datos; su principal desventaja es que no basta para representar la mayor\u00eda de relaciones. Adem\u00e1s no manten\u00eda la independencia con la base de datos f\u00edsica.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#03-modelo-en-red-codasyl","title":"03.-Modelo en red (Codasyl)","text":"<p>Es un modelo que ha tenido una gran aceptaci\u00f3n (aunque apenas se utiliza actualmente). En especial se hizo popular la forma definida por el est\u00e1ndar Codasyl a principios de los 70 que se convirti\u00f3 en el modelo en red m\u00e1s utilizado.</p> <p></p> <p>El modelo en red organiza la informaci\u00f3n en registros (tambi\u00e9n llamados nodos) y enlaces. En los registros se almacenan los datos, mientras que los enlaces permiten relacionar estos datos. Las bases de datos en red son parecidas a las jer\u00e1rquicas s\u00f3lo que en ellas puede haber m\u00e1s de un padre.</p> <p>En este modelo se pueden representar perfectamente cualquier tipo de relaci\u00f3n entre los datos (aunque el Codasyl restring\u00eda un poco las relaciones posibles), pero hace muy complicado su manejo.</p> <p>Pose\u00eda un lenguaje poderoso de trabajo con la base de datos. El problema era la complejidad para trabajar con este modelo tanto para manipular los datos como programar aplicaciones de acceso a la base de datos. Tampoco manten\u00eda una buena independencia con la f\u00edsica de la base de datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#04-modelo-relacional","title":"04.-Modelo Relacional","text":"<p>Es el modelo m\u00e1s popular. Los datos se organizan en tablas y estas en columnas y filas de datos. Las tablas se relacionan entre s\u00ed para ligar todos los datos.</p> <p>Se basa en la teor\u00eda de conjuntos y consigue una gran separaci\u00f3n entre lo conceptual y lo f\u00edsico, consiguiendo su total independencia. Tiene un lenguaje considerado est\u00e1ndar, el SQL y una enorme red de usuarios y documentaci\u00f3n que facilita su aprendizaje. Adem\u00e1s dota de una gran facilidad para establecer reglas complejas a los datos.</p> <p>El problema es que la simplicidad de manejo y la independencia que consigue se logra a base de un software muy complejo que requiere tambi\u00e9n un hardware poderoso.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#05-modelo-de-bases-de-datos-orientadas-a-objetos","title":"05.-Modelo de bases de datos orientadas a objetos","text":"<p>Desde la aparici\u00f3n de la programaci\u00f3n orientada a objetos (POO u OOP) se empez\u00f3 a pensar en bases de datos adaptadas a estos lenguajes. La programaci\u00f3n orientada a objetos permite cohesionar datos y procedimientos, haciendo que se dise\u00f1en estructuras que poseen datos (atributos) en las que se definen los procedimientos (operaciones) que pueden realizar con los datos. En las bases orientadas a objetos se utiliza esta misma idea.</p> <p>A trav\u00e9s de este concepto se intenta que estas bases de datos consigan arreglar las limitaciones de las relacionales. Por ejemplo el problema de la herencia (el hecho de que no se puedan realizar relaciones de herencia entre las tablas), tipos definidos por el usuario, disparadores (triggers) almacenables en la base de datos, soporte multimedia...</p> <p>Se supone que son las bases de datos de tercera generaci\u00f3n (la primera fue las bases de datos en red y la segunda las relacionales), lo que significa que el futuro parece estar a favor de estas bases de datos. Pero siguen sin reemplazar a las relacionales, aunque son el tipo de base de datos que m\u00e1s est\u00e1 creciendo en los \u00faltimos a\u00f1os.</p> <p>Su modelo conceptual se suele dise\u00f1ar usando la notaci\u00f3n UML (Unified Modeling Language) y el l\u00f3gico usando ODMG (Object Data Management Group, grupo de administraci\u00f3n de objetos de datos), organismo que intenta crear est\u00e1ndares para este modelo.</p> <p>Sus ventajas est\u00e1n en el hecho de usar la misma notaci\u00f3n que la de los programas (lo que facilita la tarea de su aprendizaje a los analistas y desarrolladores) y que el significado de los datos es m\u00e1s completo. Lo malo es que no posee un lenguaje tan poderoso como el modelo relacional para manipular datos y metadatos, que tiene m\u00e1s dificultades para establecer reglas a los datos y que al final es m\u00e1s complejo para manejar los datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#06-bases-de-datos-objeto-relacionales","title":"06.-Bases de datos objeto-relacionales","text":"<p>Tratan de ser un h\u00edbrido entre el modelo relacional y el orientado a objetos. El problema de las bases de datos orientadas a objetos es que requieren reinvertir capital y esfuerzos de nuevo para convertir las bases de datos relacionales en bases de datos orientadas a objetos. En las bases de datos objeto relacionales se intenta conseguir una compatibilidad relacional dando la posibilidad de integrar mejoras de la orientaci\u00f3n a objetos.</p> <p>Estas bases de datos se basan en el est\u00e1ndar ISO SQL 2000 y los siguientes. En ese est\u00e1ndar se a\u00f1ade a las bases relacionales la posibilidad de almacenar procedimientos de usuario, triggers, tipos definidos por el usuario, consultas recursivas, bases de datos OLAP, tipos LOB,...</p> <p>Las \u00faltimas versiones de la mayor\u00eda de las cl\u00e1sicas grandes bases de datos relacionales (Oracle, SQL Server, DB2, ...) son objeto relacionales.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/04.-Tipos%20de%20SGBD/#07-bases-de-datos-nosql","title":"07.-Bases de datos NoSQL","text":"<p>En los \u00faltimos a\u00f1os ha aparecido todo un g\u00e9nero de bases de datos (de varios tipos) que intentan paliar deficiencias detectadas en el modelo relacional.</p> <p>El dominio de este modelo parec\u00eda demostrar, durante d\u00e9cadas, que era el tipo ideal de base de datos. El cambio de perspectiva se ha producido por la alt\u00edsima demanda de servicios que requiere Internet. En especial si lo que se requiere es escribir o modificar datos, ya que actualmente todos los usuarios de Internet crean much\u00edsimos datos cada d\u00eda que requieren ser almacenados inmediatamente (el caso m\u00e1s claro es el de las redes sociales).</p> <p>Con este panorama han aparecido nuevos tipos de bases de datos y se han modificado y actualizado tipos antiguos que ahora parecen \u00fatiles. Lo que aportan la mayor\u00eda de estos tipos de bases de datos, es el uso de otro tipo de esquemas conceptuales e internos m\u00e1s apropiados para este tipo de demandas de usuario.</p> <p>En resumen las bases de datos NoSQL renuncian al modelo relacional para paliar las carencias del modelo relacional en estos aspectos:</p> <ul> <li> <p>Aceptar un enorme cantidad peticiones de consulta y especialmente de modificaci\u00f3n de datos por minuto</p> </li> <li> <p>Gestionar datos muy heterog\u00e9neos (irregulares, con tipos de datos cambiantes)</p> </li> <li> <p>Gestionar datos que se relacionan de manera muy compleja</p> </li> <li> <p>Usar otros lenguajes (diferentes a SQL), m\u00e1s aptos para otras tareas</p> </li> </ul> <p>Esto no significa que cada base de datos NoSQL sea capaz de mejorar en todos los aspectos anteriores, cada tipo de base de datos NoSQL est\u00e1 pensado para algunos de los puntos anteriores.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/","title":"01.-Introducci\u00f3n","text":"<p>Los ficheros o archivos son la herramienta fundamental de trabajo en una computadora todav\u00eda a d\u00eda de hoy. Las computadoras siguen almacenando la informaci\u00f3n en ficheros; eso s\u00ed, su estructura es cada vez m\u00e1s compleja.</p> <p>Los datos deben de ser almacenados en componentes de almacenamiento permanente, lo que se conoce como memoria secundaria (discos duros u otras unidades de disco). En esas memorias, los datos se estructuran en archivos (tambi\u00e9n llamados ficheros).</p> <p>Un fichero es una secuencia de n\u00fameros binarios que organiza informaci\u00f3n relacionada a un mismo aspecto.</p> <p>En general sobre los archivos se pueden realizar las siguientes operaciones:</p> <ul> <li> <p>Abrir (open). Prepara el fichero para su proceso.</p> </li> <li> <p>Cerrar (close). Cierra el fichero impidiendo su proceso inmediato.</p> </li> <li> <p>Leer (read). Obtiene informaci\u00f3n del fichero.</p> </li> <li> <p>Escribir (write). Graba informaci\u00f3n en el fichero.</p> </li> <li> <p>Posicionarse (seek). Coloca el puntero de lectura en una posici\u00f3n concreta del mismo (no se puede realizar en todos los tipos de ficheros).</p> </li> <li> <p>Comprobar fin de fichero (eof). Indica si hemos llegado al final del fichero.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#02-uso-de-archivos-para-grabar-datos","title":"02.-Uso de archivos para grabar datos","text":"<p>Los archivos, como herramienta para almacenar informaci\u00f3n, tomaron la terminolog\u00eda del mundo de la oficina empresarial. As\u00ed la palabra dato hace referencia a un valor sea un n\u00famero o un texto o cualquier otro tipo de datos almacenable.</p> <p>Cuando podemos distinguir datos referidos a una misma propiedad real a la que podemos poner un nombre, hablamos de campos. As\u00ed: S\u00e1nchez, Rodr\u00edguez, Serrat y Crespo son datos que perfectamente podr\u00edan encajar en un campo llamado Primer Apellido.</p> <p>Los datos que se refieren al mismo elemento real (una persona, una factura, un movimiento bancario,\u2026) se agrupan en registros. En un fichero de datos personales, cada registro ser\u00eda una persona; cada campo ser\u00eda cada propiedad distinguible en la persona.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#03-tipos-de-archivos","title":"03.-Tipos de archivos","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ficheros-secuenciales","title":"ficheros secuenciales","text":"<p>En estos ficheros, los datos se organizan secuencialmente en el orden en el que fueron grabados. Para leer los \u00faltimos datos hay que leer los anteriores. Es decir leer el registro n\u00famero nueve, implica leer previamente los ocho anteriores.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ventajas","title":"ventajas","text":"<ul> <li> <p>R\u00e1pidos para obtener registros contiguos de una base de datos</p> </li> <li> <p>No hay huecos en el archivo al grabarse los datos seguidos, datos m\u00e1s compactos.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#desventajas","title":"desventajas","text":"<ul> <li> <p>Consultas muy lentas al tener que leer todos los registros anteriores en el orden del archivo respecto al que queremos leer. Es decir, que si queremos leer el quinto registro, hay que leer los cuatro anteriores.</p> </li> <li> <p>Algoritmos de lectura y escritura complejos. No es f\u00e1cil hacer operaciones avanzadas con los datos</p> </li> <li> <p>No se pueden eliminar registros del fichero (se pueden marcar de manera especial para que no sean tenidos en cuenta, pero no se pueden borrar)</p> </li> <li> <p>El borrado provoca archivos que no son compactos</p> </li> <li> <p>La ordenaci\u00f3n de los datos requiere leer todos los datos, reorganizarlos en memoria y volver a grabarles en el archivo en el orden correcto. Se trata de una operaci\u00f3n excesivamente lenta</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ficheros-de-acceso-directo-o-aleatorio","title":"ficheros de acceso directo o aleatorio","text":"<p>En estos ficheros se puede leer una posici\u00f3n concreta directamente; bastar\u00e1 saber la posici\u00f3n exacta (normalmente en bytes) del dato a leer para obtenerle. Es decir, posicionarnos en el quinto registro se har\u00eda de golpe, con una sola instrucci\u00f3n. Lo \u00fanico que necesitamos saber el tama\u00f1o de cada registro, que en este tipo de ficheros debe de ser el mismo. Suponiendo que cada registro ocupa 100 bytes, el quinto registro comenzar\u00e1 en la posici\u00f3n 400. A partir de esa posici\u00f3n podremos leer todos los datos del registro.</p> <p></p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ventajas_1","title":"ventajas","text":"<ul> <li> <p>Acceso r\u00e1pido a un registro concreto. No necesita leer los datos anteriores</p> </li> <li> <p>La modificaci\u00f3n de datos es m\u00e1s sencilla</p> </li> <li> <p>Permiten acceso secuencial adem\u00e1s del aleatorio (por lo que mejoran el caso anterior)</p> </li> <li> <p>Permiten tanto leer como escribir a sin necesidad de cerrar el archivo.</p> </li> <li> <p>Aptos para organizaciones relativas directas, en las que la clave del registro se relaciona con su posici\u00f3n en el archivo.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#desventajas_1","title":"desventajas","text":"<ul> <li> <p>Salvo en archivos relativos directos, no es apto por s\u00ed mismo para usar en bases de datos, ya que los datos se organizan en base a una clave que casi nunca coincide con la posici\u00f3n del registro en el archivo</p> </li> <li> <p>No se pueden borrar datos (s\u00ed marcar para borrado, pero generar\u00e1n huecos)</p> </li> <li> <p>Las consultas sobre multitud de registros son m\u00e1s lentas que en el caso anterior.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ficheros-secuenciales-encadenados","title":"ficheros secuenciales encadenados","text":"<p>Son ficheros con registros grabados secuencialmente que podr\u00edamos recorrer registro a registro o de forma aleatoria. Adem\u00e1s cada registro posee un campo que contiene la direcci\u00f3n de otro registro (a este tipo de campos se les llama punteros). Cada registro usa su puntero para indicar la direcci\u00f3n del siguiente registro. Usando los punteros podremos recorrer los registros en un orden concreto.</p> <p>Cuando aparece un nuevo registro, se a\u00f1ade al final del archivo, pero los punteros se reordenan para que se mantenga el orden.</p> <p></p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ventajas_2","title":"ventajas","text":"<ul> <li> <p>El fichero mantiene el orden en el que se a\u00f1adieron los registros y un segundo orden en base a una clave. Incluso a\u00f1adiendo m\u00e1s punteros a cada registro podremos establecer m\u00e1s formas de ordenar los registros.</p> </li> <li> <p>La operaci\u00f3n de ordenaci\u00f3n no requiere reorganizar todo el fichero, sino s\u00f3lo modificar los punteros</p> </li> <li> <p>Posee las mismas ventajas que el acceso secuencial y el acceso aleatorio</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#desventajas_2","title":"desventajas","text":"<ul> <li> <p>No se borran los registros, sino que se marcan para ser ignorados. Por lo que se malgasta espacio</p> </li> <li> <p>A\u00f1adir registros o modificar las claves son operaciones que requieren recalcular los punteros por lo que llevan m\u00e1s tiempo que en los casos anteriores</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ficheros-secuenciales-indexados","title":"ficheros secuenciales indexados","text":"<p>Se utilizan dos ficheros para los datos, uno posee los registros almacenados de forma secuencial, pero que permite su acceso aleatorio. El otro posee una tabla con punteros a la posici\u00f3n ordenada de los registros. Ese segundo fichero es el \u00edndice, una tabla con la ordenaci\u00f3n deseada para los registros y la posici\u00f3n que ocupan en el archivo.</p> <p>El archivo de \u00edndices posee unas cuantas entradas s\u00f3lo en las que se indica la posici\u00f3n de ciertos valores claves en el archivo (cada 10, 15 ,20,... registros del archivo principal se a\u00f1ade una entrada en el de \u00edndices). El archivo principal tiene que estar siempre ordenado y as\u00ed cuando se busca un registro, se busca su valor clave en la tabla de \u00edndices, la cual poseer\u00e1 la posici\u00f3n del registro buscado. Desde esa posici\u00f3n se busca secuencialmente el registro hasta encontrarlo.</p> <p>Existe un tercer archivo llamado de desbordamiento u overflow en el que se colocan los nuevos registros que se van a\u00f1adiendo (para no tener que ordenar el archivo principal cada vez que se a\u00f1ade un nuevo registro) este archivo est\u00e1 desordenado. Se utiliza s\u00f3lo si se busca un registro y no se encuentra en el archivo principal. En ese caso se recorre todo el archivo de overflow hasta encontrarlo.</p> <p>Para no tener demasiados archivos en overflow (lo que restar\u00eda velocidad ya que no utilizar\u00edamos el archivo de \u00edndices que es el que da velocidad), cada cierto tiempo se reorganiza el archivo principal, ordenando los datos en el orden correcto y recalculando el archivo de \u00edndices. Ejemplo:</p> <p></p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ventajas_3","title":"ventajas","text":"<ul> <li> <p>El archivo est\u00e1 siempre ordenado de forma secuencial en base a una clave. Por lo que la simple lectura secuencial del archivo obtiene un listado ordenado de los datos.</p> </li> <li> <p>La b\u00fasqueda de datos es rapid\u00edsima</p> </li> <li> <p>Permite la lectura secuencial (que adem\u00e1s ser\u00e1 en el orden de la clave)</p> </li> <li> <p>A\u00f1adir un solo registro no conlleva un tiempo extra como en el caso anterior</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#desventajas_3","title":"desventajas","text":"<ul> <li>Para un uso \u00f3ptimo hay que reorganizar el archivo principal cada cierto tiempo y esta operaci\u00f3n es muy costosa ya que hay que reescribir de nuevo y de forma ordenada todo el archivo con el \u00e1rea primeria, adem\u00e1s de reorganizar el \u00e1rea de \u00edndices y eliminar el fichero de desbordamiento. Es tan costosa que se hace muy poco a menudo, pero en archivos de datos que se modifican muy a menudo, no reorganizar provocar\u00eda un \u00e1rea de desbordamiento enorme y perder\u00edamos las ventajas de este modelo.</li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ficheros-indexado-encadenados","title":"ficheros indexado-encadenados","text":"<p>Utiliza punteros e \u00edndices, es una variante encadenada del caso anterior. Hay un fichero de \u00edndices equivalente al comentado en el caso anterior y otro fichero de tipo encadenado con punteros a los siguientes registros. La diferencia est\u00e1 en que este segundo fichero que contiene el \u00e1rea primaria de los datos, no est\u00e1 ordenado secuencialmente, sino que el orden se realizar\u00eda recorriendo un puntero (como en el caso de los ficheros secuencialmente encadenados).</p> <p>Cuando se a\u00f1aden registros se a\u00f1aden en un tercer fichero llamado de desbordamiento u overflow. En el \u00e1rea de desbordamiento los datos se almacenan secuencialmente, se accede a ellos si se busca un dato y no se encuentra el \u00e1rea primaria.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#ventajas_4","title":"ventajas","text":"<ul> <li>Posee las mismas ventajas que el modelo anterior adem\u00e1s de que la reordenaci\u00f3n es m\u00e1s r\u00e1pida ya que s\u00f3lo requiere modificar los punteros y el \u00e1rea de \u00edndices (no requiere reordenar todos los datos del \u00e1rea primaria).</li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#desventajas_4","title":"desventajas","text":"<ul> <li>Requieren compactar los datos a menudo para reorganizar \u00edndices y quitar el fichero de desbordamiento y es una operaci\u00f3n lenta (aunque mucho menos lenta que en el caso anterior)</li> </ul> <p>Ilustraci\u00f3n 16. Ejemplo fichero secuencial indexado y encadenado</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#04-operaciones-relacionadas-con-uso-de-archivos-en-bases-de-datos","title":"04.-Operaciones relacionadas con uso de archivos en bases de datos","text":""},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#borrado-y-recuperacion-de-registros","title":"borrado y recuperaci\u00f3n de registros","text":"<p>Algunos de los tipos de ficheros vistos anteriormente no admiten el borrado real de datos, sino que s\u00f3lo permiten a\u00f1adir un dato que indica si el registro est\u00e1 borrado o no. Esto es interesante ya que permite anular una operaci\u00f3n de borrado. Por ello esta t\u00e9cnica de marcar registros, se utiliza casi siempre en todos los tipos de archivos.</p> <p>En otros casos los datos antes de ser eliminados del todo pasan a un fichero especial (conocido como papelera) en el que se mantienen durante cierto tiempo para su posible recuperaci\u00f3n.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#fragmentacion-y-compactacion-de-datos","title":"fragmentaci\u00f3n y compactaci\u00f3n de datos","text":"<p>La fragmentaci\u00f3n en un archivo hace referencia a la posibilidad de que \u00e9ste tenga huecos interiores debido a borrado de datos u a otras causas. Causa los siguientes problemas:</p> <ul> <li> <p>Mayor espacio de almacenamiento</p> </li> <li> <p>Lentitud en las operaciones de lectura y escritura del fichero</p> </li> </ul> <p>Por ello se requiere compactar los datos. Esta t\u00e9cnica permite eliminar los huecos interiores a un archivo. Las formas de realizarla son:</p> <ul> <li> <p>Reescribir el archivo para eliminar los huecos. Es la mejor, pero l\u00f3gicamente es la m\u00e1s lenta al requerir releer y reorganizar todo el contenido del fichero.</p> </li> <li> <p>Aprovechar huecos. De forma que los nuevos registros se inserten en esos huecos. Esta t\u00e9cnica suele requerir un paso previo para reorganizar esos huecos.</p> </li> </ul>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#compresion-de-datos","title":"compresi\u00f3n de datos","text":"<p>En muchos casos para ahorrar espacio de almacenamiento, se utilizan t\u00e9cnicas de compresi\u00f3n de datos. La ventaja es que los datos ocupan menos espacio y la desventaja es que al manipular los datos hay que descomprimirlos lo que hace que las operaciones b\u00e1sicas con el fichero se ralentizan.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/05.-Archivos/#cifrado-de-datos","title":"cifrado de datos","text":"<p>Otra de las opciones habituales sobre ficheros de datos es utilizar t\u00e9cnicas de cifrado para proteger los ficheros en caso de que alguien no autorizado se haga con el fichero. Para leer un fichero de datos, har\u00eda falta descifrar el fichero. Para descifrar necesitamos una clave o bien aplicar m\u00e9todos de descifrado; l\u00f3gicamente cuanto mejor sea la t\u00e9cnica de cifrado, m\u00e1s dif\u00edcil ser\u00e1 descifrar los datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/","title":"06.-Est\u00e1ndares y modelo ANSI","text":"<p>Es uno de los aspectos que todav\u00eda sigue pendiente. Desde la aparici\u00f3n de los primeros gestores de base de datos se intent\u00f3 llegar a un acuerdo para que hubiera una estructura com\u00fan para todos ellos, a fin de que el aprendizaje y manejo de este software fuera m\u00e1s provechoso y eficiente.</p> <p>El acuerdo nunca se ha conseguido del todo, no hay est\u00e1ndares aceptados del todo. Aunque s\u00ed hay unas cuentas propuestas de est\u00e1ndares que s\u00ed funcionan como tales.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/#01-organismos-de-estandarizacion","title":"01.-Organismos de estandarizaci\u00f3n","text":"<p>Los intentos por conseguir una estandarizaci\u00f3n han estado promovidos por organismos de todo tipo. Algunos son estatales, otros privados y otros promovidos por los propios usuarios. Los tres que han tenido gran relevancia en el campo de las bases de datos son ANSI/SPARC/X3, CODASYL y ODMG (\u00e9ste s\u00f3lo para las bases de datos orientadas a objetos). Los organismos grandes (que recogen grandes responsabilidades) dividen sus tareas en comit\u00e9s, y \u00e9stos en grupos de trabajo que se encargan de temas concretos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/#02-isojtc1sc21wg3","title":"02.-ISO/JTC1/SC21/WG3","text":"<ul> <li> <p>ISO (International Organization for Standardization). Es un organismo internacional de definici\u00f3n de est\u00e1ndares de gran prestigio.</p> </li> <li> <p>IEC (International Electrotechnical Commission). Organismo de definici\u00f3n de normas en ambientes electr\u00f3nicos. Es la parte, en definitiva de ISO, dedicada a la creaci\u00f3n de est\u00e1ndares.</p> </li> <li> <p>JTC 1 (Joint Technical Committee). Comit\u00e9 parte de IEC dedicado a la tecnolog\u00eda de la informaci\u00f3n (inform\u00e1tica). En el campo de las bases de datos, el subcomit\u00e9 SC 21 (en el que participan otros organismos nacionales, como el espa\u00f1ol AENOR) posee un grupo de trabajo llamado WG 3 que se dedica a las bases de datos. Este grupo de trabajo es el que define la estandarizaci\u00f3n del lenguaje SQL entre otras cuestiones.</p> </li> </ul> <p>Entre los trabajos que realiza el grupo WG3 est\u00e1 la normalizaci\u00f3n de SQL, adem\u00e1s de otras normas de estandarizaci\u00f3n.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/#03-dbtgcodasyl","title":"03.-DBTG/Codasyl","text":"<p>Codasyl (_COnference on DAta SYstem Languages_) es el nombre de una conferencia iniciada en el a\u00f1o 1959 y que dio lugar a un organismo con la idea de conseguir un lenguaje est\u00e1ndar para la mayor\u00eda de m\u00e1quinas inform\u00e1ticas. Participaron organismos privados y p\u00fablicos del gobierno de Estados Unidos con la finalidad de definir est\u00e1ndares. Su primera tarea fue desarrollar el lenguaje COBOL y otros elementos del an\u00e1lisis, dise\u00f1o y la programaci\u00f3n de ordenadores.</p> <p>La tarea real de estandarizar esos lenguajes se la cedieron al organismo ANSI, pero las ideas e inicios de muchas tecnolog\u00edas se idearon en el consorcio Codasyl.</p> <p>En 1967 se crea un grupo de tareas para bases de datos (Data Base Task Group) y este grupo defini\u00f3 el modelo en red de bases de datos y su integraci\u00f3n con COBOL. A este modelo en red se le denomina modelo Codasyl o modelo DBTG y fue finalmente aceptado por la ANSI.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/#a24ansix3sparc","title":"[a2.4]ANSI/X3/SPARC","text":"<p>ANSI (American National Standards Institute) es un organismo cient\u00edfico de Estados Unidos que ha definido diversos est\u00e1ndares en el campo de las bases de datos. X3 es la parte de ANSI encargada de los est\u00e1ndares en el mundo de la electr\u00f3nica. Finalmente SPARC, System Planning and Repairments Committee, comit\u00e9 de planificaci\u00f3n de sistemas y reparaciones es una subsecci\u00f3n de X3 encargada de los est\u00e1ndares en Sistemas Inform\u00e1ticos en especial del campo de las bases de datos. Su logro fundamental ha sido definir un modelo de referencia para las bases de datos (que se estudiar\u00e1 posteriormente).</p> <p></p> <p>En la actualidad ANSI para Estados Unidos e ISO para todo el mundo son nombres equivalentes en cuanto a estandarizaci\u00f3n de bases de datos, puesto que se habla ya de un \u00fanico modelo de sistema de bases de datos.</p>"},{"location":"00.-Conceptos%20B%C3%A1sicos%20sobre%20SGBD/06.-Est%C3%A1ndares%20y%20modelo%20ANSI/#05-modelo-ansix3sparc","title":"05.-Modelo ANSI/X3/SPARC","text":"<p>El organismo ANSI ha marcado la referencia para la construcci\u00f3n de SGBD. El modelo definido por el grupo de trabajo SPARC se basa en estudios anteriores en los que se defin\u00edan tres niveles de abstracci\u00f3n necesarios para gestionar una base de datos. ANSI profundiza m\u00e1s en esta idea y define c\u00f3mo debe ser el proceso de creaci\u00f3n y utilizaci\u00f3n de estos niveles.</p> <p>En el modelo ANSI se indica que hay tres modelos: externo, conceptual e interno. Se entiende por modelo, el conjunto de normas que permiten crear esquemas (dise\u00f1os de la base de datos).</p> <p>Los esquemas externos reflejan la informaci\u00f3n preparada para el usuario final, el esquema conceptual refleja los datos y relaciones de la base de datos y el esquema interno la preparaci\u00f3n de los datos para ser almacenados.</p> <p>El esquema conceptual contiene la informaci\u00f3n l\u00f3gica de la base de datos. Su estructuraci\u00f3n y las relaciones que hay entre los datos.</p> <p>El esquema interno contiene informaci\u00f3n sobre c\u00f3mo est\u00e1n almacenados los datos en disco. Es el esquema m\u00e1s cercano a la organizaci\u00f3n real de los datos.</p> <p>En definitiva el modelo ANSI es una propuesta te\u00f3rica sobre c\u00f3mo debe de funcionar un sistema gestor de bases de datos (sin duda, la propuesta m\u00e1s importante). Su idea es la siguiente:</p> <p></p> <p>Ilustraci\u00f3n 18. Niveles en el modelo ANSI</p> <p>En la Ilustraci\u00f3n 18, el paso de un esquema a otro se realiza utilizando una interfaz o funci\u00f3n de traducci\u00f3n. En su modelo, la ANSI no indica c\u00f3mo se debe realizar esta funci\u00f3n, s\u00f3lo que debe existir.</p> <p>La arquitectura completa (Ilustraci\u00f3n 19) est\u00e1 dividida en dos secciones, la zona de definici\u00f3n de datos y la de manipulaci\u00f3n. Esa arquitectura muestra las funciones realizadas por humanos y las realizadas por programas.</p> <p>En la fase de definici\u00f3n, una serie de interfaces permiten la creaci\u00f3n de los metadatos que se convierten en el eje de esta arquitectura. La creaci\u00f3n de la base de datos comienza con la elaboraci\u00f3n del esquema conceptual realiz\u00e1ndola el administrador de la empresa (actualmente es el dise\u00f1ador, pero ANSI no lo llam\u00f3 as\u00ed). Ese esquema se procesa utilizando un procesador del esquema conceptual (normalmente una herramienta CASE, interfaz 1 del dibujo anterior) que lo convierte en los metadatos (interfaz 2).</p> <p>La interfaz 3 permite mostrar los datos del esquema conceptual a los otros dos administradores: el administrador de la base de datos y el de aplicaciones (el desarrollador). Mediante esta informaci\u00f3n construyen los esquemas internos y externos mediante las interfaces 4 y 5 respectivamente, los procesadores de estos esquemas almacenan la informaci\u00f3n correspondiente a estos esquemas en los metadatos (interfaces 6 y 7).</p> <p></p> <p>En la fase de manipulaci\u00f3n el usuario puede realizar operaciones sobre la base de datos usando la interfaz 8 (normalmente una aplicaci\u00f3n) esta petici\u00f3n es transformada por el transformador externo/conceptual que obtiene el esquema correspondiente ayud\u00e1ndose tambi\u00e9n de los metadatos (interfaz 9). El resultado lo convierte otro transformador en el esquema interno (interfaz 10) usando tambi\u00e9n la informaci\u00f3n de los metadatos (interfaz 11). Finalmente del esquema interno se pasa a los datos usando el \u00faltimo transformador (interfaz 12) que tambi\u00e9n accede a los metadatos (interfaz 13) y de ah\u00ed se accede a los datos (interfaz 14). Para que los datos se devuelvan al usuario en formato adecuado para \u00e9l se tiene que hacer el proceso contrario (observar dibujo).</p>"},{"location":"01.-Tutorial/","title":"Index","text":"<p>Bienvenido a PostgreSQL. Los siguientes cap\u00edtulos est\u00e1n destinados a dar una simple introducci\u00f3n a PostgreSQL, conceptos de base de datos relacionales y el lenguaje SQL a aquellos  que son nuevos en cualquiera de estos aspectos. S\u00f3lo asumimos algunos  conocimientos generales sobre c\u00f3mo usar las computadoras. No se requiere ning\u00fan Unix/Linux en particular o experiencia de programaci\u00f3n. Esta parte  est\u00e1 destinada principalmente a dar una experiencia pr\u00e1ctica con  aspectos importantes del sistema PostgreSQL. No intenta ser un tratamiento completo o exhaustivo de los temas que cubre.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/","title":"01.-Instalaci\u00f3n","text":"<p>Antes de poder usar PostgreSQL necesitamos instalarlo, por supuesto. Es posible que PostgreSQL ya est\u00e9 instalado, ya sea porque estaba incluido en la distribuci\u00f3n de nuestro sistema operativo o porque el administrador del sistema ya lo instal\u00f3. Si ese es el caso, debemos obtener informaci\u00f3n de la documentaci\u00f3n del sistema operativo o del administrador del sistema sobre c\u00f3mo acceder a PostgreSQL.</p> <p>Si no se est\u00e1 seguro de si PostgreSQL ya est\u00e1 disponible o si se puede utilizar para experimentaci\u00f3n, entonces puedemos instalarlo nosotros mismos. Hacerlo no es dif\u00edcil y puede ser un buen ejercicio. PostgreSQL puede ser instalado por cualquier usuario no privilegiado; no se requiere acceso al superusuario (root).</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion-en-arch-linux","title":"Instalaci\u00f3n en Arch Linux","text":""},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#resumen","title":"Resumen","text":"<pre><code>$ sudo pacman -S postgresql\n$ postgres --version\n$ sudo -iu postgres\n</code></pre> <ul> <li><code>sudo</code>: Ejecuta el comando siguiente con permisos de superusuario o root</li> <li><code>-i</code>: Activa el login shell del usuario especificado, en este caso postgres</li> <li><code>-u postgres</code>: Establece al usuario espec\u00edfico como postgres</li> </ul> <pre><code>$ initdb -D /var/lib/postgres/data\n$ sudo vim /var/lib/postgress/data/postgresql.conf\n\n    # Agregaremos/modificaremos la siguiente linea\n\n       listen_addresses = '*'\n\n$ ip addr | grep inet\n$ sudo vim /var/lib/postgres/data/pg_hba.conf\n\n# Dentro del archivo, encontrar las siguientes l\u00edneas...\n\n    # TYPE  DATABASE        USER            ADDRESS                 METHOD\n    # \"local\" is for Unix domain socket connections only\n    local   all             user                                    trust\n\n    # Agrega la siguiente linea en donde\n    # reemplazar xxx.xxx.xxx.xxx/xx por su direcci\u00f3n IP\n    host    all             all             xxx.xxx.xxx.xxx/xx      md5\n\n$ sudo passwd postgres\n$ sudo -iu postgres\n\n# Dentro...\n[postgres]$ psql\n[postgres]$ ALTER USER postgres WITH password 'xxxx';\n# En las 'xxxx' pondremos nuestra contrase\u00f1a\n\n\n$ sudo systemctl start postgresql.service\n$ sudo systemctl enable postgresql.service\n$ sudo systemctl status postgresql.service\n\n# Habilitar el hist\u00f3rico /var/lib/postgres/.psql_history\n#\n# Debemos crear los ficheros .psql_history y .bashrc en /var/lib/postgres\n# y hacerlos pertenecer al usuario \"postgres\" y al grupo \"postgres\"\n\n$ sudo touch /var/lib/postgres/.bashrc\n$ sudo touch /var/lib/postgres/.psql_history\n$ sudo chown postgres:postgres /var/lib/postgres/.bashrc\n$ sudo chown postgres:postgres /var/lib/postgres/.psql_history\n$ sudo chmod 644 /var/lib/postgres/.bashrc\n$ sudo chmod 644 /var/lib/postgres/.psql_history\n\n# Cargar la variable de entorno PSQL_HISTORY con el fichero .psql_history\n# y exportarla para hacerlo permanente en .bashrc\n\n$ sudo -iu postgres\n$ echo 'export PSQL_HISTORY=/var/lib/postgres/.psql_history' &gt;&gt; /var/lib/postgres/.bashrc\n</code></pre>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/01.-Instalaci%C3%B3n/#instalacion-desde-los-binarios","title":"Instalaci\u00f3n desde los binarios","text":"<p>Si el administrador de no ha establecido las cosas de la manera predeterminada, es posible que tengamos algo m\u00e1s de trabajo que hacer. Por ejemplo, si la m\u00e1quina de servidor de base de datos es una m\u00e1quina remota, tendremos que configurar la variable de entorno <code>PGHOST</code> al nombre de la m\u00e1quina servidor de bases de datos. La variable de entorno <code>PGPORT</code> tambi\u00e9n deber\u00eda que ser establecida. La conclusi\u00f3n es esta: si intentamos iniciar un programa de aplicaci\u00f3n y se queja de que no puede conectarse a la base de datos, debemos consultar al administrador del sitio o, si somos nosotros mismos, la documentaci\u00f3n para asegurarnos de que el entorno est\u00e1 correctamente configurado.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/02.-Fundamentos%20arquitect%C3%B3nicos/","title":"02.-Fundamentos arquitect\u00f3nicos","text":"<p>Antes de proceder,  debemos entender la arquitectura b\u00e1sica del sistema PostgreSQL. Entender c\u00f3mo interact\u00faan entre s\u00ed las partes de PostgreSQL har\u00e1 este cap\u00edtulo algo m\u00e1s claro.</p> <p>En la jerga de bases de datos, PostgreSQL utiliza un modelo cliente/servidor. Una sesi\u00f3n de PostgreSQL consiste en los siguientes procesos de cooperaci\u00f3n (programas):</p> <ul> <li> <p>Un proceso de servidor, que administra los archivos de la base de datos, acepta conexiones a la base de datos de aplicaciones de clientes y realiza acciones de base de datos en nombre de los clientes. El programa de servidores de bases de datos se llama <code>postgres</code>.</p> </li> <li> <p>La aplicaci\u00f3n cliente (frontend) del usuario que quiere realizar operaciones de base de datos. Las aplicaciones de cliente pueden ser de muy diversa naturaleza: un cliente podr\u00eda ser una herramienta orientada al texto, una aplicaci\u00f3n gr\u00e1fica, un servidor web que acceda a la base de datos para mostrar p\u00e1ginas web, o una herramienta especializada de mantenimiento de bases de datos. Algunas aplicaciones de clientes se suministran con la distribuci\u00f3n PostgreSQL; la mayor\u00eda son desarrolladas por los usuarios.</p> </li> </ul> <p>Como es t\u00edpico de las aplicaciones cliente/servidor, el cliente y el servidor pueden estar en diferentes hosts. En ese caso se comunican a trav\u00e9s de una conexi\u00f3n de red TCP/IP.  Debemos tener esto en cuenta, porque los archivos a los que se puede acceder en una m\u00e1quina cliente pueden no ser accesibles (o s\u00f3lo podr\u00edan ser accesibles usando un nombre de archivo diferente) en la m\u00e1quina del servidor de bases de datos.</p> <p>El servidor PostgreSQL puede manejar m\u00faltiples conexiones simult\u00e1neas de los clientes. Para lograrlo comienza un nuevo proceso (\"forks\")  para cada conexi\u00f3n. A partir de ese momento, el cliente y el nuevo proceso de servidor se comunican sin la intervenci\u00f3n del proceso original <code>postgres</code>. Por lo tanto, el proceso de servidor supervisor siempre est\u00e1 funcionando, esperando conexiones de clientes, mientras que los procesos de servidor asociados y el cliente van y vienen. (Todo esto es, por supuesto, invisible para el usuario. S\u00f3lo lo mencionamos aqu\u00ed para estar al tanto.)</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/03.-Creando%20una%20Base%20de%20Datos/","title":"03.-Creando una Base de Datos","text":"<p>La primera prueba para ver si puede acceder al servidor de base de datos es tratar de crear una base de datos. Un servidor PostgreSQL en ejecuci\u00f3n puede administrar muchas bases de datos. Normalmente, se utiliza una base de datos separada para cada proyecto o para cada usuario.</p> <p>Posiblemente, el administrador de tu sitio ya ha creado una base de datos para nuestro uso. En ese caso puedes omitir este paso y saltar a la siguiente secci\u00f3n.</p> <p>Para crear una nueva base de datos, en este ejemplo nombrada <code>mydb</code>, se utiliza el siguiente comando:</p> <pre><code>$ createdb mydb\n</code></pre> <p>Si esto no produce respuesta, este paso fue exitoso y se puede saltar el resto de esta secci\u00f3n.</p> <p>Si ves un mensaje similar a:</p> <pre><code>createdb: comando no encontrado\n</code></pre> <p>Entonces PostgreSQL no se instal\u00f3 correctamente. O no se instal\u00f3 en absoluto o la ruta de b\u00fasqueda de su shell no estaba configurada para incluirlo. Llamaremos al comando con un camino absoluto en su lugar:</p> <pre><code>$/usr/local/pgsql/bin/createdb mydb\n</code></pre> <p>El camino en nuestro sitio podr\u00eda ser diferente (<code>/usr/bin/createdb mydb</code> en archlinux). El administrador del sitio o las instrucciones de instalaci\u00f3n puede ayudarnos a corregir la situaci\u00f3n.</p> <p>Otra respuesta podr\u00eda ser esta:</p> <pre><code>createdb: error: connection to server on socket \"/tmp/.s.PGSQL.5432\" failed: No such file or directory\n        Is the server running locally and accepting connections on that socket?\n</code></pre> <p>Esto significa que el servidor no se inici\u00f3, o no est\u00e1 escuchando d\u00f3nde <code>createdb</code>espera contactarlo. Una vez m\u00e1s, revise las instrucciones de instalaci\u00f3n o consulte al administrador.</p> <p>Otra respuesta podr\u00eda ser esta:</p> <pre><code>createdb: error: connection to server on socket \"/tmp/.s.PGSQL.5432\" failed: FATAL:  role \"joe\" does not exist\n</code></pre> <p>donde se menciona nuestro propio nombre de inicio de sesi\u00f3n. Esto suceder\u00e1 si el administrador no ha creado una cuenta de usuario de PostgreSQL para nosotros. (Las cuentas de usuario de PostgreSQL son distintas de las cuentas de usuario del sistema operativo.) Si somos el administrador, consultar el cap\u00edtulo 22 para ayudar en la creaci\u00f3n de cuentas. Debemos convertirnos en el usuario del sistema operativo bajo el cual PostgreSQL fue instalado (generalmente <code>postgres</code>) para crear la primera cuenta de usuario. Tambi\u00e9n podr\u00eda ser que se nos asign\u00f3 un nombre de usuario de PostgreSQL que es diferente de nuestro nombre de usuario de nuestro sistema operativo; en ese caso necesitamos utilizar la opci\u00f3n <code>-U</code> o configurar la variable de entorno <code>PGUSER</code> para especificar nuestro nombre de usuario de PostgreSQL.</p> <p>Si tenemos una cuenta de usuario pero no tiene los privilegios necesarios para crear una base de datos, veremos lo siguiente:</p> <pre><code>createdb: error: database creation failed: ERROR:  permission denied to create database\n</code></pre> <p>No todos los usuarios tienen autorizaci\u00f3n para crear nuevas bases de datos. Si PostgreSQL se niega a crear bases de datos para nosotros, entonces el administrador del sitio necesita concedenos permiso para crear bases de datos. Consultaremos a nuestro administrador del sitio si esto ocurre. Si hemos instalado PostgreSQL nosotros mismos, entonces debemos iniciar sesi\u00f3n bajo la cuenta de usuario con la que iniciamos el servidor. </p> <p>Tambi\u00e9n podemos crear bases de datos con otros nombres. PostgreSQL nos permite crear cualquier n\u00famero de bases de datos en un sitio determinado. Los nombres de la base de datos deben tener un primer car\u00e1cter alfab\u00e9tico y se limitan a 63 bytes de longitud. Una opci\u00f3n conveniente es crear una base de datos con el mismo nombre que nuestro nombre de usuario actual. Muchas herramientas asumen ese nombre de base de datos como predeterminado, por lo que puede ahorrarnos algo de escritura. Para crear esa base de datos, simplemente escribiremos:</p> <pre><code>$ createdb\n</code></pre> <p>Si ya no queremos usar tu base de datos, podemos eliminarla. Por ejemplo, si somos el propietario (creador) de la base de datos <code>mydb</code>, podemos destruirla usando el siguiente comando:</p> <pre><code>$ dropdb mydb\n</code></pre> <p>(Para este comando, el nombre de la base de datos no predetermina el nombre de la cuenta de usuario. Siempre tienes que especificarlo.) Esta acci\u00f3n elimina f\u00edsicamente todos los archivos asociados con la base de datos y no se puede deshacer, por lo que debe hacerse con mucho cuidado.</p> <p>M\u00e1s sobre <code>createdb</code>y <code>dropdb</code>se puede encontrar en createdb y dropdb respectivamente.</p> <p>Nota aclaratoria: Los nombres de usuario est\u00e1n separados de las cuentas de usuario del sistema operativo. Cuando nos conectamos a una base de datos, se puede elegir con qu\u00e9 nombre de usuario de PostgreSQL nos conectamos; si no lo hacemos, se predeterminar\u00e1 al mismo nombre de nuestra cuenta actual del sistema operativo. Sucede que siempre habr\u00e1 una cuenta de usuario de PostgreSQL que tenga el mismo nombre que el usuario del sistema operativo que inici\u00f3 el servidor, y tambi\u00e9n sucede que ese usuario siempre tiene permiso para crear bases de datos. En lugar de iniciar sesi\u00f3n como ese usuario tambi\u00e9n se puede especificar opci\u00f3n <code>-U</code>opci\u00f3n en todas partes para seleccionar un nombre de usuario de PostgreSQL con el que conectarse.</p>"},{"location":"01.-Tutorial/01.-C%C3%B3mo%20empezar/04.-Accediendo%20a%20una%20base%20de%20datos/","title":"04.-Accediendo a una base de datos","text":"<p>Una vez que se haya creado una base de datos, podemos acceder a ella...:</p> <ul> <li> <p>Ejecutando el programa de terminal interactivo PostgreSQL, llamado <code>psql</code>, que nos permite entrar, editar y ejecutar interactivamente comandos SQL.</p> </li> <li> <p>Usando una herramienta web existente como <code>pgAdmin</code> o una suite de oficina con soporte para <code>ODBC</code> o <code>JDBC</code>  para crear y manipular una base de datos. Estas posibilidades no las cubriremos por ahora.</p> </li> <li> <p>Escribiendo una aplicaci\u00f3n personalizada, utilizando una de las varias conexiones con diferentes lenguajes disponibles como pgSQL, Python, Tcl y Perl. Estas posibilidades se examinar\u00e1n m\u00e1s adelante.</p> </li> </ul> <p>Vamos a empezar con <code>psql</code> para probar los ejemplos. Se puede activar para la base de datos <code>mydb</code> escribiendo el comando:</p> <pre><code>$ psql mydb\n</code></pre> <p>Si no suministramos el nombre de la base de datos, se presupone el nombre de la cuenta de usuario. Ya descubrimos este esquema en la secci\u00f3n anterior usando <code>createdb</code>.</p> <p>En <code>psql</code>, nos recibir\u00e1 el siguiente mensaje:</p> <pre><code>psql (16.0)\nEscriba \"ayuda\" para ayuda.\n\nmydb=&gt;\n</code></pre> <p>La \u00faltima l\u00ednea tambi\u00e9n podr\u00eda ser:</p> <pre><code>mydb=#\n</code></pre> <p>Eso significar\u00eda que somos un superusuario de la base de datos, que ser\u00e1 el caso m\u00e1s probable ya que nosotros fuimos los instaladores de la instancia PostgreSQL. Ser superusuario significa no estar sujeto a controles de acceso. Por ahora no es un hecho importante.</p> <p>Si hay problemas de inicio con <code>psql</code> volveremos a la secci\u00f3n anterior. El diagn\u00f3stico de <code>createdb</code>y <code>psql</code>son similares, y si el primero funcionaba, el segundo deber\u00eda funcionar tambi\u00e9n.</p> <p>La \u00faltima l\u00ednea impresa por <code>psql</code>es el prompt, e indica que <code>psql</code> nos est\u00e1 escuchando y que podemos empezar a escribir consultas SQL en un espacio de trabajo mantenido por <code>psql</code>. Prueba estos comandos:</p> <pre><code>mydb=&gt; SELECT version();\n                                         versi\u00f3n\n-------------------------------------------------------------------------------\n PostgreSQL 16.0 on x86o64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\n(1 fila) \n\nmydb=&gt; SELECT current_date;\n current_date\n--------------\n 2023-10-19\n(1 row)\n\n\nmydb=&gt; SELECT 2 + 2;\n ?column?\n----------\n        4\n(1 row)\n</code></pre> <p>El programa  <code>psql</code> tiene una serie de comandos internos que no son comandos SQL. Comienzan con el car\u00e1cter, <code>\\</code>. Por ejemplo, podemos obtener ayuda en la sintaxis de varios comandos PostgreSQL SQL escribiendo:</p> <pre><code>mydb=&gt; \\h\n</code></pre> <p>Para salir de <code>psql</code>, escribiremos:</p> <pre><code>mydb=&gt; \\q\n</code></pre> <p>y <code>psql</code> nos devolver\u00e1 a nuestra l\u00ednea de comandos habitual. (Para m\u00e1s comandos internos, escribir <code>\\?</code>en el prompt <code>psql</code>). Todas la capacidades de <code>psql</code>est\u00e1n documentadas . No usaremos estas caracter\u00edsticas expl\u00edcitamente, pero podemos usarlas cuando sea preciso.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>Este cap\u00edtulo ofrece una visi\u00f3n general de c\u00f3mo utilizar SQL para realizar operaciones sencillas. Solo se tiene la intenci\u00f3n de dar una introducci\u00f3n y no es de ninguna manera un tutorial completo sobre SQL. Se han escrito numerosos libros sobre SQL, incluyendo [melt93] y [DATE97].  Debemos ser conscientes de que algunas caracter\u00edsticas del lenguaje PostgreSQL son extensiones del est\u00e1ndar.</p> <p>En los ejemplos que siguen, asumimos que se ha creado una base de datos nombrada <code>mydb</code> y se ha podido iniciar <code>psql</code>.</p> <p>Los ejemplos de este manual tambi\u00e9n se pueden encontrar en la distribuci\u00f3n de la fuente PostgreSQL en el directorio <code>src/tutorial/</code>. (Las distribuciones en binario de PostgreSQL podr\u00edan no proporcionar esos archivos). Para usar esos archivos, primero cambiaremos a ese directorio y ejecutaremos <code>make</code>:</p> <pre><code>$ cd .../src/tutorial\n$ make\n</code></pre> <p>Esto crea los scripts y compila los archivos C que contienen funciones y tipos definidos por el usuario. Luego, para iniciar el tutorial, haga lo siguiente:</p> <pre><code>$ psql -s mydb\n\n...\n\nmydb=&gt; \\i basics.sql\n</code></pre> <p>El comando <code>\\i</code> lee entre los comandos del archivo especificado.  La opci\u00f3n <code>-s</code> de <code>psql</code> nos pondr\u00e1 en el modo single step el cual se detiene antes de enviar cada declaraci\u00f3n al servidor. Los comandos utilizados en esta secci\u00f3n est\u00e1n en el archivo <code>basics.sql</code>.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/02.-Conceptos/","title":"02.-Conceptos","text":"<p>PostgreSQL es un sistema de gesti\u00f3n relacional de bases de datos (RDBMS - Relational Data Base Management System). Eso significa que es un sistema para gestionar los datos almacenados en relaciones. La relaci\u00f3n es esencialmente un t\u00e9rmino matem\u00e1tico para la tabla. La noci\u00f3n de almacenar datos en tablas es tan com\u00fan hoy d\u00eda que puede parecer inherentemente obvio, pero hay una serie de otras formas de organizar bases de datos. Los archivos y directorios en sistemas operativos similares a Unix forman un ejemplo de una base de datos jer\u00e1rquica. Un desarrollo m\u00e1s moderno son las bases de datos orientadas a objetos.</p> <p>Cada tabla es una colecci\u00f3n de filas nombradas. Cada fila de una tabla dada tiene el mismo conjunto de columnas nombradas, y cada columna es de un tipo de datos espec\u00edfico. Mientras que las  columnas tienen un orden fijo en cada fila, es importante recordar que  SQL no garantiza el orden de las filas dentro de la tabla de ninguna manera (aunque se pueden ordenar expl\u00edcitamente para su visualizaci\u00f3n).</p> <p>Las tablas se agrupan en bases de datos, y una colecci\u00f3n de bases de datos gestionadas por una sola instancia de servidor PostgreSQL constituye un cluster de bases de datos.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/","title":"03.-Creando una nueva tabla","text":"<p>Podemos crear una nueva tabla especificando el nombre de la tabla, junto con todos los nombres de la columna y sus tipos:</p> <pre><code>CREATE TABLE weather (\n    city            varchar(80),\n    temp_lo         int,           -- low temperature\n    temp_hi         int,           -- high temperature\n    prcp            real,          -- precipitation\n    date            date\n);\n</code></pre> <p>Podemos entrar esto en  <code>psql</code> con los avances de l\u00ednea.  <code>psql</code> reconocer\u00e1 que el comando no se termina hasta el punto y coma.</p> <p>Los espacios blanco (es decir, espacios, tabuladores y avances de l\u00ednea) se pueden utilizar libremente en comandos SQL. Eso significa que podemos escribir el comando alineado de manera diferente, o incluso todo en una l\u00ednea. Los dos guiones <code>--</code> permiten presentar comentarios. Lo que les sigue es ignorado hasta el final de la l\u00ednea. SQL es insensible a las may\u00fasculas y min\u00fasculas y tambi\u00e9n sus identificadores, excepto cuando los identificadores se enmarcan con dobles comillas para preservar las may\u00fasculas/min\u00fasculas (no se hace arriba).</p> <p><code>varchar(80)</code>especifica un tipo de datos que puede almacenar cadenas de caracteres arbitrarias de hasta 80 caracteres de longitud.  </p> <p><code>int</code> es el tipo entero normal.  </p> <p><code>real</code> es un tipo para almacenar n\u00fameros de punto flotante de una sola precisi\u00f3n. </p> <p><code>date</code> debe ser autoexplicativo. (S\u00ed, la columna de tipo  <code>date</code> tambi\u00e9n se nombra <code>date</code>. Esto puede ser conveniente o confuso.)</p> <p>PostgreSQL soporta el est\u00e1ndar de tipos SQL <code>int</code>, <code>smallint</code>, <code>real</code>, <code>double precision</code>, <code>char(N)</code>, <code>varchar(N)</code>, <code>date</code>, <code>time</code>, <code>timestamp</code> y <code>interval</code>, as\u00ed como otros tipos de utilidad general y un rico conjunto de tipos geom\u00e9tricos. PostgreSQL se puede personalizar con un n\u00famero arbitrario de tipos de datos definidos por el usuario. Por lo tanto, los nombres de tipo no son  palabras clave en la sintaxis, excepto cuando sea necesario para apoyar casos especiales en el SQL est\u00e1ndar.</p> <p>El segundo ejemplo almacenar\u00e1 las ciudades y su ubicaci\u00f3n geogr\u00e1fica asociada:</p> <pre><code>CREATE TABLE cities (\n    name            varchar(80),\n    location        point\n);\n</code></pre> <p>El tipo <code>point</code> es un ejemplo de un tipo de datos PostgreSQL espec\u00edfico.</p> <p>Por \u00faltimo, debe mencionarse que si no se necesita una tabla por m\u00e1s tiempo o se desea recrearla de manera diferente se puede eliminar usando el  siguiente comando:</p> <pre><code>DROP TABLE tablename;\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#ejercicios","title":"Ejercicios","text":"<p>1.- Crear una tabla llamada <code>employees</code> con columnas para <code>id</code>, <code>first_name</code>,  <code>last_name</code>, <code>email</code> y <code>hire_date</code>. Usar los tipos de datos apropiados para cada columna.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#solucion","title":"Soluci\u00f3n","text":"<pre><code>CREATE TABLE employees (\n  id INTEGER, \n  firs_name VARCHAR(50),\n  last_name VARCHAR(50), \n  email VARCHAR(100),\n  hire_date DATE\n);\n</code></pre> <p>2.- Crea una tabla llamada <code>products</code> con las siguientes columnas:</p> <ul> <li><code>product_id</code> de tipo entero para almacenar un identificador \u00fanico para cada producto.</li> <li><code>name</code> de tipo texto para almacenar el nombre del producto.</li> <li><code>price</code> de tipo num\u00e9rico con precisi\u00f3n 10 y escala 2 para almacenar el precio del producto con 2 d\u00edgitos decimales.</li> <li><code>stock</code> de tipo entero para almacenar la cantidad en stock de ese producto.</li> <li><code>arrival_date</code> de tipo fecha para almacenar la fecha en que ese producto ingres\u00f3 al inventario.</li> </ul> <p>Utiliza los tipos de datos adecuados para cada columna.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/03.-Creando%20una%20nueva%20tabla/#solucion_1","title":"Soluci\u00f3n","text":"<pre><code>CREATE TABLE products (\n  product_id INTEGER,      -- product unique indentificator\n  name VARCHAR(100),\n  price DECIMAL(10,2),     -- price in 10 digits and 2 decimals\n  stock INTEGER,\n  arrival_date DATE        -- arrival product date\n);\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/04.-Cargando%20una%20tabla%20con%20filas/","title":"04.-Cargando una tabla con filas","text":"<p>La sentencia <code>INSERT</code> se utiliza para cargar una tabla con filas:</p> <pre><code>INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');\n</code></pre> <p>Todos los tipos de datos utilizan formatos de  entrada bastante obvios. Las constantes que no son simples valores num\u00e9ricos generalmente deben estar rodeados de comillas individuales (<code>'</code>), como en el ejemplo. El tipo <code>date</code> es realmente bastante flexible en lo que acepta, pero para este  tutorial nos acogeremos al formato inequ\u00edvoco que se muestra aqu\u00ed.</p> <p>El tipo <code>point</code> requiere un par de coordenadas como entrada, como se muestra aqu\u00ed:</p> <pre><code>INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');\n</code></pre> <p>La sintaxis utilizada hasta ahora requiere recordar el orden de las columnas. Una sintaxis alternativa permite enumerar las columnas  expl\u00edcitamente:</p> <pre><code>INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');\n</code></pre> <p>Puedes listar las columnas en un orden diferente si deseas o  incluso omite algunas columnas, por ejemplo, si se desconoce la  precipitaci\u00f3n:</p> <pre><code>INSERT INTO tiempo (date, city, temp_hi, temp_lo)\n    VALUES ('1994-11-29', 'Hayward', 54, 37);\n</code></pre> <p>Muchos desarrolladores consideran que enumerar expl\u00edcitamente las columnas es m\u00e1s estiloso que confiar en el orden impl\u00edcitamente.</p> <p>Introduzcamos todos los comandos mostrados  anteriormente para que tener algunos datos con los que trabajar en las secciones siguientes.</p> <p>Tambi\u00e9n se puede usar <code>COPY</code> para cargar grandes cantidades de datos de archivos de texto plano. Esto suele ser m\u00e1s r\u00e1pido porque el comando  <code>COPY</code> est\u00e1 optimizado para esta aplicaci\u00f3n, aunque permitiendo menos flexibilidad que <code>INSERT</code>. Un ejemplo ser\u00eda:</p> <pre><code>COPY weather FROM '/home/user/weather.txt';\n</code></pre> <p>donde el nombre del archivo para el archivo fuente debe estar  disponible en la m\u00e1quina que ejecuta el proceso de backend, no en el  cliente, ya que el proceso de backend lee el archivo directamente.  Puedes leer m\u00e1s sobre el  comando <code>COPY</code> en COPY.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/04.-Cargando%20una%20tabla%20con%20filas/#ejercicios","title":"Ejercicios","text":"<ol> <li>Inserta 5 registros de prueba en la tabla <code>employees</code> con diferentes valores para cada columna.</li> </ol> <pre><code>INSERT INTO employees (id, first_name, last_name, email, hire_date)\nVALUES (1, 'Juan', 'Perez', 'jperez@mail.com', '2022-01-05'),\n       (2, 'Maria', 'Garcia', 'mgarcia@mail.com', '2021-05-15'),\n       (3, 'Pedro', 'Gomez', 'pgomez@mail.com', '2020-08-22'),\n       (4, 'Luisa', 'Fernandez', 'lufe@mail.com', '2023-02-01'),\n       (5, 'Pablo', 'Morales', 'pmorales@mail.com', '2019-12-15');\n</code></pre> <ol> <li>Inserta 10 registros de prueba en la tabla <code>products</code> con precios entre 5 y 100 y stock entre 10 y 50 unidades a partir de un fichero de texto.</li> </ol>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/05.-Consulta%20de%20tablas/","title":"05.-Consulta de tablas","text":"<p>Para recuperar datos de una tabla, se consulta; para locual utilizamos la declaraci\u00f3n SQL <code>SELECT</code>. La declaraci\u00f3n se divide en una lista de selecci\u00f3n (la parte que enumera las columnas a devolver), una lista de tablas (la parte que enumera las tablas a partir de las cuales recuperar los datos), y una calificaci\u00f3n opcional (la parte que especifica cualquier restricci\u00f3n). Por ejemplo, para recuperar todas las filas de la tabla <code>weather</code>, escribimos:</p> <pre><code>SELECT * FROM weather;\n</code></pre> <p>Aqu\u00ed  <code>*</code> es una abreviatura para todas las columnas. <sup>1</sup> As\u00ed que el mismo resultado ser\u00eda tenido con: </p> <pre><code>SELECT city, temp_lo, temp_hi, prcp, date FROM weather;\n</code></pre> <p>La salida debe ser:</p> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      43 |      57 |    0 | 1994-11-29\n Hayward       |      37 |      54 |      | 1994-11-29\n(3 rows)\n</code></pre> <p>Puedes escribir expresiones, no solo referencias de columna simples, en la lista de selecci\u00f3n. Por ejemplo, puede hacer:</p> <pre><code>SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;\n</code></pre> <p>Esto deber\u00eda dar:</p> <pre><code>     city      | temp_avg |    date\n---------------+----------+------------\n San Francisco |       48 | 1994-11-27\n San Francisco |       50 | 1994-11-29\n Hayward       |       45 | 1994-11-29\n(3 rows)\n</code></pre> <p>Observe c\u00f3mo el  <code>AS</code>cl\u00e1usula se utiliza para reetiquete la columna de salida. (El  <code>AS</code>la cl\u00e1usula es opcional.)</p> <p>Una consulta puede ser calificada.  <code>WHERE</code>cl\u00e1usula que especifica qu\u00e9 filas se quieren. El  <code>WHERE</code>cl\u00e1usula contiene una expresi\u00f3n booleana (valor de la verdad), y s\u00f3lo se  devuelven filas para las que la expresi\u00f3n booleana es verdadera. Los  habituales operadores booleanos (<code>AND</code>, <code>OR</code>, y <code>NOT</code>) est\u00e1n permitidos en la calificaci\u00f3n. Por ejemplo, los siguientes recuperan el clima de San Francisco en d\u00edas lluviosos:</p> <pre><code>SELECT * FROM weather\n    WHERE city = 'San Francisco' AND prcp &gt; 0.0;\n</code></pre> <p>Resultado:</p> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n(1 row)\n</code></pre> <p>Puede solicitar que los resultados de una consulta sean devueltos en orden ordenado:</p> <pre><code>SELECT * FROM weather\n    ORDER BY city;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n Hayward       |      37 |      54 |      | 1994-11-29\n San Francisco |      43 |      57 |    0 | 1994-11-29\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n</code></pre> <p>En este ejemplo, el orden de tipo no est\u00e1 completamente  especificado, y por lo que podr\u00eda obtener las filas de San Francisco en  cualquier orden. Pero siempre obtendr\u00edas los resultados mostrados arriba si lo haces:</p> <pre><code>SELECT * FROM weather\n    ORDER BY city, temp_lo;\n</code></pre> <p>Puede solicitar que se eliminen las filas duplicadas del resultado de una consulta:</p> <pre><code>SELECT DISTINCT city\n    FROM weather;\n</code></pre> <pre><code>     city\n---------------\n Hayward\n San Francisco\n(2 rows)\n</code></pre> <p>Una vez m\u00e1s, el pedido de la fila de resultados podr\u00eda variar. Usted puede asegurar resultados consistentes mediante el uso de  <code>DISTINCT</code>y  <code>ORDER BY</code>en conjunto: <sup>2</sup></p> <pre><code>SELECT DISTINCT city\n    FROM weather\n    ORDER BY city;\n</code></pre> <ol> <li> <p>Mientras  <code>SELECT *</code>es \u00fatil para las consultas fuera de las esposas, se considera ampliamente  mal estilo en el c\u00f3digo de producci\u00f3n, ya que a\u00f1adir una columna a la  tabla cambiar\u00eda los resultados.\u00a0\u21a9</p> </li> <li> <p>En algunos sistemas de bases de datos, incluidas versiones anteriores de PostgreSQL, la implementaci\u00f3n de  <code>DISTINCT</code> autom\u00e1ticamente ordena las filas con lo que  <code>ORDER BY</code> es innecesario. Pero esto no es requerido por el est\u00e1ndar SQL, y el PostgreSQL actual no garantiza que  <code>DISTINCT</code> haga que las filas aparezcan ordenadas.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/06.-Uniones%20de%20tablas/","title":"06.-Uniones de tablas","text":"<p>Hasta ahora, nuestras consultas s\u00f3lo han accedido a una mesa a la  vez. Las consultas pueden acceder a varias mesas a la vez, o acceder a  la misma tabla de tal manera que se est\u00e1n procesando varias filas de la  tabla al mismo tiempo. Las consultas que acceden a m\u00faltiples tablas (o  m\u00faltiples instancias de la misma mesa) en un momento se llaman a consultas de unirse. Combinan filas de una tabla con filas de una segunda tabla, con una  expresi\u00f3n que especifica qu\u00e9 filas deben ser emparejados. Por ejemplo,  para devolver todos los registros meteorol\u00f3gicos junto con la ubicaci\u00f3n  de la ciudad asociada, la base de datos necesita comparar la  <code>city</code>columna de cada hilera de la  <code>weather</code>mesa con el  <code>name</code>columna de todas las filas en el  <code>cities</code>mesa y seleccione los pares de filas donde coinciden estos valores.<sup>1</sup> Esto se lograr\u00eda con la siguiente consulta:</p> <pre><code>SELECT * FROM weather JOIN cities ON city = name;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(2 rows)\n</code></pre> <p>Observe dos cosas sobre el conjunto de resultados:</p> <ul> <li> <p>No hay ninguna fila de resultados para la ciudad de Hayward. Esto se debe a que no hay ninguna entrada a juego en el  <code>cities</code>mesa para Hayward, as\u00ed que la uni\u00f3n ignora las filas inigualables en el  <code>weather</code>mesa. En breve veremos c\u00f3mo se arregla esto.</p> </li> <li> <p>Hay dos columnas que contienen el nombre de la ciudad. Esto es correcto porque las listas de columnas de la  <code>weather</code>y  <code>cities</code>las mesas est\u00e1n concatenadas. En la pr\u00e1ctica esto es indeseable, sin  embargo, por lo que probablemente querr\u00e1 enumerar las columnas de salida expl\u00edcitamente en lugar de usar <code>*</code>:</p> </li> </ul> <p><code>postgresql   SELECT city, temp_lo, temp_hi, prcp, date, location       FROM weather JOIN cities ON city = name;</code></p> <p>Dado que todas las columnas ten\u00edan diferentes nombres, el  analizador encontr\u00f3 autom\u00e1ticamente a qu\u00e9 tabla pertenec\u00edan. Si hubiera  nombres de columnas duplicados en las dos tablas tendr\u00edas que calificar los nombres de las columnas para mostrar cu\u00e1l se refer\u00eda, como en:</p> <pre><code>SELECT weather.city, weather.temp_lo, weather.temp_hi,\n       weather.prcp, weather.date, cities.location\n    FROM weather JOIN cities ON weather.city = cities.name;\n</code></pre> <p>Es ampliamente considerado buen estilo para calificar todos los  nombres de columna en una consulta de uni\u00f3n, de modo que la consulta no  fallar\u00e1 si un nombre de columna duplicado se a\u00f1ade m\u00e1s tarde a una de  las tablas.</p> <p>Suscr\u00edmense a las preguntas del tipo visto hasta ahora tambi\u00e9n se pueden escribir en esta forma:</p> <pre><code>SELECT *\n    FROM weather, cities\n    WHERE city = name;\n</code></pre> <p>Esta sintaxis es anterior a la <code>JOIN</code>/ <code>ON</code>sintaxis, que se introdujo en SQL-92. Las tablas se enumeran simplemente en la  <code>FROM</code>cl\u00e1usula, y la expresi\u00f3n de comparaci\u00f3n se a\u00f1ade a la  <code>WHERE</code>cl\u00e1usula. Los resultados de esta sintaxis impl\u00edcita m\u00e1s antigua y de lo m\u00e1s reciente expl\u00edcito <code>JOIN</code>/ <code>ON</code>Sintaxis son id\u00e9nticas. Pero para un lector de la consulta, la sintaxis  expl\u00edcita hace su significado m\u00e1s f\u00e1cil de entender: La condici\u00f3n de  uni\u00f3n se introduce por su propia palabra clave, mientras que  anteriormente la condici\u00f3n se mezclaba en el  <code>WHERE</code>cl\u00e1usula junto con otras condiciones.</p> <p>Ahora averiguaremos c\u00f3mo podemos conseguir los discos de Hayward. Lo que queremos que haga la consulta es es escanear el  <code>weather</code>mesa y para cada fila para encontrar la coincidencia  <code>cities</code>filas (s). Si no se encuentra ninguna fila a juego queremos que algunos valores vac\u00edos sean sustituidos por el  <code>cities</code>las columnas de la mesa. Este tipo de consulta se llama uni\u00f3n externa. (Las uniones que hemos visto hasta ahora son uniciones internas.) El comando se ve as\u00ed:</p> <pre><code>SELECT *\n    FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n Hayward       |      37 |      54 |      | 1994-11-29 |               |\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(3 rows)\n</code></pre> <p>Esta consulta se llama uni\u00f3n externa izquierda porque la tabla mencionada a la izquierda del operador de uni\u00f3n tendr\u00e1  cada una de sus filas en la salida al menos una vez, mientras que la  tabla en la derecha s\u00f3lo tendr\u00e1 esa salida de filas que coincen con  alguna fila de la tabla izquierda. Al salir de una fila de mesa  izquierda para la que no hay coincidencia de la mesa derecha, los  valores vac\u00edos (null) se sustituyen por las columnas de la mesa derecha.</p> <p>Ejercicio: Tambi\u00e9n hay uniones exteriores derechas y \u00fanete exterior completo. Intenta averiguar qu\u00e9 hacen.</p> <p>Tambi\u00e9n podemos unirnos a una mesa contra s\u00ed misma. Esto se llama unirse a s\u00ed mismo. Como ejemplo, supongamos que deseamos encontrar todos los registros  meteorol\u00f3gicos que est\u00e1n en el rango de temperatura de otros registros  meteorol\u00f3gicos. As\u00ed que tenemos que comparar el  <code>temp_lo</code>y  <code>temp_hi</code>columnas de cada uno  <code>weather</code>fila a la  <code>temp_lo</code>y  <code>temp_hi</code>columnas de todos los dem\u00e1s  <code>weather</code>filas. Podemos hacerlo con la siguiente consulta:</p> <pre><code>SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,\n       w2.city, w2.temp_lo AS low, w2.temp_hi AS high\n    FROM weather w1 JOIN weather w2\n        ON w1.temp_lo &lt; w2.temp_lo AND w1.temp_hi &gt; w2.temp_hi;\n</code></pre> <pre><code>     city      | low | high |     city      | low | high\n---------------+-----+------+---------------+-----+------\n San Francisco |  43 |   57 | San Francisco |  46 |   50\n Hayward       |  37 |   54 | San Francisco |  46 |   50\n(2 rows)\n</code></pre> <p>Aqu\u00ed hemos reetiquetado la tabla de la meteorolog\u00eda como  <code>w1</code>y  <code>w2</code>para poder distinguir el lado izquierdo y derecho de la uni\u00f3n. Tambi\u00e9n puede utilizar este tipo de alias en otras consultas para ahorrar algunos  mees, por ejemplo:</p> <pre><code>SELECT *\n    FROM weather w JOIN cities c ON w.city = c.name;\n</code></pre> <p>Usted encontrar\u00e1 este estilo de abreviatura con bastante frecuencia.</p> <ol> <li> <p>Esto es s\u00f3lo un modelo conceptual. La uni\u00f3n se realiza normalmente de una manera m\u00e1s eficiente que la comparaci\u00f3n real de cada par posible de filas, pero esto es invisible para el usuario.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/07.-Funciones%20agregadas/","title":"07.-Funciones agregadas","text":"<p>Como la mayor\u00eda de los otros productos de base de datos relacionales, PostgreSQL admite funciones agregadas. Una funci\u00f3n agregada calcula un solo resultado de m\u00faltiples filas de entrada. Por ejemplo, hay agregados para calcular la <code>count</code>, <code>sum</code>,  <code>avg</code>(promedio),  <code>max</code>(m\u00e1ximo) y  <code>min</code>(m\u00ednimo) sobre un conjunto de filas.</p> <p>Como ejemplo, podemos encontrar la lectura m\u00e1s alta a bajo temperatura en cualquier lugar con:</p> <pre><code>SELECT max(temp_lo) FROM weather;\n</code></pre> <pre><code> max\n-----\n  46\n(1 row)\n</code></pre> <p>Si quer\u00edamos saber en qu\u00e9 ciudad (o ciudades) se produjo esa lectura, podr\u00edamos intentar:</p> <pre><code>SELECT city FROM weather WHERE temp_lo = max(temp_lo);     Err\u00f3neo\n</code></pre> <p>pero esto no funcionar\u00e1 desde el agregado  <code>max</code>no se puede utilizar en el  <code>WHERE</code>cl\u00e1usula. (Esta restricci\u00f3n existe porque el  <code>WHERE</code>la cl\u00e1usula determina qu\u00e9 filas se incluir\u00e1n en el c\u00e1lculo agregado; por  lo que obviamente debe ser evaluada antes de que se computen las  funciones agregadas.) Sin embargo, como suele ocurrir, la consulta se  puede reafirmar para lograr el resultado deseado, aqu\u00ed mediante una subcoquer\u00eda:</p> <pre><code>SELECT city FROM weather\n    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);\n</code></pre> <pre><code>     city\n---------------\n San Francisco\n(1 row)\n</code></pre> <p>Esto est\u00e1 bien porque la subcoquer\u00eda es un c\u00e1lculo independiente  que calcula su propio agregado por separado de lo que est\u00e1 sucediendo en la consulta exterior.</p> <p>Los agregados tambi\u00e9n son muy \u00fatiles en combinaci\u00f3n con  <code>GROUP BY</code>cl\u00e1usulas. Por ejemplo, podemos obtener el n\u00famero de lecturas y la temperatura m\u00e1xima baja observada en cada ciudad con:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n Hayward       |     1 |  37\n San Francisco |     2 |  46\n(2 rows)\n</code></pre> <p>lo que nos da una fila de salida por ciudad. Cada resultado  agregado se calcula sobre las filas de la mesa que coinciden con esa  ciudad. Podemos filtrar estas filas agrupadas usando <code>HAVING</code>:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    GROUP BY city\n    HAVING max(temp_lo) &lt; 40;\n</code></pre> <pre><code>  city   | count | max\n---------+-------+-----\n Hayward |     1 |  37\n(1 row)\n</code></pre> <p>que nos da los mismos resultados s\u00f3lo para las ciudades que tienen todas  <code>temp_lo</code>valores inferiores a 40. Por \u00faltimo, si s\u00f3lo nos importan las ciudades cuyos nombres comienzan con<code>S</code>- Podr\u00edamos hacerlo:</p> <pre><code>SELECT city, count(*), max(temp_lo)\n    FROM weather\n    WHERE city LIKE 'S%'            -- (1)\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n San Francisco |     2 |  46\n(1 row)\n</code></pre> <p>El operador <code>LIKE</code> trabaja con patrones y se explicar\u00e1 m\u00e1s adelante.</p> <p>Es importante comprender la interacci\u00f3n entre agregados y SQLde  <code>WHERE</code>y  <code>HAVING</code>cl\u00e1usulas. La diferencia fundamental entre  <code>WHERE</code>y  <code>HAVING</code>Esto es:  <code>WHERE</code>selecciona filas de entrada antes de que se computen los grupos y agregados (por  lo tanto, controla qu\u00e9 filas van en el c\u00f3mputo agregado), mientras que  <code>HAVING</code>selecciona filas de grupo despu\u00e9s de grupos y agregados se calculan. As\u00ed, el  <code>WHERE</code>la cl\u00e1usula no debe contener funciones agregadas; no tiene sentido tratar  de utilizar un agregado para determinar qu\u00e9 filas ser\u00e1n entradas a los  agregados. Por otro lado, el  <code>HAVING</code>cl\u00e1usula siempre contiene funciones agregadas. (Estrictamente hablando, se te permite escribir un  <code>HAVING</code>cl\u00e1usula que no usa agregados, pero rara vez es \u00fatil. La misma condici\u00f3n podr\u00eda ser utilizada de manera m\u00e1s eficiente en el  <code>WHERE</code>etapa.)</p> <p>En el ejemplo anterior, podemos aplicar la restricci\u00f3n del nombre de la ciudad en <code>WHERE</code>, ya que no necesita ning\u00fan agregado. Esto es m\u00e1s eficiente que a\u00f1adir la restricci\u00f3n a <code>HAVING</code>, porque evitamos hacer la agrupaci\u00f3n y los c\u00e1lculos agregados para todas las filas que fallan el  <code>WHERE</code>compruebas.</p> <p>Otra forma de seleccionar las filas que entran en un c\u00f3mputo agregado es usar <code>FILTER</code>, que es una opci\u00f3n por agregado:</p> <pre><code>SELECT city, count(*) FILTER (WHERE temp_lo &lt; 45), max(temp_lo)\n    FROM weather\n    GROUP BY city;\n</code></pre> <pre><code>     city      | count | max\n---------------+-------+-----\n Hayward       |     1 |  37\n San Francisco |     1 |  46\n(2 rows)\n</code></pre> <p><code>FILTER</code>es como <code>WHERE</code>, excepto que elimina las filas s\u00f3lo de la entrada de la funci\u00f3n agregada particular a la que se une. Aqu\u00ed, el  <code>count</code>agregados s\u00f3lo cuenta filas con  <code>temp_lo</code>debajo de 45; pero el  <code>max</code>agregados se sigue aplicando a todas las filas, por lo que todav\u00eda encuentra la lectura de 46.</p>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/08.-Actualizaciones/","title":"08.-Actualizaciones","text":"<p>Puede actualizar las filas existentes utilizando el  <code>UPDATE</code>comando. Supongamos que descubres que las lecturas de temperatura est\u00e1n todas  desactivadas en 2 grados despu\u00e9s del 28 de noviembre. Puede corregir los datos de la siguiente manera:</p> <pre><code>UPDATE weather\n    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n    WHERE date &gt; '1994-11-28';\n</code></pre> <p>Veamos el nuevo estado de los datos:</p> <pre><code>SELECT * FROM weather;\n\n     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n Hayward       |      35 |      52 |      | 1994-11-29\n(3 rows)\n</code></pre>"},{"location":"01.-Tutorial/02.-El%20lenguaje%20SQL/09.-Borrados/","title":"09.-Borrados","text":"<p>Las filas se pueden quitar de una mesa usando el  <code>DELETE</code>comando. Supongamos que ya no est\u00e1 interesado en el clima de Hayward. Entonces  puede hacer lo siguiente para eliminar esas filas de la tabla:</p> <pre><code>DELETE FROM weather WHERE city = 'Hayward';\n</code></pre> <p>Todos los registros meteorol\u00f3gicos pertenecientes a Hayward se retiran.</p> <pre><code>SELECT * FROM weather;\n</code></pre> <pre><code>     city      | temp_lo | temp_hi | prcp |    date\n---------------+---------+---------+------+------------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27\n San Francisco |      41 |      55 |    0 | 1994-11-29\n(2 rows)\n</code></pre> <p>Uno debe ser cauto de las declaraciones de la forma</p> <pre><code>DELETE FROM tablename;\n</code></pre> <p>Sin una cualificaci\u00f3n,  <code>DELETE</code>eliminar\u00e1 todas las filas de la mesa dada, dej\u00e1ndola vac\u00eda. El sistema no solicitar\u00e1 confirmaci\u00f3n antes de hacer esto.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/01.-Introducci%C3%B3n/","title":"01.-Introducci\u00f3n","text":"<p>En el cap\u00edtulo anterior hemos cubierto los fundamentos de la utilizaci\u00f3n  SQLpara almacenar y acceder a sus datos en PostgreSQL. Ahora discutiremos algunas caracter\u00edsticas m\u00e1s avanzadas de  SQLque simplifica la gesti\u00f3n y previene la p\u00e9rdida o corrupci\u00f3n de sus datos. Finalmente, veremos algunas extensiones de PostgreSQL.</p> <p>Este cap\u00edtulo se referir\u00e1 en ocasiones a los ejemplos encontrados en  para cambiarlos o mejorarlos, por lo que ser\u00e1 \u00fatil haber le\u00eddo ese  cap\u00edtulo. Algunos ejemplos de este cap\u00edtulo tambi\u00e9n se pueden encontrar  en  <code>advanced.sql</code>en el directorio de tutoriales. Este archivo tambi\u00e9n contiene algunos  datos de muestra para cargar, lo que no se repite aqu\u00ed. (Para saber la  para usar el expediente.)</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/02.-Vistas/","title":"02.-Vistas","text":"<p>Consulte de nuevo a las consultas de la Secci\u00f3n 2.6. Supongamos que la lista combinada de los registros meteorol\u00f3gicos y la  ubicaci\u00f3n de la ciudad es de particular inter\u00e9s para su aplicaci\u00f3n, pero no quiere escribir la consulta cada vez que lo necesite. Puede crear  una vista sobre la consulta, que da un nombre a la consulta que se puede referir como una tabla ordinaria:</p> <pre><code>CREATE VIEW myview AS\n    SELECT name, temp_lo, temp_hi, prcp, date, location\n        FROM weather, cities\n        WHERE city = name;\n\nSELECT * FROM myview;\n</code></pre> <p>Hacer un uso liberal de las opiniones es un aspecto clave del buen  dise\u00f1o de la base de datos SQL. Las vistas le permiten encapsular los  detalles de la estructura de sus tablas, lo que podr\u00eda cambiar a medida  que su aplicaci\u00f3n evoluciona, detr\u00e1s de interfaces consistentes.</p> <p>Las vistas se pueden utilizar en casi cualquier lugar se puede  utilizar una tabla real. Construir la vista sobre otras vistas no es  raros.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/03.-Claves%20for%C3%A1neas/","title":"03.-Claves for\u00e1neas","text":"<p>Recordemos el  <code>weather</code>y  <code>cities</code>cuadros del cap\u00edtulo 2. Considere el siguiente problema: Usted desea asegurarse de que nadie puede insertar filas en el  <code>weather</code>mesa que no tiene una entrada a juego en el  <code>cities</code>mesa. Esto se llama mantener la integridad referencial de sus datos. En los sistemas de bases de datos simplist\u00e1s esto se implementar\u00eda (si no lo hace) examinando primero la  <code>cities</code>tabla para comprobar si existe un registro de coincidencia, y luego insertar o rechazar el nuevo  <code>weather</code>Registros. Este enfoque tiene una serie de problemas y es muy inconveniente, por lo que PostgreSQL puede hacer esto por usted.</p> <p>La nueva declaraci\u00f3n de las tablas se ver\u00eda as\u00ed:</p> <pre><code>CREATE TABLE cities (\n        name     varchar(80) primary key,\n        location point\n);\n\nCREATE TABLE weather (\n        city      varchar(80) references cities(name),\n        temp_lo   int,\n        temp_hi   int,\n        prcp      real,\n        date      date\n);\n</code></pre> <p>Ahora intenta insertar un registro inv\u00e1lido:</p> <pre><code>INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');\n</code></pre> <pre><code>ERROR:  insert or update on table \"weather\" violates foreign key constraint \"weather_city_fkey\"\nDETAIL:  Key (city)=(Berkeley) is not present in table \"cities\".\n</code></pre> <p>El comportamiento de las teclas extranjeras puede estar finamente  sintonizado con su aplicaci\u00f3n. No iremos m\u00e1s all\u00e1 de este simple ejemplo en este tutorial, sino que nos referimos al  para m\u00e1s informaci\u00f3n. Hacer un uso correcto de las claves extranjeras  definitivamente mejorar\u00e1 la calidad de sus aplicaciones de base de  datos, por lo que se le anima encarecidamente a aprender sobre ellas.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/04.-Transacciones/","title":"04.-Transacciones","text":"<p>Las transacciones son un concepto fundamental de todos los sistemas de bases de datos. El punto esencial de una transacci\u00f3n es que agrupa m\u00faltiples pasos en una  operaci\u00f3n \u00fanica, todo o nada. Los estados intermedios entre los pasos no son visibles para otras transacciones simult\u00e1neas, y si se produce  alg\u00fan fallo que impide que la transacci\u00f3n se complete, entonces ninguno  de los pasos afecta a la base de datos en absoluto.</p> <p>Por ejemplo, considere una base de datos bancaria que contenga  saldos para diversas cuentas de clientes, as\u00ed como saldos totales de  dep\u00f3sitos para sucursales. Supongamos que queremos registrar un pago de  $100.00 de la cuenta de Alice a la cuenta de Bob. Simplificando  escandalosamente, los comandos SQL para esto podr\u00edan parecer:</p> <pre><code>UPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nUPDATE branches SET balance = balance - 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\nUPDATE branches SET balance = balance + 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');\n</code></pre> <p>Los detalles de estos comandos no son importantes aqu\u00ed; el punto  importante es que hay varias actualizaciones separadas involucradas para lograr esta operaci\u00f3n bastante simple. Los oficiales de nuestro banco  querr\u00e1n estar seguros de que o todas estas actualizaciones ocurren, o  ninguna de ellas sucede. Ciertamente no har\u00eda por un fallo del sistema  que result\u00f3 en que Bob recibiera $100.00 que no fue debitado de Alice.  Alice tampoco seguir\u00eda siendo una clienta feliz si fuera cargada sin que Bob fuera acreditado. Necesitamos una garant\u00eda de que si algo sale mal a lo largo de la operaci\u00f3n, ninguno de los pasos ejecutados hasta ahora  entrar\u00e1 en vigor. Agrupar las actualizaciones en una transacci\u00f3n nos da esta garant\u00eda. Se dice que una transacci\u00f3n es at\u00f3mica: desde el punto de vista de otras transacciones, o bien ocurre completamente o no en absoluto.</p> <p>Tambi\u00e9n queremos una garant\u00eda de que una vez que una transacci\u00f3n  sea completada y reconocida por el sistema de bases de datos, de hecho  se haya registrado permanentemente y no se pierda incluso si se produce  un accidente poco despu\u00e9s. Por ejemplo, si estamos grabando un retiro de efectivo por parte de Bob, no queremos ninguna posibilidad de que el  adeudo a su cuenta desaparezca en un accidente justo despu\u00e9s de salir  por la puerta del banco. Una base de datos transaccional garantiza que  todas las actualizaciones realizadas por una transacci\u00f3n se registran en el almacenamiento permanente (es decir, en el disco) antes de que se  informe de la transacci\u00f3n.</p> <p>Otra propiedad importante de las bases de datos transaccionales  est\u00e1 estrechamente relacionada con la noci\u00f3n de actualizaciones  at\u00f3micas: cuando varias transacciones se ejecutan simult\u00e1neamente, cada  una no deber\u00eda ser capaz de ver los cambios incompletos realizados por  otros. Por ejemplo, si una transacci\u00f3n est\u00e1 ocupada por un total de  todos los saldos de la sucursal, no har\u00eda para que incluyera el adeudo  de la sucursal de Alice, pero no el cr\u00e9dito a la sucursal de Bob, ni  viceversa. As\u00ed que las transacciones deben ser todo o nada no s\u00f3lo en  t\u00e9rminos de su efecto permanente en la base de datos, sino tambi\u00e9n en  t\u00e9rminos de su visibilidad a medida que suceden. Las actualizaciones  realizadas hasta ahora por una transacci\u00f3n abierta son invisibles a  otras transacciones hasta que la transacci\u00f3n se complete, con lo cual  todas las actualizaciones se hacen visibles simult\u00e1neamente.</p> <p>En PostgreSQL, una transacci\u00f3n se establece alrededor de los comandos SQL de la transacci\u00f3n con  <code>BEGIN</code>y  <code>COMMIT</code>comandos. As\u00ed que nuestra transacci\u00f3n bancaria en realidad se ver\u00eda como:</p> <pre><code>BEGIN;\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\n-- etc etc\nCOMMIT;\n</code></pre> <p>Si, a lo largo de la transacci\u00f3n, decidimos que no queremos  comprometernos (quiz\u00e1s nos acabamos de notar que el saldo de Alice sali\u00f3 negativo), podemos emitir el comando  <code>ROLLBACK</code>en vez de <code>COMMIT</code>, y todas nuestras actualizaciones hasta ahora ser\u00e1n canceladas.</p> <p>PostgreSQL realmente trata cada declaraci\u00f3n de SQL como si se ejecutara dentro de una transacci\u00f3n. Si no emites un  <code>BEGIN</code>comando, entonces cada declaraci\u00f3n individual tiene un  <code>BEGIN</code>y (si tiene \u00e9xito)  <code>COMMIT</code>Envuelto alrededor de ella. Un grupo de declaraciones rodeados de  <code>BEGIN</code>y  <code>COMMIT</code>A veces se llama bloque de transacciones.</p> <p>Nota Algunas bibliotecas clientes emiten  <code>BEGIN</code>y  <code>COMMIT</code>comandos autom\u00e1ticamente, para que pueda obtener el efecto de los bloques de  transacciones sin preguntar. Coma control la documentaci\u00f3n de la  interfaz que est\u00e1 utilizando.</p> <p>Es posible controlar las declaraciones en una transacci\u00f3n de una manera m\u00e1s granular a trav\u00e9s del uso de puntos de ahorro. Savepoints le permite descartar selectivamente partes de la  transacci\u00f3n, al tiempo que compromete el resto. Despu\u00e9s de definir un  punto de salvaci\u00f3n con <code>SAVEPOINT</code>, puede si es necesario volver al punto de salvado con <code>ROLLBACK TO</code>. Todos los cambios de base de datos de la transacci\u00f3n entre definir el  punto de reserva y volver a ella se descartan, pero los cambios antes  del punto de salvado se mantienen.</p> <p>Despu\u00e9s de volver a un punto de salva, se sigue definiendo, por lo  que puede volver a \u00e9l varias veces. Por el contrario, si usted est\u00e1  seguro de que no tendr\u00e1 que volver a un punto de salvado en particular  de nuevo, se puede liberar, por lo que el sistema puede liberar algunos  recursos. Tenga en cuenta que la liberaci\u00f3n o la vuelta a un punto de  ahorro liberar\u00e1 autom\u00e1ticamente todos los puntos de ahorro que se  definieron despu\u00e9s de \u00e9l.</p> <p>Todo esto est\u00e1 sucediendo dentro del bloque de transacciones, por  lo que nada de esto es visible para otras sesiones de base de datos.  Cuando y si usted comete el bloque de transacciones, las acciones  comprometidas se hacen visibles como una unidad a otras sesiones,  mientras que las acciones de la espalda enrollada nunca se hacen  visibles en absoluto.</p> <p>Recordando la base de datos del banco, supongamos que debitamos  $100.00 de la cuenta de Alice, y la cuenta de acreditar a Bob, s\u00f3lo para encontrar m\u00e1s tarde que deber\u00edamos haber acreditado la cuenta de Wally. Podr\u00edamos hacerlo usando puntos de ahorro como este:</p> <pre><code>BEGIN;\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nSAVEPOINT my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\n-- oops ... forget that and use Wally's account\nROLLBACK TO my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Wally';\nCOMMIT;\n</code></pre> <p>Este ejemplo es, por supuesto, demasiado simplificado, pero hay  mucho control posible en un bloque de transacciones a trav\u00e9s del uso de  puntos de ahorro. Adem\u00e1s,  <code>ROLLBACK TO</code>es la \u00fanica manera de recuperar el control de un bloque de transacciones  que fue puesto en estado abortado por el sistema debido a un error, a  falta de rodarlo completamente y empezar de nuevo.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/05.-Funciones%20de%20ventanas/","title":"05.-Funciones de ventanas","text":"<p>Una funci\u00f3n de ventana realiza un c\u00e1lculo a trav\u00e9s de un conjunto de filas de tablas que de  alguna manera est\u00e1n relacionadas con la fila actual. Esto es comparable  al tipo de c\u00e1lculo que se puede hacer con una funci\u00f3n agregada. Sin  embargo, las funciones de las ventanas no hacen que las filas se agrupen en una sola fila de salida como las llamadas agregadas no de ventana.  En cambio, las filas conservan sus identidades separadas. Detr\u00e1s de las  escenas, la funci\u00f3n de la ventana es capaz de acceder a algo m\u00e1s que la  fila actual del resultado de la consulta.</p> <p>Aqu\u00ed hay un ejemplo que muestra c\u00f3mo comparar el salario de cada empleado con el salario promedio en su departamento:</p> <pre><code>SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;\n</code></pre> <pre><code>  depname  | empno | salary |          avg\n-----------+-------+--------+-----------------------\n develop   |    11 |   5200 | 5020.0000000000000000\n develop   |     7 |   4200 | 5020.0000000000000000\n develop   |     9 |   4500 | 5020.0000000000000000\n develop   |     8 |   6000 | 5020.0000000000000000\n develop   |    10 |   5200 | 5020.0000000000000000\n personnel |     5 |   3500 | 3700.0000000000000000\n personnel |     2 |   3900 | 3700.0000000000000000\n sales     |     3 |   4800 | 4866.6666666666666667\n sales     |     1 |   5000 | 4866.6666666666666667\n sales     |     4 |   4800 | 4866.6666666666666667\n(10 rows)\n</code></pre> <p>Las tres primeras columnas de salida provienen directamente de la tabla <code>empsalary</code>, y hay una fila de salida para cada fila en la tabla. La cuarta columna  representa un promedio tomado en todas las filas de tabla que tienen lo  mismo  <code>depname</code>valor como la fila actual. (En realidad es la misma funci\u00f3n que la no-ventada  <code>avg</code>agregado, pero el  <code>OVER</code>cl\u00e1usula hace que sea tratada como una funci\u00f3n de la ventana y calculada a trav\u00e9s del marco de la ventana.)</p> <p>Una llamada de funci\u00f3n de ventana siempre contiene un  <code>OVER</code>cl\u00e1usula directamente siguiendo el nombre y los argumentos de la funci\u00f3n de la  ventana. Esto es lo que lo distingue sint\u00e1cticamente de una funci\u00f3n  normal o agregado no de ventana. El  <code>OVER</code>la cl\u00e1usula determina exactamente c\u00f3mo se dividen las filas de la consulta para su procesamiento por la funci\u00f3n de la ventana. El  <code>PARTITION BY</code>cl\u00e1usula dentro  <code>OVER</code>divide las filas en grupos, o particiones, que comparten los mismos valores de la  <code>PARTITION BY</code>la expresi\u00f3n (s). Para cada fila, la funci\u00f3n de la ventana se calcula a  trav\u00e9s de las filas que caen en la misma partici\u00f3n que la fila actual.</p> <p>Tambi\u00e9n puede controlar el orden en el que las filas se procesan por funciones de ventana usando  <code>ORDER BY</code>dentro <code>OVER</code>. (La ventana  <code>ORDER BY</code>ni siquiera tiene que coincidir con el orden en el que las filas son de salida.) He aqu\u00ed un ejemplo:</p> <pre><code>SELECT depname, empno, salary,\n       rank() OVER (PARTITION BY depname ORDER BY salary DESC)\nFROM empsalary;\n</code></pre> <pre><code>  depname  | empno | salary | rank\n-----------+-------+--------+------\n develop   |     8 |   6000 |    1\n develop   |    10 |   5200 |    2\n develop   |    11 |   5200 |    2\n develop   |     9 |   4500 |    4\n develop   |     7 |   4200 |    5\n personnel |     2 |   3900 |    1\n personnel |     5 |   3500 |    2\n sales     |     1 |   5000 |    1\n sales     |     4 |   4800 |    2\n sales     |     3 |   4800 |    2\n(10 rows)\n</code></pre> <p>Como se muestra aqu\u00ed, el  <code>rank</code>funci\u00f3n produce un rango num\u00e9rico para cada distinto  <code>ORDER BY</code>valor en la partici\u00f3n de la fila actual, utilizando el orden definido por el  <code>ORDER BY</code>cl\u00e1usula.  <code>rank</code>no necesita un par\u00e1metro expl\u00edcito, porque su comportamiento est\u00e1 totalmente determinado por la  <code>OVER</code>cl\u00e1usula.</p> <p>Las filas consideradas por una funci\u00f3n de ventana son las de la tabla virtual . producida por la consulta's  <code>FROM</code>cl\u00e1usula filtrada por su <code>WHERE</code>, <code>GROUP BY</code>, y  <code>HAVING</code>cl\u00e1usulas, si las hay. Por ejemplo, una fila eliminada porque no cumple con la  <code>WHERE</code>la condici\u00f3n no se ve por ninguna funci\u00f3n de ventana. Una consulta puede  contener m\u00faltiples funciones de ventana que cortan los datos de  diferentes maneras usando diferentes  <code>OVER</code>cl\u00e1usulas, pero todas act\u00faan sobre la misma colecci\u00f3n de filas definidas por esta tabla virtual.</p> <p>Ya vimos eso.  <code>ORDER BY</code>se puede omitir si el orden de las filas no es importante. Tambi\u00e9n es posible omitir <code>PARTITION BY</code>, en cuyo caso hay una sola partici\u00f3n que contiene todas las filas.</p> <p>Hay otro concepto importante asociado a las funciones de la  ventana: para cada fila, hay un conjunto de filas dentro de su partici\u00f3n llamada marco de la ventana. Algunas funciones de ventana act\u00faan s\u00f3lo en las filas del marco de la  ventana, en lugar de toda la partici\u00f3n. Por defecto, si  <code>ORDER BY</code>se suministra entonces el marco consiste en todas las filas desde el  inicio de la partici\u00f3n hasta la fila actual, adem\u00e1s de cualquier fila  siguiente que sean iguales a la fila actual de acuerdo con el  <code>ORDER BY</code>cl\u00e1usula. Cuando  <code>ORDER BY</code>se omite el marco predeterminado consiste en todas las filas en la partici\u00f3n. <sup>1</sup> Aqu\u00ed hay un ejemplo de uso <code>sum</code>:</p> <pre><code>SELECT salary, sum(salary) OVER () FROM empsalary;\n</code></pre> <pre><code> salary |  sum\n--------+-------\n   5200 | 47100\n   5000 | 47100\n   3500 | 47100\n   4800 | 47100\n   3900 | 47100\n   4200 | 47100\n   4500 | 47100\n   4800 | 47100\n   6000 | 47100\n   5200 | 47100\n(10 rows)\n</code></pre> <p>Arriba, ya que no hay  <code>ORDER BY</code>en el  <code>OVER</code>cl\u00e1usula, el marco de la ventana es el mismo que la partici\u00f3n, que por falta de  <code>PARTITION BY</code>es toda la tabla; en otras palabras, cada suma se toma sobre toda la tabla y por lo tanto obtenemos el mismo resultado para cada fila de salida.  Pero si a\u00f1adimos un  <code>ORDER BY</code>cl\u00e1usula, obtenemos resultados muy diferentes:</p> <pre><code>SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;\n</code></pre> <pre><code> salary |  sum\n--------+-------\n   3500 |  3500\n   3900 |  7400\n   4200 | 11600\n   4500 | 16100\n   4800 | 25700\n   4800 | 25700\n   5000 | 30700\n   5200 | 41100\n   5200 | 41100\n   6000 | 47100\n(10 rows)\n</code></pre> <p>Aqu\u00ed la suma se toma del primer (menor) sueldo hasta el actual,  incluyendo cualquier duplicado de la actual (adunice los resultados para los salarios duplicados).</p> <p>Las funciones de la ventana s\u00f3lo se permiten en la  <code>SELECT</code>lista y la  <code>ORDER BY</code>cl\u00e1usula de la consulta. Est\u00e1n prohibidos en otros lugares, como en <code>GROUP BY</code>,  <code>HAVING</code>y  <code>WHERE</code>cl\u00e1usulas. Esto se debe a que l\u00f3gicamente se ejecutan despu\u00e9s de la tramitaci\u00f3n de esas cl\u00e1usulas. Adem\u00e1s, las funciones de la ventana se ejecutan despu\u00e9s de funciones de agregados no de ventana. Esto significa que es v\u00e1lido  incluir una llamada de funci\u00f3n agregada en los argumentos de una funci\u00f3n de ventana, pero no viceversa.</p> <p>Si hay una necesidad de filtrar o agrupar filas despu\u00e9s de que se  realizan los c\u00e1lculos de la ventana, puede utilizar un subseleccionado.  Por ejemplo:</p> <pre><code>SELECT depname, empno, salary, enroll_date\nFROM\n  (SELECT depname, empno, salary, enroll_date,\n          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n     FROM empsalary\n  ) AS ss\nWHERE pos &lt; 3;\n</code></pre> <p>La consulta anterior s\u00f3lo muestra las filas de la consulta interior teniendo  <code>rank</code>menos de 3.</p> <p>Cuando una consulta implica m\u00faltiples funciones de ventana, es posible escribir cada una con una separada  <code>OVER</code>cl\u00e1usula, pero esto es duplicado y propenso a errores si se quiere el mismo  comportamiento de escaparate para varias funciones. En su lugar, cada  comportamiento de ventanas puede ser nombrado en un  <code>WINDOW</code>cl\u00e1usula y luego referenciada en <code>OVER</code>. Por ejemplo:</p> <pre><code>SELECT sum(salary) OVER w, avg(salary) OVER w\n  FROM empsalary\n  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n</code></pre> <p>Se ver\u00e1n m\u00e1s detalles sobre las funciones de la ventana m\u00e1s adelante</p> <ol> <li> <p>Hay opciones para definir el marco de la ventana de otras maneras, pero este tutorial no los cubre. Para m\u00e1s detalles v\u00e9ase.\u00a0\u21a9</p> </li> </ol>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/06.-Herencia/","title":"06.-Herencia","text":"<p>La herencia es un concepto de bases de datos orientadas a objetos.  Abre interesantes nuevas posibilidades de dise\u00f1o de bases de datos.</p> <p>Vamos a crear dos tablas: Una tabla  <code>cities</code>y una mesa <code>capitals</code>. Naturalmente, las capitales tambi\u00e9n son ciudades, as\u00ed que quieres  alguna manera de mostrar las capitales impl\u00edcitamente cuando listas  todas las ciudades. Si eres realmente listo podr\u00edas inventar alg\u00fan  esquema como este:</p> <pre><code>CREATE TABLE capitals (\n  name       text,\n  population real,\n  elevation  int,    -- (in ft)\n  state      char(2)\n);\n\nCREATE TABLE non_capitals (\n  name       text,\n  population real,\n  elevation  int     -- (in ft)\n);\n\nCREATE VIEW cities AS\n  SELECT name, population, elevation FROM capitals\n    UNION\n  SELECT name, population, elevation FROM non_capitals;\n</code></pre> <p>Esto funciona bien en cuanto a consultas va, pero se pone feo cuando necesitas actualizar varias filas, para una cosa.</p> <p>Una mejor soluci\u00f3n es la siguiente:</p> <pre><code>CREATE TABLE cities (\n  name       text,\n  population real,\n  elevation  int     -- (in ft)\n);\n\nCREATE TABLE capitals (\n  state      char(2) UNIQUE NOT NULL\n) INHERITS (cities);\n</code></pre> <p>En este caso, una fila de  <code>capitals</code>hereda todas las columnas (<code>name</code>, <code>population</code>, y <code>elevation</code>) de su progenitor, <code>cities</code>. El tipo de la columna  <code>name</code>es <code>text</code>, un tipo nativo PostgreSQL para cadenas de caracteres de longitud variable. El  <code>capitals</code>tabla tiene una columna adicional, <code>state</code>, que muestra su abreviatura estatal. En PostgreSQL, una tabla puede heredar de cero o m\u00e1s otras tablas.</p> <p>Por ejemplo, la siguiente consulta encuentra los nombres de todas  las ciudades, incluidas las capitales de los estados, que se encuentran  en una elevaci\u00f3n de m\u00e1s de 500 pies:</p> <pre><code>SELECT name, elevation\n  FROM cities\n  WHERE elevation &gt; 500;\n</code></pre> <p>que devuelve:</p> <pre><code>   name    | elevation\n-----------+-----------\n Las Vegas |      2174\n Mariposa  |      1953\n Madison   |       845\n(3 rows)\n</code></pre> <p>Por otro lado, la siguiente consulta encuentra todas las ciudades  que no son capitales de estado y est\u00e1n situadas en una elevaci\u00f3n de m\u00e1s  de 500 pies:</p> <pre><code>SELECT name, elevation\n    FROM ONLY cities\n    WHERE elevation &gt; 500;\n</code></pre> <pre><code>   name    | elevation\n-----------+-----------\n Las Vegas |      2174\n Mariposa  |      1953\n(2 rows)\n</code></pre> <p>Aqu\u00ed el  <code>ONLY</code> antes de  <code>cities</code> indica que la consulta debe ser atropaleada s\u00f3lo el  <code>cities</code> tablas y no tablas a continuaci\u00f3n  <code>cities</code>en la jerarqu\u00eda de herencias. Muchas de las \u00f3rdenes que ya hemos discutido. <code>SELECT</code>, <code>UPDATE</code>, y  <code>DELETE</code>- apoyar esto  <code>ONLY</code>notaci\u00f3n.</p> <p>Nota</p> <p>Aunque la herencia es a menudo \u00fatil, no se ha integrado con  limitaciones \u00fanicas o con claves for\u00e1neas, lo que limita su utilidad.</p>"},{"location":"01.-Tutorial/03.-Caracter%C3%ADsticas%20avanzadas/07.-Conclusi%C3%B3n/","title":"07.-Conclusi\u00f3n","text":"<p>PostgreSQL tiene muchas caracter\u00edsticas no tocadas en esta introducci\u00f3n, que se ha orientado hacia los nuevos usuarios de SQL. Estas caracter\u00edsticas se discuten con m\u00e1s detalle en adelante.</p>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/","title":"Base de datos PostgreSQL de ejemplo","text":"<p>La base de datos de alquiler de DVD representa los procesos comerciales de una tienda de alquiler de DVD. La base de datos de alquiler de DVD  tiene muchos objetos, entre ellos:</p> <ul> <li>15 tablas</li> <li>1 disparador</li> <li>7 vistas</li> <li>8 funciones</li> <li>1 dominio</li> <li>13 secuencias</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#modelo-de-er-de-alquiler-de-dvd","title":"Modelo de ER de alquiler de DVD","text":""},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#_1","title":"00.-Base de datos PostgreSQL de ejemplo","text":""},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#tablas","title":"Tablas","text":"<p>Hay 15 tablas en la base de datos de DVD Rental:</p> <ul> <li><code>actor</code> - almacena datos de actores, incluyendo nombre y apellidos.</li> <li><code>film</code> - almacena datos de pel\u00edculas tales como t\u00edtulo, a\u00f1o de lanzamiento, longitud, calificaci\u00f3n, etc.</li> <li><code>film_actor</code> - almacena, guarda las relaciones entre pel\u00edculas y actores.</li> <li><code>category</code> - almacena datos de las categor\u00edas de pel\u00edculas.</li> <li><code>film_category</code> - almacena las relaciones entre pel\u00edculas y categor\u00edas.</li> <li><code>store</code> - contiene los datos de la tienda, incluyendo el personal de gerente y la direcci\u00f3n.</li> <li><code>inventory</code> - almacena datos de inventario.</li> <li><code>rental</code> - almacena datos de alquiler.</li> <li><code>payment</code> - tiendas pagos de los clientes.</li> <li><code>staff</code> - almacena datos del personal.</li> <li><code>customer</code> - almacena datos de clientes.</li> <li><code>address</code> - de tiendas de la direcci\u00f3n de datos para el personal y clientes</li> <li><code>city</code> - alma los nombres de la ciudad.</li> <li><code>country</code> - almacene nombres de pa\u00edses.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#descargue-la-base-de-datos-de-muestras-postgresql","title":"Descargue la base de datos de muestras PostgreSQL","text":"<p>Puede descargar la base de datos de la muestra de alquiler de DVD PostgreSQL a trav\u00e9s del siguiente enlace:</p> <p>Descargar DVD Rental de la base de datos de muestras</p> <p>El archivo de base de datos est\u00e1 en <code>zip</code>formato ( <code>dvdrental.zip</code>) por lo que usted necesita para extraerlo a   <code>dvdrental.tar</code>antes de cargar la base de datos de la muestra en el servidor de bases de datos PostgreSQL.</p>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#descargar-diagrama-de-er-imprimible","title":"Descargar diagrama de ER imprimible","text":"<p>Adem\u00e1s de la base de datos de muestras, le proporcionamos un diagrama de ERE  imprimible en formato PDF. Puede descargar e imprimir el diagrama de ERE para referencia mientras practica PostgreSQL.</p> <p>Descargar el diagrama de ER imprimible</p> <p>Este tutorial le present\u00f3 una base de datos de muestras PostgreSQL llamada alquiler de DVD. Usaremos esta base de datos en nuestros tutoriales  PostgreSQL, as\u00ed que aseg\u00farese de cargarlo a su servidor.</p>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#cargar-postgresql-base-de-datos-de-ejemplo","title":"Cargar PostgreSQL Base de datos de ejemplo","text":"<p>Antes de seguir adelante con este tutorial, es necesario tener:</p> <ul> <li>Un servidor de bases de datos PostgreSQL instalado en su sistema.</li> <li>Una base de datos de muestra PostgreSQL llamada dvdrental.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#cargar-la-base-de-datos-de-muestras-usando-herramienta-psql","title":"Cargar la base de datos de muestras usando herramienta <code>psql</code>","text":"<p>Primero, lanza la herramienta psql.</p> <pre><code>&gt;psql\n</code></pre> <p>En segundo lugar, introduzca la informaci\u00f3n de la cuenta para iniciar sesi\u00f3n en el servidor de bases de datos PostgreSQL. Puede utilizar el  valor predeterminado proporcionado por <code>psql</code> pulsando el teclado Enter. Sin embargo, para la contrase\u00f1a, debe introducir la que proporcion\u00f3 durante la instalaci\u00f3n de PostgreSQL.</p> <pre><code>Server [localhost]:\nDatabase [postgres]:\nPort [5432]:\nUsername [postgres]:\nPassword for user postgres:\n</code></pre> <p>En tercer lugar, entrar en el siguiente  <code>CREATE DATABASE</code>declaraci\u00f3n para crear una nueva base de datos dvdrental.</p> <pre><code>postgres= # CREATE DATABASE dvdrental;\nCREATE DATABASE\n</code></pre> <p>PostgreSQL crear\u00e1 una nueva base de datos nombrada <code>dvdrental</code>.</p> <p>Finalmente, entra el comando <code>exit</code> para dejar <code>psql</code>:</p> <pre><code>postgres=# exit\n</code></pre> <p>Luego, navegue por la carpeta de binarios de la carpeta de instalaci\u00f3n PostgreSQL:</p> <pre><code>C:\\&gt;cd C:\\Program Files\\PostgreSQL\\12\\bin\n</code></pre> <p>Despu\u00e9s de eso, utilice la herramienta pg-restore para cargar datos en la base de datos dvdrental:</p> <pre><code>pg_restore -U postgres -d dvdrental C:\\sampledb\\dvdrental.tar\n</code></pre> <p>En este comando:</p> <ul> <li>El  <code>-U postgres</code> especifica al usuario <code>postgres</code> para iniciar sesi\u00f3n en el servidor de bases de datos PostgreSQL.</li> <li>El  <code>-d dvdrental</code> especifica la base de datos de destino para cargar.</li> </ul> <p>Finalmente, introduzca la contrase\u00f1a para el usuario postgres y pulse Enter</p> <pre><code>Password:\n</code></pre> <p>Se tarda unos segundos en cargar los datos almacenados en el archivo <code>dvdrental.tar</code>en la base de datos <code>dvdrental</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/00.-Base%20de%20datos%20PostgreSQL%20de%20ejemplo/#cargar-la-base-de-datos-de-dvd-rental-usando-pgadmin","title":"Cargar la base de datos de DVD Rental usando pgAdmin","text":"<p>Lo siguiente le muestra paso a paso sobre c\u00f3mo utilizar la herramienta pgAdmin para restaurar la base de datos de  del archivo de base de datos:</p> <p>Primero, inicie la herramienta pgAdmin y con\u00e9ctese al servidor PostgreSQL.</p> <p>En segundo lugar, haga clic derecho en las bases de datos y seleccione la opci\u00f3n  men\u00fa:</p> <p></p> <p>En tercer lugar, introduzca el nombre de la base de datos  <code>dvdrental</code>y haga Save clic en el bot\u00f3n Guardar:</p> <p></p> <p>Ver\u00e1 la nueva base de datos vac\u00eda creada bajo el nodo de Bases de Datos:</p> <p></p> <p>Cuarto, haga clic con el bot\u00f3n derecho en la base de datos dvdrental y elija Restaurar... elemento de men\u00fa para restaurar la base de datos del archivo de base de datos descargado:</p> <p></p> <p>Quinto, introduzca la ruta al archivo de la base de datos de ejemplo, por ejemplo, c:sampledb.dvddrental.tar y haga clic en el bot\u00f3n Restore:</p> <p></p> <p>Sexto, el proceso de restauraci\u00f3n se completar\u00e1 en pocos segundos y muestra el siguiente di\u00e1logo una vez que se complete:</p> <p></p> <p>Finalmente, abra la  <code>dvdrental</code>base de datos de panel del navegador de objetos, encontrar\u00e1 tablas en el  <code>public</code>esquema y otros objetos de base de datos como se muestra en la siguiente imagen:</p> <p></p> <p>En este tutorial, has aprendido a cargar el  <code>dvdrental</code>base de datos de muestras en el servidor de bases de datos PostgreSQL para practicar PostgreSQL.</p> <p>Vamos a empezar a aprender PostgreSQL y divertirnos.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/","title":"01.-SELECT","text":"<p>Una de las tareas m\u00e1s comunes, cuando se trabaja con la base de datos, es recuperar los datos de las tablas utilizando la declaraci\u00f3n <code>SELECT</code>.</p> <p>La declaraci\u00f3n  <code>SELECT</code> es una de las declaraciones m\u00e1s complejas en PostgreSQL.  Tiene muchas cl\u00e1usulas que se puede utilizar para formar una consulta flexible.</p> <p>Debido a su complejidad, lo dividiremos en muchos ejercicios m\u00e1s cortos y f\u00e1ciles de entender para que puedas aprender sobre cada cl\u00e1usula m\u00e1s r\u00e1pido.</p> <p>La declaraci\u00f3n <code>SELECT</code> tiene las siguientes cl\u00e1usulas:</p> <ul> <li>Seleccionar filas distintas usando el operador  <code>DISTINCT</code>.</li> <li>Ordenar las filas usando la cl\u00e1usula <code>ORDER BY</code>.</li> <li>Filtrar filas usando la cl\u00e1usula  <code>WHERE</code>.</li> <li>Seleccione un subconjunto de filas de una tabla usando la cl\u00e1usula <code>LIMIT</code> o  <code>FETCH</code>.</li> <li>Agrupar filas en grupos usando  la cl\u00e1usula <code>GROUP BY</code>.</li> <li>Grupos de filtro utilizando la cl\u00e1usula <code>HAVING</code></li> <li>Unirse a otras tablas usando uniones con las cl\u00e1usulas <code>INNER JOIN</code>, <code>LEFT JOIN</code>, <code>FULL OUTER JOIN</code>,  <code>CROSS JOIN</code>.</li> <li>Realizar operaciones establecidas mediante <code>UNION</code>, <code>INTERSECT</code>, y <code>EXCEPT</code>.</li> </ul> <p>En este tutorial, vas a enfocarte en las cl\u00e1usulas <code>SELECT</code> y  <code>FROM</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#sintaxis-de-declaracion-postgresql-select","title":"Sintaxis de declaraci\u00f3n PostgreSQL SELECT","text":"<p>Comenzamos con la forma b\u00e1sica de la declaraci\u00f3n <code>SELECT</code> que recupera los datos de una sola tabla.</p> <p>A continuaci\u00f3n se ilustra la sintaxis de la  <code>SELECT</code>de la declaraci\u00f3n:</p> <pre><code>SELECT\n   select_list\nFROM\n   table_name;\n</code></pre> <p>En esta sintaxis:</p> <ul> <li>Primero, especifique una lista de selecci\u00f3n que puede ser una columna o una lista de columnas en una tabla de la que desea recuperar datos. Si  especifica una lista de columnas, necesita colocar una coma (<code>,</code>) entre dos columnas para separarlas. Si desea seleccionar datos de todas las columnas de la tabla, puede utilizar un asterisco (<code>*</code>) abreviatura en lugar de especificar todos los nombres de la columna. La <code>select_list</code> tambi\u00e9n puede contener expresiones o valores literales.</li> <li>En segundo lugar, proporcione el nombre de la tabla desde la que desea consultar los datos despu\u00e9s de la palabra clave <code>FROM</code>.</li> </ul> <p>La cl\u00e1usula  <code>FROM</code> es opcional. Si no est\u00e1s consultando datos de ninguna tabla, puedes omitir la cl\u00e1usula  <code>FROM</code> en la declaraci\u00f3n  <code>SELECT</code>.</p> <p>PostgreSQL eval\u00faa la cl\u00e1usula  <code>FROM</code> antes de la cl\u00e1usula <code>SELECT</code> en la declaraci\u00f3n del  <code>SELECT</code>:</p> <p></p> <p>Tenga en cuenta que las palabras clave SQL son insensibles a may\u00fasculas/min\u00fasculas. Significa que  <code>SELECT</code> es equivalente a  <code>select</code> a <code>Select</code>. Por convenci\u00f3n, usaremos todas las palabras clave SQL en may\u00fasculas para hacer las consultas m\u00e1s f\u00e1ciles de leer.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#ejemplos-de-postgresql-select","title":"Ejemplos de PostgreSQL SELECT","text":"<p>Exploremos algunos ejemplos de uso de la declaraci\u00f3n  <code>SELECT</code>.</p> <p>Usaremos la tabla  <code>customer</code> en la BD  <code>dvdrental</code> para la demostraci\u00f3n.</p> <p></p> <p>Primero, con\u00e9ctese al servidor PostgreSQL usando el usuario  <code>postgres</code>:</p> <pre><code>psql -U postgres\n</code></pre> <p>Se le pedir\u00e1 que introduzca una contrase\u00f1a para el usuario  <code>postgres</code>.  Despu\u00e9s de introducir la contrase\u00f1a correctamente, estar\u00e1 conectado al servidor PostgreSQL:</p> <pre><code>postgres=#\n</code></pre> <p>En segundo lugar, cambie la base de datos actual a dvdrental:</p> <pre><code>\\c dvdrental\n</code></pre> <p>Tercero, ejecutar la consulta en los siguientes ejemplos.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#usar-la-declaracion-select-para-consultar-los-datos-de-una-columna","title":"Usar la declaraci\u00f3n <code>SELECT</code> para consultar los datos de una columna","text":"<p>Este ejemplo utiliza la declaraci\u00f3n <code>SELECT</code> para encontrar los nombres de los primeros nombres de todos los clientes de la tabla <code>customer</code>:</p> <pre><code>SELECT first_name FROM customer;\n</code></pre> <p>Aqu\u00ed est\u00e1 la salida parcial:</p> <pre><code> first_name\n-------------\n Jared\n Mary\n Patricia\n Linda\n Barbara\n...\n</code></pre> <p>Observe que a\u00f1adimos un punto y coma (<code>;</code>) al final de la declaraci\u00f3n <code>SELECT</code>. El punto y coma no es parte de la declaraci\u00f3n SQL; m\u00e1s bien, sirve como se\u00f1al a PostgreSQL indicando la conclusi\u00f3n de una declaraci\u00f3n SQL. Adem\u00e1s, se utilizan los (<code>;</code>)  para separar dos o m\u00e1s declaraciones SQL.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#ejemplo-uso-de-select-para-consultar-datos-de-varias-columnas","title":"Ejemplo.- Uso de SELECT para consultar datos de varias columnas","text":"<p>La siguiente consulta utiliza  <code>SELECT</code> para recuperar el nombre, apellido y correo electr\u00f3nico de los clientes de la tabla <code>customer</code>:</p> <pre><code>SELECT\n   first_name,\n   last_name,\n   email\nFROM\n   customer;\n</code></pre> <p>Salida parcial:</p> <pre><code> first_name  |  last_name   |                  email\n-------------+--------------+------------------------------------------\n Jared       | Ely          | jared.ely@sakilacustomer.org\n Mary        | Smith        | mary.smith@sakilacustomer.org\n Patricia    | Johnson      | patricia.johnson@sakilacustomer.org\n...\n</code></pre> <p>La salida muestra tres columnas correspondientes de nombre, apellido y correo electr\u00f3nico.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#ejemplo-uso-de-select-para-consultar-datos-de-todas-las-columnas-de-una-tabla","title":"Ejemplo.- Uso de SELECT para consultar datos de todas las columnas de una tabla","text":"<p>La siguiente consulta utiliza la la declaraci\u00f3n  <code>SELECT *</code> para recuperar los datos de todas las columnas de la  tabla <code>customer</code>:</p> <pre><code>SELECT * FROM customer;\n</code></pre> <p>Salida parcial:</p> <pre><code> customer_id | store_id | first_name  |  last_name   |                  email                   | address_id | activebool | create_date |       last_update       | active\n-------------+----------+-------------+--------------+------------------------------------------+------------+------------+-------------+-------------------------+--------\n         524 |        1 | Jared       | Ely          | jared.ely@sakilacustomer.org             |        530 | t          | 2006-02-14  | 2013-05-26 14:49:45.738 |      1\n           1 |        1 | Mary        | Smith        | mary.smith@sakilacustomer.org            |          5 | t          | 2006-02-14  | 2013-05-26 14:49:45.738 |      1\n           2 |        1 | Patricia    | Johnson      | patricia.johnson@sakilacustomer.org      |          6 | t          | 2006-02-14  | 2013-05-26 14:49:45.738 |      1\n...\n</code></pre> <p>En este ejemplo, usamos un asterisco (<code>*</code>) en la cl\u00e1usula <code>SELECT</code>, que sirve de abreviatura para \"todas las columnas\".</p> <p>En lugar de enumerar todas las columnas en la cl\u00e1usula  <code>SELECT</code> individualmente, podemos utilizar el asterisco (<code>*</code>) para hacer la consulta m\u00e1s corta.</p> <p>Sin embargo, el uso del asterisco (<code>*</code>) en la declaraci\u00f3n  <code>SELECT</code> se considera una mala pr\u00e1ctica cuando se incrustan declaraciones de SQL en el c\u00f3digo de solicitud, como Python, Java o PHP por las siguientes razones:</p> <ul> <li>Rendimiento de la base de datos.- Supongamos que se tiene una tabla con muchas columnas y datos sustanciales, la delcaraci\u00f3n  <code>SELECT</code> con el asterisco (<code>*</code>) seleccionar\u00e1 los datos de todas las columnas de la tabla,  potencialmente recuperando m\u00e1s datos de los requeridos para la  aplicaci\u00f3n.</li> <li>Rendimiento de la aplicaci\u00f3n. La recuperaci\u00f3n de  datos innecesarios aumenta el tr\u00e1fico entre el servidor PostgreSQL y el servidor de la aplicaci\u00f3n. En consecuencia, esto puede resultar en tiempos de respuesta m\u00e1s lentos y una escalabilidad reducida para sus  aplicaciones.</li> </ul> <p>Por estas razones, se recomienda especificar expl\u00edcitamente los nombres de las columnas requeridas en la cl\u00e1usula  <code>SELECT</code> siempre que sea posible. Esto garantiza que s\u00f3lo los datos necesarios se recuperen de la base de datos, contribuyendo a consultas m\u00e1s  eficientes y optimizadas.</p> <p>La abreviatura (*) debe reservarse exclusivamente para las consultas ad-hoc que examinan los datos de la base de datos.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#ejemplo-uso-de-select-con-expresiones","title":"Ejemplo.- Uso de SELECT con expresiones","text":"<p>El siguiente ejemplo utiliza el  <code>SELECT</code> para devolver los nombres completos y correos electr\u00f3nicos de todos los clientes de la tabla <code>customer</code>:</p> <pre><code>SELECT \n   first_name || ' ' || last_name,\n   email\nFROM \n   customer;\n</code></pre> <p>Producto:</p> <pre><code>       ?column?        |                  email\n-----------------------+------------------------------------------\n Jared Ely             | jared.ely@sakilacustomer.org\n Mary Smith            | mary.smith@sakilacustomer.org\n Patricia Johnson      | patricia.johnson@sakilacustomer.org\n...\n</code></pre> <p>En este ejemplo, utilizamos el operador de  <code>||</code> para concatenar el primer nombre, el espacio y el apellido de cada cliente.</p> <p>Observa que la primera columna de la salida no tiene un nombre (<code>?column?</code>). Para asignar un nombre a una columna temporalmente en la consulta, se puede utilizar un alias de columna:</p> <pre><code>expression AS column_alias\n</code></pre> <p>La palabra clave <code>AS</code> es opcional. Por lo tanto, se puede utilizar una sintaxis m\u00e1s corta:</p> <pre><code>expression column_lias\n</code></pre> <p>Por ejemplo, se puede asignar una columna alias <code>full-name</code> a la primera columna de la consulta de la siguiente manera:</p> <pre><code>SELECT \n   first_name || ' ' || last_name full_name,\n   email\nFROM \n   customer;\n</code></pre> <p>Salida:</p> <pre><code>       full_name       |                  email\n-----------------------+------------------------------------------\n Jared Ely             | jared.ely@sakilacustomer.org\n Mary Smith            | mary.smith@sakilacustomer.org\n Patricia Johnson      | patricia.johnson@sakilacustomer.org\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#uso-de-sql-select-sin-una-clausula-from","title":"Uso de SQL SELECT sin una cl\u00e1usula FROM","text":"<p>La cl\u00e1usula  <code>FROM</code> de la declaraci\u00f3n <code>SELECT</code> es opcional. Por lo tanto, se puedes omitirlo.</p> <p>T\u00edpicamente, se usa la cl\u00e1usula  <code>SELECT</code> con una funci\u00f3n para recuperar el resultado de la funci\u00f3n. Por ejemplo:</p> <pre><code>SELECT NOW();\n</code></pre> <p>En este ejemplo, utilizamos la funci\u00f3n  <code>NOW()</code> en la declaraci\u00f3n  <code>SELECT</code> que devuelve la fecha y hora actuales del servidor PostgreSQL.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/01.-SELECT/#resumen","title":"Resumen","text":"<ul> <li>Utiliza la declaraci\u00f3n  <code>SELECT ... FROM</code> para recuperar los datos de una tabla.</li> <li>PostgreSQL eval\u00faa primero la declaraci\u00f3n <code>FROM</code> en la cl\u00e1usula  <code>SELECT</code>.</li> <li>Utiliza un alias de columna para asignar un nombre temporal a una columna o a una expresi\u00f3n en una consulta.</li> <li>En PostgreSQL, la cl\u00e1usula  <code>FROM</code> es opcional.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/","title":"02.-Alias de columnas","text":"<p>Un alias de columna te permite asignar a una columna o expresi\u00f3n en la lista de selecci\u00f3n de una declaraci\u00f3n <code>SELECT</code> un nombre temporal. El alias de columna existe temporalmente durante la ejecuci\u00f3n de la consulta.</p> <p>A continuaci\u00f3n se ilustra la sintaxis del uso de un alias de columna:</p> <pre><code>SELECT column_name AS alias_name\nFROM table_name;\n</code></pre> <p>En esta sintaxis, a <code>column_name</code> se le asigna un alias <code>alias_name</code>. La palabra clave <code>AS</code> es opcional por lo que puedes omitirla as\u00ed:</p> <pre><code>SELECT column_name alias_name\nFROM table_name;\n</code></pre> <p>La siguiente sintaxis ilustra c\u00f3mo establecer un alias para una expresi\u00f3n en la <code>SELECT</code>cl\u00e1usula:</p> <pre><code>SELECT expression AS alias_name\nFROM table_name;\n</code></pre> <p>El objetivo principal de los alias de columna es hacer que los encabezados del resultado de una consulta sean m\u00e1s significativos.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/#ejemplos-de-alias-de-columna-de-postgresql","title":"Ejemplos de alias de columna de PostgreSQL","text":"<p>Usaremos la tabla <code>customer</code> de la base de datos de muestra para mostrar c\u00f3mo trabajar con alias de columnas.</p> <p>\u200b         </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/#asignar-un-alias-de-columna-a-un-ejemplo-de-columna","title":"Asignar un alias de columna a un ejemplo de columna","text":"<p>La siguiente consulta devuelve los nombres y apellidos de todos los clientes de la tabla <code>customer</code>:</p> <pre><code>SELECT \n   first_name, \n   last_name\nFROM customer;\n</code></pre> <p>\u200b         </p> <p>Si deseas cambiar el nombre del encabezado <code>last_name</code>, puedes asignarle un nuevo nombre usando un alias de columna como este:</p> <pre><code>SELECT\n   first_name, \n   last_name AS surname\nFROM customer;\n</code></pre> <p>Esta consulta asign\u00f3 <code>surname</code> como alias de la columna <code>last_name</code>:</p> <p>\u200b         </p> <p>O puede acortarlo eliminando la palabra clave <code>AS</code> de la siguiente manera:</p> <pre><code>SELECT \n   first_name, \n   last_name surname\nFROM customer;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/#asignar-un-alias-de-columna-a-un-ejemplo-de-expresion","title":"Asignar un alias de columna a un ejemplo de expresi\u00f3n","text":"<p>La siguiente consulta devuelve los nombres completos de todos los clientes. Construye el nombre completo concatenando el nombre, el espacio y el apellido:</p> <pre><code>SELECT \n   first_name || ' ' || last_name \nFROM \n   customer;\n</code></pre> <p>Tenga en cuenta que en PostgreSQL se utiliza <code>||</code>como operador de concatenaci\u00f3n que concatena una o m\u00e1s cadenas en una sola cadena.</p> <p>\u200b         </p> <p>Como puede ver claramente en el resultado, el encabezado de la columna no tiene significado <code>?column?</code>.</p> <p>Para solucionar este problema, puede asignar a la expresi\u00f3n <code>first_name || ' ' || last_name</code>un alias de columna, por ejemplo <code>full_name</code>:</p> <pre><code>SELECT\n    first_name || ' ' || last_name AS full_name\nFROM\n    customer;\n</code></pre> <p>\u200b         </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/#alias-de-columnas-que-contienen-espacios","title":"Alias de columnas que contienen espacios","text":"<p>Si un alias de columna contiene uno o m\u00e1s espacios, debe encerrarlo entre comillas dobles como esta:</p> <pre><code>column_name AS \"column alias\"\n</code></pre> <p>Por ejemplo:</p> <pre><code>SELECT\n    first_name || ' ' || last_name \"full name\"\nFROM\n    customer;\n</code></pre> <p>\u200b         </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/02.-Alias%20de%20columnas/#resumen","title":"Resumen","text":"<ul> <li>Asigne a una columna o expresi\u00f3n un alias de columna usando la sintaxis <code>column_name AS alias_name</code> o  <code>expression AS alias_name</code>. La palabra clave <code>AS</code> es opcional.</li> <li>Utilice comillas dobles (\u201c) para rodear los alias de columnas que contengan espacios.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/","title":"03.-ORDER BY","text":"<p>Cuando consulta datos de una tabla, la declaraci\u00f3n <code>SELECT</code> devuelve filas en un orden no especificado. Para ordenar las filas del conjunto de resultados, utilice la cl\u00e1usula <code>ORDER BY</code> de la declaraci\u00f3n <code>SELECT</code>.</p> <p>La cl\u00e1usula <code>ORDER BY</code>  le permite ordenar las filas devueltas por una cl\u00e1usula  <code>SELECT</code>  en orden ascendente o descendente seg\u00fan una expresi\u00f3n de clasificaci\u00f3n.</p> <p>A continuaci\u00f3n se ilustra la sintaxis de la cl\u00e1usula <code>ORDER BY</code> :</p> <pre><code>SELECT \n  select_list \nFROM \n  table_name \nORDER BY \n  sort_expression1 [ASC | DESC], \n  sort_expression2 [ASC | DESC],\n  ...;\n</code></pre> <p>En esta sintaxis:</p> <ul> <li>Primero, especifique una expresi\u00f3n de  clasificaci\u00f3n, que puede ser una columna o una expresi\u00f3n, que desea  ordenar despu\u00e9s de las palabras clave <code>ORDER BY</code>. Si desea ordenar el conjunto de resultados en funci\u00f3n de varias columnas o expresiones, debe colocar una coma ( <code>,</code>) entre dos columnas o expresiones para separarlas.</li> <li>En segundo lugar, utiliza la opci\u00f3n <code>ASC</code>  para ordenar filas en orden ascendente y la opci\u00f3n  <code>DESC</code>  para ordenar filas en orden descendente. Si omite la opci\u00f3n <code>ASC</code> o  <code>DESC</code>,  <code>ORDER BY</code> utiliza <code>ASC</code> de forma predeterminada.</li> </ul> <p>PostgreSQL eval\u00faa las cl\u00e1usulas de la declaraci\u00f3n <code>SELECT</code>  en el siguiente orden: <code>FROM</code>, <code>SELECT</code>y <code>ORDER BY</code>:</p> <p>\u200b         </p> <p>Debido al orden de evaluaci\u00f3n, si tiene un alias de columna en la cl\u00e1usula <code>SELECT</code>, puede usarlo en la cl\u00e1usula <code>ORDER BY</code>.</p> <p>Tomemos algunos ejemplos del uso de la <code>ORDER BY</code> cl\u00e1usula PostgreSQL.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#order-by-ejemplos","title":"ORDER BY ejemplos","text":"<p>Usaremos la tabla <code>customer</code> de la base de datos de muestra para la demostraci\u00f3n.</p> <p>\u200b         </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#uso-de-la-clausula-order-by-de-postgresql-para-ordenar-filas-por-una-columna","title":"Uso de la cl\u00e1usula ORDER BY de PostgreSQL para ordenar filas por una columna","text":"<p>La siguiente consulta utiliza la cl\u00e1usula <code>ORDER BY</code> para ordenar a los clientes por sus nombres en orden ascendente:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nORDER BY \n  first_name ASC;\n</code></pre> <p>\u200b         </p> <p>Dado que la opci\u00f3n <code>ASC</code> es la predeterminada, puede omitirla en la cl\u00e1usula <code>ORDER BY</code> como aqu\u00ed:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nORDER BY \n  first_name;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#uso-de-la-clausula-order-by-de-postgresql-para-ordenar-filas-por-una-columna-en-orden-descendente","title":"Uso de la cl\u00e1usula ORDER BY de PostgreSQL para ordenar filas por una columna en orden descendente","text":"<p>La siguiente declaraci\u00f3n selecciona el nombre y el apellido de la tabla <code>customer</code> y ordena las filas por valores en la columna de apellido en orden descendente:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nORDER BY \n  last_name DESC;\n</code></pre> <p>\u200b         </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#uso-de-la-clausula-order-by-de-postgresql-para-ordenar-filas-por-varias-columnas","title":"Uso de la cl\u00e1usula ORDER BY de PostgreSQL para ordenar filas por varias columnas","text":"<p>La siguiente declaraci\u00f3n selecciona el nombre y el apellido de la tabla de clientes y ordena las filas por el nombre en  orden ascendente y el apellido en orden descendente:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nORDER BY \n  first_name ASC, \n  last_name DESC;\n</code></pre> <p>\u200b         </p> <p>En este ejemplo, la cl\u00e1usula ORDER BY ordena primero las filas por valores en la columna del nombre. Luego ordena las filas ordenadas por valores en la columna de apellido.</p> <p>Como se puede ver en la salida, dos clientes con el mismo nombre,  <code>Kelly</code>, tiene el apellido ordenado en orden descendente.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#uso-de-la-clausula-order-by-para-ordenar-filas-por-expresiones","title":"Uso de la cl\u00e1usula ORDER BY para ordenar filas por expresiones","text":"<p>La funci\u00f3n <code>LENGTH()</code> acepta una cadena y devuelve su longitud.</p> <p>La siguiente sentencia selecciona los nombres y sus longitudes. Ordena las filas por la longitud de los nombres:</p> <pre><code>SELECT \n  first_name, \n  LENGTH(first_name) len \nFROM \n  customer \nORDER BY \n  len DESC;\n</code></pre> <p>\u200b         </p> <p>Como la cl\u00e1usula <code>ORDER BY</code> se eval\u00faa despu\u00e9s de la cl\u00e1usula <code>SELECT</code>, el alias de columna <code>len</code> est\u00e1 disponible y se puede utilizar en la cl\u00e1usula <code>ORDER BY</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#clausula-order-by-de-postgresql-y-null","title":"Cl\u00e1usula ORDER BY de PostgreSQL y NULL","text":"<p>En el mundo de las bases de datos, <code>NULL</code> es un marcador que indica que faltan datos o que los datos son desconocidos en el momento del registro.</p> <p>Cuando ordena filas que contienen <code>NULL</code>, puede especificar el orden de <code>NULL</code> con otros valores no nulos utilizando la opci\u00f3n <code>NULLS FIRST</code> o <code>NULLS LAST</code> de la cl\u00e1usula <code>ORDER BY</code>:</p> <pre><code>ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST]Lenguaje del c\u00f3digo: CSS (css)\n</code></pre> <p>La opci\u00f3n <code>NULLS FIRST</code> coloca <code>NULL</code> antes de otros valores no nulos y la opci\u00f3n <code>NULL LAST</code> coloca <code>NULL</code> despu\u00e9s de otros valores no nulos.</p> <p>Vamos a crear una tabla para la demostraci\u00f3n.</p> <pre><code>-- create a new table\nCREATE TABLE sort_demo(num INT);\n\n-- insert some data\nINSERT INTO sort_demo(num) \nVALUES \n  (1), \n  (2), \n  (3), \n  (null);\n</code></pre> <p>Tenga en cuenta que si a\u00fan no est\u00e1 familiarizado con las sentencias <code>CREATE TABLE</code> e <code>INSERT</code>, puede simplemente ejecutarlas desde <code>pgAdmin</code> o <code>psql</code> para crear la tabla <code>sort_demo</code> e insertar datos en ella.</p> <p>La siguiente consulta devuelve datos de la tabla <code>sort_demo</code>:</p> <pre><code>SELECT \n  num \nFROM \n  sort_demo \nORDENAR POR \n  num;\n</code></pre> <p>Salida:</p> <pre><code> num\n------\n    1\n    2\n    3\n null\n(4 filas)\n</code></pre> <p>En este ejemplo, la cl\u00e1usula <code>ORDER BY</code> ordena los valores de la columna <code>num</code> de la tabla <code>sort_demo</code> en orden ascendente. Coloca <code>NULL</code> despu\u00e9s de otros valores.</p> <p>Tenga en cuenta que <code>psql</code> muestra <code>null</code> como una cadena vac\u00eda por defecto. Para hacer <code>null</code> m\u00e1s claro, puede ejecutar el siguiente comando para cambiar una cadena vac\u00eda por otra como <code>null</code>:</p> <pre><code>\\pset null null\n</code></pre> <p>Salida:</p> <pre><code>Null display is \"null\"\n</code></pre> <p>Por tanto, si utiliza la opci\u00f3n <code>ASC</code>, la cl\u00e1usula <code>ORDER BY</code> utiliza por defecto la opci\u00f3n <code>NULLS LAST</code>. Por lo tanto, la siguiente consulta devuelve el mismo resultado:</p> <pre><code>SELECT \n  num \nFROM \n  sort_demo \nORDENAR POR \n  num NULLS LAST;\n</code></pre> <p>Salida:</p> <pre><code> num\n------\n    1\n    2\n    3\n null\n(4 rows)\n\n</code></pre> <p>Para anteponer <code>NULL</code> a otros valores no nulos, se utiliza la opci\u00f3n <code>NULLS FIRST</code>:</p> <pre><code>SELECT \n  num \nFROM \n  sort_demo \nORDENAR POR \n  num NULLS FIRST;\n</code></pre> <p>Salida:</p> <pre><code> num\n------\n null\n    1\n    2\n    3\n(4 rows)\n</code></pre> <p>La siguiente sentencia ordena los valores de la columna <code>num</code> de la tabla <code>sort_demo</code> en orden descendente:</p> <pre><code>SELECT \n  num \nFROM \n  ordenar_demo \nORDENAR POR \n  num DESC;\n</code></pre> <p>Salida:</p> <pre><code> num\n------\n null\n    3\n    2\n    1\n(4 filas)\n</code></pre> <p>La salida indica que la cl\u00e1usula <code>ORDER BY</code> con la opci\u00f3n <code>DESC</code> utiliza los <code>NULLS FIRST</code> por defecto.</p> <p>Para invertir el orden, puedes utilizar la opci\u00f3n <code>NULLS LAST</code>:</p> <pre><code>SELECT \n  num \nFROM \n  ordenar_demo \nORDENAR POR \n  num DESC NULLS LAST;\n</code></pre> <p>Salida:</p> <pre><code> num\n------\n    3\n    2\n    1\n null\n(4 rosws)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/03.-ORDER%20BY/#resumen","title":"Resumen","text":"<ul> <li>Utiliza la cl\u00e1usula <code>ORDER BY</code> en la sentencia <code>SELECT</code> para ordenar las filas del conjunto de consulta.</li> <li>Utiliza la opci\u00f3n <code>ASC</code> para ordenar las filas en orden ascendente y la opci\u00f3n <code>DESC</code> para ordenar las filas en orden descendente.</li> <li>La <code>ORDER BY</code>cl\u00e1usula utiliza la <code>ASC</code>opci\u00f3n por defecto.</li> <li>Use las opciones <code>NULLS FIRST</code>y <code>NULLS LAST</code>para especificar expl\u00edcitamente el orden de <code>NULL</code>con otros valores no nulos.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/04.-SELECT%20DISTINCT/","title":"04.-SELECT DISTINCT","text":"<p>La cl\u00e1usula <code>SELECT DISTINCT</code> elimina filas duplicadas de un conjunto de resultados. La cl\u00e1usula <code>SELECT DISTINCT</code> retiene una fila por cada grupo de duplicados.</p> <p>La cl\u00e1usula <code>SELECT DISTINCT</code> puede aplicarse a una o varias columnas de la lista de selecci\u00f3n de la sentencia <code>SELECT</code>.</p> <p>A continuaci\u00f3n se ilustra la sintaxis de la cl\u00e1usula <code>DISTINCT</code>:</p> <pre><code>SELECT \n  DISTINCT columna1 \nFROM \n  nombre_tabla;\n</code></pre> <p>En esta sintaxis, <code>SELECT DISTINCT</code> utiliza los valores de la columna <code>columna1</code> para evaluar el duplicado.</p> <p>Si especifica varias columnas, la cl\u00e1usula <code>SELECT DISTINCT</code> evaluar\u00e1 el duplicado bas\u00e1ndose en la combinaci\u00f3n de valores de dichas columnas. Por ejemplo</p> <pre><code>SELECT\n   DISTINCT columna1, columna2\nFROM\n   nombre_tabla;\n</code></pre> <p>En esta sintaxis, el <code>SELECT DISTINCT</code> utiliza la combinaci\u00f3n de valores de las columnas <code>columna1</code> y <code>columna2</code> para evaluar el duplicado.</p> <p>Tenga en cuenta que PostgreSQL tambi\u00e9n ofrece la cl\u00e1usula DISTINCT ON que conserva la primera entrada \u00fanica de una columna o combinaci\u00f3n de columnas en el conjunto de resultados. </p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/04.-SELECT%20DISTINCT/#ejemplos-sql-select-distinct","title":"Ejemplos.- SQL SELECT DISTINCT","text":"<p>Vamos a crear una nueva tabla llamada <code>distinct_demo</code> e insertar datos en ella para practicar la cl\u00e1usula <code>DISTINCT</code>.</p> <p>Ten en cuenta que aprender\u00e1s a crear una tabla y a insertar datos en una tabla en el tutorial siguiente. En este tutorial, solo ejecute la sentencia en psql o pgAdmin para ejecutar las sentencias.</p> <p>Primero, crea la tabla <code>distinct_demo</code> que tiene tres columnas: <code>id</code>, <code>bcolor</code> y <code>fcolor</code> usando la siguiente sentencia <code>CREATE TABLE</code>:</p> <pre><code>CREATE TABLE distinct_demo (\n  id SERIAL NOT NULL PRIMARY KEY, \n  bcolor VARCHAR, \n  fcolor VARCHAR\n)\n</code></pre> <p>En segundo lugar, inserta algunas filas en la tabla <code>distinct_demo</code> utilizando la sentencia INSERT:</p> <pre><code>INSERT INTO distinct_demo (bcolor, fcolor) \nVALUES \n  ('rojo', 'rojo'), \n  ('rojo', 'rojo'), \n  ('rojo', NULL), \n  (NULL, 'rojo'), \n  ('rojo', 'verde'), \n  ('rojo', 'azul'), \n  ('verde', 'rojo'), \n  ('verde', 'azul'), \n  ('verde', 'verde'), \n  ('azul', 'rojo'), \n  ('azul', 'verde'), \n  ('azul', 'azul');\n</code></pre> <p>En tercer lugar, recupera los datos de la tabla <code>distinct_demo</code> utilizando la sentencia <code>SELECT</code>:</p> <pre><code>SELECT \n  id, \n  bcolor, \n  fcolor \nFROM \n  distinct_demo;\n</code></pre> <p></p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/04.-SELECT%20DISTINCT/#postgresql-distinct-ejemplo-de-una-columna","title":"PostgreSQL DISTINCT ejemplo de una columna","text":"<p>La siguiente sentencia selecciona valores \u00fanicos en la columna <code>bcolor</code> de la tabla <code>t1</code> y ordena el conjunto de resultados por orden alfab\u00e9tico utilizando el ORDER BY.</p> <pre><code>SELECT \n  DISTINCT bcolor \nFROM \n  distinct_demo \nORDER BY \n  bcolor;\n</code></pre> <p></p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/04.-SELECT%20DISTINCT/#distinct-columnas-multiples","title":"DISTINCT columnas m\u00faltiples","text":"<p>La siguiente sentencia demuestra c\u00f3mo utilizar la cl\u00e1usula <code>DISTINCT</code> en m\u00faltiples columnas:</p> <pre><code>SELECT \n  DISTINCT bcolor, \n  fcolor \nFROM \n  distinct_demo \nORDER BY \n  bcolor, \n  fcolor;\n</code></pre> <p></p> <p>Como hemos especificado las columnas <code>bcolor</code> y <code>fcolor</code> en la cl\u00e1usula <code>SELECT DISTINCT</code>, la sentencia combina los valores de las columnas <code>bcolor</code> y <code>fcolor</code> para evaluar la unicidad de las filas.</p> <p>La consulta devuelve la combinaci\u00f3n \u00fanica de <code>bcolor</code> y <code>fcolor</code> de la tabla <code>distinct_demo</code>.</p> <p>Observe que la tabla <code>distinct_demo</code> tiene dos filas con el valor <code>red</code> en las columnas <code>bcolor</code> y <code>fcolor</code>. Cuando aplicamos <code>DISTINCT</code> a ambas columnas, se elimina una fila duplicada del conjunto de resultados.</p>"},{"location":"02.-Tutorial%20Avanzado/01.-Consultas/04.-SELECT%20DISTINCT/#resumen","title":"Resumen","text":"<ul> <li>Utilice <code>SELECT DISTINCT</code> para eliminar filas duplicadas de un conjunto de resultados de una consulta.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/","title":"01.-WHERE","text":"<p>La sentencia <code>SELECT</code> devuelve todas las filas de una o varias columnas de una tabla. Para recuperar filas que satisfacen una condici\u00f3n especificada, se utiliza una cl\u00e1usula <code>WHERE</code>.</p> <p>La sintaxis de la cl\u00e1usula <code>WHERE</code> de PostgreSQL es la siguiente:</p> <pre><code>SELECT \n  seleccionar_lista \nFROM \n  nombre_tabla \nWHERE \n  condici\u00f3n \nORDENAR POR \n  sort_expression;\n</code></pre> <p>En esta sintaxis, la cl\u00e1usula <code>WHERE</code> se coloca justo despu\u00e9s de la cl\u00e1usula <code>FROM</code> de la sentencia <code>SELECT</code>. </p> <p>La cl\u00e1usula <code>WHERE</code> utiliza la condici\u00f3n <code>condition</code> para filtrar las filas devueltas por la cl\u00e1usula <code>SELECT</code>.</p> <p>La condici\u00f3n es una expresi\u00f3n booleana que se eval\u00faa como verdadero, falso o desconocido.</p> <p>La consulta s\u00f3lo devuelve las filas que cumplen la \"condici\u00f3n\" de la cl\u00e1usula \"WHERE\". En otras palabras, la consulta incluir\u00e1 en el conjunto de resultados s\u00f3lo las filas que hagan que la \"condici\u00f3n\" se eval\u00fae como verdadera.</p> <p>PostgreSQL eval\u00faa la cl\u00e1usula <code>WHERE</code> despu\u00e9s de la cl\u00e1usula <code>FROM</code> pero antes de las cl\u00e1usulas <code>SELECT</code> y <code>ORDER BY</code>:</p> <p></p> <p>Si utiliza un alias de columna en la cl\u00e1usula <code>SELECT</code>, no se podr\u00e1 utilizar en la cl\u00e1usula <code>WHERE</code>.</p> <p>Adem\u00e1s de la sentencia <code>SELECT</code>, se puede utilizar la cl\u00e1usula <code>WHERE</code> en las sentencias <code>UPDATE</code> y <code>DELETE</code> para especificar filas a actualizar y borrar.</p> <p>Para formar la condici\u00f3n en la cl\u00e1usula <code>WHERE</code>, se utilizan operadores l\u00f3gicos y de comparaci\u00f3n:</p> Operador Descripci\u00f3n = Igual &gt; Mayor que than &lt; Menos que &gt;= Mayor o igual que &lt;= Menor o igual que &lt;&gt; or != Distinto AND Operador l\u00f3gico AND OR Operador l\u00f3gico OR IN Devuelve <code>true</code> si un valor coincide con cualquier valor de la lista BETWEEN Devuelve <code>true</code> si un valor est\u00e1 entre un rango de valores LIKE Devuelve <code>true</code> si un valor coincide con el patr\u00f3n IS NULL Devuelve <code>true</code> si un valor es NULL NOT Niega el resultado de otros operadores"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplos-de-la-clausula-where","title":"Ejemplos de la cl\u00e1usula <code>WHERE</code>","text":"<p>Practiquemos con algunos ejemplos de uso de la cl\u00e1usula <code>WHERE</code>.</p> <p>Utilizaremos la tabla <code>customer</code> de la base de datos de ejemplo para la demostraci\u00f3n.</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>=</code>","text":"<p>La siguiente sentencia utiliza la cl\u00e1usula <code>WHERE</code> para encontrar clientes cuyo nombre de pila sea <code>Jamie</code>:</p> <pre><code>SELECT \n  last_name \n  first_name\nFROM \n  customer\nWHERE\n  first_name = 'Jamie';\n</code></pre> <p>Salida:</p> <pre><code> last_name | first_name\n-----------+------------\n Rice      | Jamie\n Waugh     | Jamie\n(2 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador-and","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>AND</code>","text":"<p>El siguiente ejemplo utiliza una cl\u00e1usula <code>WHERE</code> con el operador l\u00f3gico <code>AND</code> para buscar clientes cuyo nombre y apellidos sean <code>Jamie</code> y <code>rice</code>:</p> <pre><code>SELECT \n  last_name, \n  first_name \nFROM \n  customer \nWHERE \n  first_name = 'Jamie' \n  AND last_name = 'Rice';\n</code></pre> <p>Salida:</p> <pre><code> last_name | first_name\n-----------+------------\n Rice      | Jamie\n(1 row)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador-or","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>OR</code>","text":"<p>El siguiente ejemplo utiliza una cl\u00e1usula WHERE con un operador OR para encontrar los clientes cuyo apellido es <code>Rodriguez</code> o cuyo nombre es <code>Adam</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  last_name = 'Rodriguez' \n  OR first_name = 'Adam';\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Laura      | Rodriguez\n Adam       | Gooch\n(2 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador-in","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>IN</code>","text":"<p>Si desea encontrar un valor en una lista de valores, puede utilizar el operador <code>IN</code>.</p> <p>El siguiente ejemplo utiliza la cl\u00e1usula <code>WHERE</code> con el operador <code>IN</code> para encontrar los clientes con nombres en la lista Ann, Anne y Annie:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name IN ('Ann', 'Anne', 'Annie');Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Ann        | Evans\n Anne       | Powell\n Annie      | Russell\n(3 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador-like","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>LIKE</code>","text":"<p>Para encontrar una cadena que coincida con un patr\u00f3n especificado, utilice el operador <code>LIKE</code>.</p> <p>El siguiente ejemplo utiliza el operador LIKE en la cl\u00e1usula WHERE para buscar clientes cuyo nombre empiece por la palabra <code>Ann</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE 'Ann%';\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Anna       | Hill\n Ann        | Evans\n Anne       | Powell\n Annie      | Russell\n Annette    | Olson\n(5 rows)\n</code></pre> <p>El <code>%</code> es un comod\u00edn que coincide con cualquier cadena. El patr\u00f3n <code>'Ann%'</code> coincide con cualquier cadena que empiece por <code>'Ann'</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador-between","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>BETWEEN</code>","text":"<p>El siguiente ejemplo busca clientes cuyo nombre empiece por la letra <code>A</code> y contenga de 3 a 5 caracteres utilizando el operador <code>BETWEEN</code>.</p> <p>El operador <code>BETWEEN</code> devuelve verdadero si un valor se encuentra en un rango de valores.</p> <pre><code>SELECT \n  first_name, \n  LENGTH(first_name) name_length \nFROM \n  customer \nWHERE \n  first_name LIKE 'A%' \n  AND LENGTH(first_name) BETWEEN 3 \n  AND 5 \nORDER BY \n  name_length;\n</code></pre> <p>Salida:</p> <pre><code>first_name | name_length\n------------+-------------\n Amy        |           3\n Ann        |           3\n Ana        |           3\n Andy       |           4\n Anna       |           4\n Anne       |           4\n Alma       |           4\n Adam       |           4\n Alan       |           4\n Alex       |           4\n Angel      |           5\n...\n</code></pre> <p>En este ejemplo, utilizamos la funci\u00f3n <code>LENGTH()</code> para obtener el n\u00famero de caracteres de una cadena de entrada.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#ejemplo-de-uso-de-la-clausula-where-con-el-operador_1","title":"Ejemplo de uso de la cl\u00e1usula <code>WHERE</code> con el operador <code>&lt;&gt;</code>","text":"<p>Este ejemplo busca clientes cuyo nombre empiece por <code>Bra</code> y cuyo apellido no sea <code>Motley</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE 'Bra%' \n  AND last_name &lt;&gt; 'Motley';Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Brandy     | Graves\n Brandon    | Huey\n Brad       | Mccurdy\n(3 rows)\n</code></pre> <p>Tenga en cuenta que puede utilizar el operador <code>!=</code> y el operador <code>&lt;&gt;</code> indistintamente porque son equivalentes.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/01.-WHERE/#resumen","title":"Resumen","text":"<ul> <li>Utiliza una cl\u00e1usula <code>WHERE</code> en la sentencia <code>SELECT</code> para filtrar filas de una consulta en funci\u00f3n de una o varias condiciones.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/02.-AND/","title":"02.-AND","text":"<p>En PostgreSQL, un valor l\u00f3gico puede tener uno de estos tres valores: <code>true</code>, <code>false</code>, y <code>null</code>.</p> <p>PostgreSQL utiliza <code>true</code>, <code>'t'</code>, <code>'true'</code>, <code>'y'</code>, <code>'yes'</code>, <code>'1'</code> para representar <code>true</code> y <code>false</code>, <code>'f'</code>, <code>'false'</code>, <code>'n'</code>, <code>'no'</code>, y <code>'0'</code> para representar <code>false</code>.</p> <p>Una expresi\u00f3n l\u00f3gica es una expresi\u00f3n que se eval\u00faa con un valor booleano. Por ejemplo, la expresi\u00f3n <code>1=1</code> es una expresi\u00f3n l\u00f3gica que se eval\u00faa como <code>true</code>:</p> <pre><code>SELECT 1 = 1 AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>La letra <code>t</code> en la salida indica el valor verdadero.</p> <p>El operador <code>AND</code> es un operador l\u00f3gico que combina m\u00faltiples expresiones l\u00f3gicas. Esta es la sintaxis b\u00e1sica del operador <code>AND</code>:</p> <pre><code>expresi\u00f3n1 AND expresi\u00f3n2C\u00f3digo del lenguaje: SQL (Lenguaje de consulta estructurado) (sql)\n</code></pre> <p>En esta sintaxis, <code>expresi\u00f3n1</code> y <code>expresi\u00f3n2</code> son expresiones l\u00f3gicas que se eval\u00faan como <code>true</code>, <code>false</code> o <code>null</code>.</p> <p>El operador <code>AND</code> devuelve <code>true</code> s\u00f3lo si ambas expresiones son <code>true</code>. Devuelve <code>false</code> si una de las expresiones es falsa. En caso contrario, devuelve <code>null</code>.</p> <p>La siguiente tabla muestra los resultados del operador <code>AND</code> al combinar <code>true</code>, <code>false</code> y <code>null</code>.</p> AND True False Null True True False Null False False False False Null Null False Null <p>En la pr\u00e1ctica, a menudo se utiliza el operador <code>AND</code> en una cl\u00e1usula <code>WHERE</code> para garantizar que todas las expresiones especificadas deben ser verdaderas para que una fila se incluya en el conjunto de resultados.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/02.-AND/#operador-and-de-postgresql","title":"Operador AND de PostgreSQL","text":"<p>Exploremos algunos ejemplos de uso del operador <code>AND</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/02.-AND/#ejemplos-basicos-del-operador-and-en-postgresql","title":"Ejemplos b\u00e1sicos del operador AND en PostgreSQL","text":"<p>El siguiente ejemplo utiliza el operador <code>AND</code> para combinar dos valores verdaderos, que devuelve true:</p> <pre><code>SELECT true AND true AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>La siguiente sentencia utiliza el operador <code>AND</code> para combinar verdadero con falso, lo que devuelve falso:</p> <pre><code>SELECT true AND false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>AND</code> para combinar true con null, que devuelve null:</p> <pre><code>SELECT true AND null AS result;\n</code></pre> <p>Output:</p> <pre><code> result\n--------\n null\n(1 row)Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>AND</code> para combinar false con false, lo que devuelve false:</p> <pre><code>SELECT false AND false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>AND</code> para combinar false con null, lo que devuelve f:</p> <pre><code>SELECT false AND null AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>AND</code> para combinar false con false, lo que devuelve false:</p> <pre><code>SELECT false AND false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/02.-AND/#uso-del-operador-and-en-la-clausula-where","title":"Uso del operador AND en la cl\u00e1usula WHERE","text":"<p>Utilizaremos la tabla <code>film</code> de la base de datos de ejemplo para la demostraci\u00f3n:</p> <p></p> <p>El siguiente ejemplo utiliza el operador <code>AND</code> en la cl\u00e1usula <code>WHERE</code> para encontrar las pel\u00edculas que tienen una duraci\u00f3n superior a 180 y un precio de alquiler inferior a 1:</p> <pre><code>SELECT \n  title, \n  length, \n  rental_rate \nFROM \n  film \nWHERE \n  length &gt; 180 \n  AND rental_rate &lt; 1;\n</code></pre> <p>Salida:</p> <pre><code>       title        | length | rental_rate\n--------------------+--------+-------------\n Catch Amistad      |    183 |        0.99\n Haunting Pianist   |    181 |        0.99\n Intrigue Worst     |    181 |        0.99\n Love Suicides      |    181 |        0.99\n Runaway Tenenbaums |    181 |        0.99\n Smoochy Control    |    184 |        0.99\n Sorority Queen     |    184 |        0.99\n Theory Mermaid     |    184 |        0.99\n Wild Apollo        |    181 |        0.99\n Young Language     |    183 |        0.99\n(10 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/02.-AND/#resumen","title":"Resumen","text":"<ul> <li>Utilice el operador <code>AND</code> para combinar varias expresiones l\u00f3gicas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/03.-OR/","title":"03.-OR","text":"<p>En PostgreSQL, un valor l\u00f3gico puede tener uno de estos tres valores: <code>true</code>, <code>false</code>, y <code>null</code>.</p> <p>PostgreSQL utiliza <code>true</code>, <code>'t'</code>, <code>'true'</code>, <code>'y'</code>, <code>'yes'</code>, <code>'1'</code> para representar <code>true</code> y <code>false</code>, <code>'f'</code>, <code>'false'</code>, <code>'n'</code>, <code>'no'</code>, y <code>'0'</code> para representar <code>false</code>.</p> <p>Una expresi\u00f3n l\u00f3gica es una expresi\u00f3n que se eval\u00faa con un valor l\u00f3gico. Por ejemplo, la expresi\u00f3n <code>1&lt;&gt;1</code> es una expresi\u00f3n l\u00f3gica que se eval\u00faa como <code>false</code>:</p> <pre><code>SELECT 1 &lt;&gt; 1 AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>La letra <code>f</code> en la salida indica <code>false</code>.</p> <p>El operador <code>OR</code> es un operador l\u00f3gico que combina m\u00faltiples expresiones booleanas. Esta es la sintaxis b\u00e1sica del operador <code>OR</code>:</p> <pre><code>expression1 OR expression2\n</code></pre> <p>En esta sintaxis, <code>expresi\u00f3n1</code> y <code>expresi\u00f3n2</code> son expresiones booleanas que se eval\u00faan como <code>true</code>, <code>false</code> o <code>null</code>.</p> <p>El operador <code>OR</code> devuelve <code>true</code> s\u00f3lo si alguna de las expresiones es <code>true</code>. Devuelve <code>false</code> si ambas expresiones son falsas. En caso contrario, devuelve null.</p> <p>La siguiente tabla muestra los resultados del operador <code>OR</code> al combinar <code>true</code>, <code>false</code> y <code>null</code>.</p> OR True False Null True True True True False True False Null Null True Null Null <p>En la pr\u00e1ctica, se suele utilizar el operador <code>OR</code> en una cl\u00e1usula <code>WHERE</code> para garantizar que cualquiera de las expresiones especificadas debe ser verdadera para que una fila se incluya en el conjunto de resultados.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/03.-OR/#operador-or","title":"Operador OR","text":"<p>Exploremos algunos ejemplos de uso del operador <code>OR</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/03.-OR/#ejemplos-basicos-del-operador-or-de-postgresql","title":"Ejemplos b\u00e1sicos del operador OR de PostgreSQL","text":"<p>El siguiente ejemplo usa el operador <code>OR</code> para combinar <code>true</code> con <code>true</code>, lo cual retorna <code>true</code>:</p> <pre><code>SELECT true OR true AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>La siguiente sentencia utiliza el operador <code>OR</code> para combinar <code>true</code> con <code>false</code>, lo que devuelve verdadero:</p> <pre><code>SELECT true OR false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>OR</code> para combinar <code>true</code> con <code>null</code>, que devuelve <code>true</code>:</p> <pre><code>SELECT true OR null AS result;Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>OR</code> para combinar <code>false</code> con <code>false</code>, lo que devuelve <code>false</code>:</p> <pre><code>SELECT false OR false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>OR</code> para combinar <code>false</code> con <code>null</code>, lo que devuelve <code>null</code>:</p> <pre><code>SELECT false OR null AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n null\n(1 row)\n</code></pre> <p>El siguiente ejemplo utiliza el operador <code>OR</code> para combinar <code>false</code> con <code>false</code>, lo que devuelve <code>false</code>:</p> <pre><code>SELECT false OR false AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n f\n(1 row)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/03.-OR/#uso-del-operador-or-en-la-clausula-where","title":"Uso del operador OR en la cl\u00e1usula WHERE","text":"<p>Utilizaremos la tabla <code>film</code> de la base de ejemplo para la demostraci\u00f3n:</p> <p></p> <p>El siguiente ejemplo utiliza el operador <code>OR</code> en la cl\u00e1usula <code>WHERE</code> para encontrar las pel\u00edculas que tienen una tarifa de alquiler es <code>0.99</code> o <code>2.99</code>:</p> <pre><code>SELECT \n  title, \n  rental_rate \nFROM \n  film \nWHERE \n  rental_rate = 0.99 OR \n  rental_rate = 2.99;\n</code></pre> <p>Salida:</p> <pre><code>            title            | rental_rate\n-----------------------------+-------------\n Academy Dinosaur            |        0.99\n Adaptation Holes            |        2.99\n Affair Prejudice            |        2.99\n African Egg                 |        2.99\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/03.-OR/#resumen","title":"Resumen","text":"<ul> <li>Utilice el operador <code>OR</code> para combinar varias expresiones l\u00f3gicas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/","title":"04.-LIMIT","text":"<p>PostgreSQL <code>LIMIT</code> es una cl\u00e1usula opcional de la sentencia <code>SELECT</code> que restringe el n\u00famero de filas devueltas por la consulta.</p> <p>A continuaci\u00f3n se ilustra la sintaxis de la cl\u00e1usula <code>LIMIT</code>:</p> <pre><code>SELECT \n  select_list \nFROM \n  table_name \nORDER BY \n  sort_expression \nLIMIT \n  row_count;\n</code></pre> <p>La sentencia devuelve <code>row_count</code> filas generadas por la consulta. Si <code>row_count</code> es cero, la consulta devuelve un conjunto vac\u00edo. En caso de que <code>row_count</code> sea <code>NULL</code>, la consulta devuelve el mismo conjunto de resultados ya que no tiene la cl\u00e1usula <code>LIMIT</code>.</p> <p>Si desea omitir un n\u00famero de filas antes de devolver <code>row_count</code> filas, puede utilizar <code>OFFSET</code> cl\u00e1usula colocada despu\u00e9s de la cl\u00e1usula <code>LIMIT</code> como se muestra en la siguiente declaraci\u00f3n:</p> <pre><code>SELECT \n  select_list \nFROM \n  table_name \nORDER BY \n  sort_expression \nLIMIT \n  row_count OFFSET row_to_skip;\n</code></pre> <p>La sentencia omite primero las filas <code>row_to_skip</code> antes de devolver las filas <code>row_count</code> generadas por la consulta.</p> <p>Si <code>row_to_skip</code> es cero, la sentencia funcionar\u00e1 como si no tuviera la cl\u00e1usula <code>OFFSET</code>.</p> <p>Debido a que una tabla almacena las filas en un orden no especificado cuando se utiliza la cl\u00e1usula <code>LIMIT</code>, siempre se debe utilizar la cl\u00e1usula <code>ORDER BY</code> para controlar el orden de las filas.</p> <p>Si no utiliza la cl\u00e1usula <code>ORDER BY</code>, puede obtener un conjunto de resultados con el orden de filas no especificado.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/#ejemplos-de-limit-en-postgresql","title":"Ejemplos de LIMIT en PostgreSQL","text":"<p>Veamos algunos ejemplos de uso de la cl\u00e1usula <code>LIMIT</code> de PostgreSQL. Utilizaremos la tabla <code>film</code> de la base de datos de ejemplo para la demostraci\u00f3n.</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/#uso-de-postgresql-limit-para-restringir-el-numero-de-filas-devueltas-ejemplo","title":"Uso de PostgreSQL LIMIT para restringir el n\u00famero de filas devueltas ejemplo","text":"<p>Este ejemplo utiliza la cl\u00e1usula <code>LIMIT</code> para obtener las cinco primeras pel\u00edculas ordenadas por <code>film_id</code>:</p> <pre><code>SELECT \n  film_id, \n  title, \n  release_year \nFROM \n  film \nORDER BY \n  film_id \nLIMIT \n  5;\n</code></pre> <p>Salida:</p> <pre><code> film_id |      title       | release_year\n---------+------------------+--------------\n       1 | Academy Dinosaur |         2006\n       2 | Ace Goldfinger   |         2006\n       3 | Adaptation Holes |         2006\n       4 | Affair Prejudice |         2006\n       5 | African Egg      |         2006\n(5 rows)\n</code></pre> <p>C\u00f3mo funciona.</p> <ul> <li>En primer lugar, ordene las pel\u00edculas por el <code>film_id</code> en orden ascendente utilizando la cl\u00e1usula <code>ORDER BY film_id</code>.</li> <li>En segundo lugar, tome 5 pel\u00edculas de la parte superior utilizando la cl\u00e1usula <code>LIMIT 5</code>.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/#ejemplo-de-uso-de-postgresql-limit-con-offset","title":"Ejemplo de uso de PostgreSQL LIMIT con OFFSET","text":"<p>Para recuperar 4 pel\u00edculas empezando por la cuarta ordenada por <code>film_id</code>, se utilizan las cl\u00e1usulas <code>LIMIT</code> y <code>OFFSET</code> de la siguiente manera:</p> <pre><code>SELECT \n  film_id, \n  title, \n  release_year \nFROM \n  film \nORDER BY \n  film_id \nLIMIT 4 OFFSET 3;\n</code></pre> <p>Salida:</p> <pre><code> film_id |      title       | release_year\n---------+------------------+--------------\n       4 | Affair Prejudice |         2006\n       5 | African Egg      |         2006\n       6 | Agent Truman     |         2006\n       7 | Airplane Sierra  |         2006\n(4 rows)\n</code></pre> <p>C\u00f3mo funciona.</p> <ul> <li>En primer lugar, ordene las pel\u00edculas por el identificador de pel\u00edcula en orden ascendente.</li> <li>En segundo lugar, omita las tres primeras filas utilizando la cl\u00e1usula <code>OFFSET 3</code>.</li> <li>Segundo, toma las siguientes cuatro filas usando la cl\u00e1usula <code>LIMIT 4</code>.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/#usando-offset-limit-de-postgresql-para-obtener-n-filas-superioresinferiores","title":"Usando OFFSET LIMIT de PostgreSQL para obtener N filas superiores/inferiores","text":"<p>Normalmente, se utiliza la cl\u00e1usula <code>LIMIT</code> para seleccionar las filas con los valores m\u00e1s altos o m\u00e1s bajos de una tabla.</p> <p>El siguiente ejemplo utiliza la cl\u00e1usula LIMIT para recuperar las 10 pel\u00edculas m\u00e1s caras por precio de alquiler:</p> <pre><code>SELECT \n  film_id, \n  title, \n  rental_rate \nFROM \n  film \nORDER BY \n  rental_rate DESC \nLIMIT \n  10;\n</code></pre> <p>Salida:</p> <pre><code> film_id |        title        | rental_rate\n---------+---------------------+-------------\n      13 | Ali Forever         |        4.99\n      20 | Amelie Hellfighters |        4.99\n       7 | Airplane Sierra     |        4.99\n      10 | Aladdin Calendar    |        4.99\n       2 | Ace Goldfinger      |        4.99\n       8 | Airport Pollock     |        4.99\n      98 | Bright Encounters   |        4.99\n     133 | Chamber Italian     |        4.99\n     384 | Grosse Wonderful    |        4.99\n      21 | American Circus     |        4.99\n(10 rows)\n</code></pre> <p>C\u00f3mo funciona.</p> <ul> <li>En primer lugar, ordene todas las pel\u00edculas por precio de alquiler de mayor a menor utilizando la cl\u00e1usula <code>ORDER BY rental_rate</code>.</li> <li>Segundo, tome s\u00f3lo 10 filas de la parte superior utilizando la cl\u00e1usula <code>LIMIT 10</code>.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/04.-LIMIT/#resumen","title":"Resumen","text":"<ul> <li>Utilice la cl\u00e1usula <code>LIMIT OFFSET</code> de PostgreSQL para recuperar un subconjunto de filas devueltas por una consulta.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/05.-FETCH/","title":"05.-FETCH","text":"<p>Para omitir un cierto n\u00famero de filas y recuperar un n\u00famero espec\u00edfico de filas, a menudo se utiliza la cl\u00e1usula <code>LIMIT</code> en la sentencia <code>SELECT</code>.</p> <p>La cl\u00e1usula <code>LIMIT</code> es ampliamente utilizada por muchos Sistemas de Gesti\u00f3n de Bases de Datos Relacionales como MySQL, H2 y HSQLDB. Sin embargo, la cl\u00e1usula <code>LIMIT</code> no es un est\u00e1ndar SQL.</p> <p>Para cumplir con el est\u00e1ndar SQL, PostgreSQL soporta la cl\u00e1usula <code>FETCH</code> para omitir un cierto n\u00famero de filas y luego obtener un n\u00famero espec\u00edfico de filas.</p> <p>Tenga en cuenta que la cl\u00e1usula <code>FETCH</code> se introdujo como parte del est\u00e1ndar SQL en SQL:2008.</p> <p>A continuaci\u00f3n se ilustra la sintaxis de la cl\u00e1usula <code>FETCH</code> de PostgreSQL:</p> <pre><code>OFFSET row_to_skip { ROW | ROWS }\nFETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY\n</code></pre> <p>En esta sintaxis:</p> <p>En primer lugar, especifique el n\u00famero de filas que desea omitir (<code>row_to_skip</code>) despu\u00e9s de la palabra clave <code>OFFSET</code>. El inicio es un n\u00famero entero cero o positivo. Por defecto es 0, lo que significa que la consulta no se saltar\u00e1 ninguna fila.</p> <p>Si <code>row_to_skip</code> es mayor que el n\u00famero de filas de la tabla, la consulta no devolver\u00e1 ninguna fila.</p> <p>En segundo lugar, indique el n\u00famero de filas a recuperar (<code>row_count</code>) en la cl\u00e1usula <code>FETCH</code>. El <code>row_count</code> debe ser un entero 1 o mayor. El valor por defecto es 1.</p> <p>El <code>ROW</code> es el sin\u00f3nimo de <code>ROWS</code>, <code>FIRST</code> es el sin\u00f3nimo de <code>NEXT</code> as\u00ed que puedes usarlos indistintamente.</p> <p>Debido a que la tabla almacena las filas en un orden no especificado, siempre debe utilizar la cl\u00e1usula <code>FETCH</code> con la cl\u00e1usula <code>ORDER BY</code> para que el orden de las filas sea consistente.</p> <p>Note que la clausula <code>OFFSET</code> debe venir antes de la clausula <code>FETCH</code> en SQL:2008. Sin embargo, las cl\u00e1usulas <code>OFFSET</code> y <code>FETCH</code> pueden aparecer en cualquier orden en PostgreSQL.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/05.-FETCH/#fetch-vs-limit","title":"FETCH vs. LIMIT","text":"<p>La cl\u00e1usula <code>FETCH</code> es funcionalmente equivalente a la cl\u00e1usula <code>LIMIT</code>. Si planea hacer su aplicaci\u00f3n compatible con otros sistemas de bases de datos, deber\u00eda usar la cl\u00e1usula <code>FETCH</code> porque sigue el est\u00e1ndar SQL.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/05.-FETCH/#ejemplos-de-fetch-en-postgresql","title":"Ejemplos de FETCH en PostgreSQL","text":"<p>Usemos la tabla <code>film</code> en la base de datos de ejemplo para la demostraci\u00f3n.</p> <p></p> <p>The following query uses the <code>FETCH</code> clause to select the first film sorted by titles in ascending order:</p> <pre><code>SELECT\n    film_id,\n    title\nFROM\n    film\nORDER BY\n    title \nFETCH FIRST ROW ONLY;\n</code></pre> <p>Salida:</p> <pre><code> film_id |      title\n---------+------------------\n       1 | Academy Dinosaur\n(1 row)\n</code></pre> <p>Equivale a la siguiente consulta:</p> <pre><code>SELECT\n    film_id,\n    title\nFROM\n    film\nORDER BY\n    title \nFETCH FIRST 1 ROW ONLY;\n</code></pre> <p>La siguiente consulta utiliza la cl\u00e1usula <code>FETCH</code> para seleccionar las cinco primeras pel\u00edculas ordenadas por t\u00edtulos:</p> <pre><code>SELECT\n    film_id,\n    title\nFROM\n    film\nORDER BY\n    title \nFETCH FIRST 5 ROW ONLY;\n</code></pre> <p>Salida:</p> <pre><code> film_id |      title\n---------+------------------\n       1 | Academy Dinosaur\n       2 | Ace Goldfinger\n       3 | Adaptation Holes\n       4 | Affair Prejudice\n       5 | African Egg\n(5 rows)\n</code></pre> <p>La siguiente sentencia devuelve las cinco pel\u00edculas siguientes a las cinco primeras ordenadas por t\u00edtulos:</p> <pre><code>SELECT\n    film_id,\n    title\nFROM\n    film\nORDER BY\n    title \nOFFSET 5 ROWS \nFETCH FIRST 5 ROW ONLY; \n</code></pre> <p>Salida:</p> <pre><code> film_id |      title\n---------+------------------\n       6 | Agent Truman\n       7 | Airplane Sierra\n       8 | Airport Pollock\n       9 | Alabama Devil\n      10 | Aladdin Calendar\n(5 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/05.-FETCH/#resumen","title":"Resumen","text":"<ul> <li>Utilice la cl\u00e1usula <code>FETCH</code> de PostgreSQL para omitir un cierto n\u00famero de filas y recuperar un n\u00famero espec\u00edfico de filas de una consulta.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/","title":"06.-IN","text":"<p>El operador <code>IN</code> permite verificar si un valor coincide con alg\u00fan otro en una lista de valores.</p> <p>Aqu\u00ed est\u00e1 la sintaxis b\u00e1sica del operador \"IN\":</p> <pre><code>valor IN (valor1,valor2,...)\n</code></pre> <p>El operador \"IN\" devuelve verdadero si el \"valor\" es igual a cualquier valor de la lista, como \"valor1\" y \"valor2\".</p> <p>La lista de valores puede ser una lista de valores literales que incluyen n\u00fameros y cadenas.</p> <p>Adem\u00e1s de los valores literales, el operador \"IN\" tambi\u00e9n acepta una lista de valores devueltos por una consulta. </p> <p>Funcionalmente, el operador <code>IN</code> equivale a combinar m\u00faltiples expresiones booleanas con los operadores OR:</p> <pre><code>valor = valor1 OR valor = valor2 OR ...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#ejemplos-del-operador-in","title":"Ejemplos del operador IN","text":"<p>Usaremos la tabla <code>film</code> de la base de datos de muestra:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#uso-del-operador-in-de-postgresql-con-una-lista-de-numeros","title":"Uso del operador IN de PostgreSQL con una lista de n\u00fameros","text":"<p>El siguiente ejemplo utiliza el operador <code>IN</code> para recuperar informaci\u00f3n sobre la pel\u00edcula con id 1, 2 y 3:</p> <pre><code>SELECT\n  film_id, \n  title \nFROM\n  film \nWHERE\n  film_id in (1, 2, 3);Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code> film_id |      title\n---------+------------------\n       1 | Academy Dinosaur\n       2 | Ace Goldfinger\n       3 | Adaptation Holes\n(3 rows)\n</code></pre> <p>La siguiente sentencia utiliza los operadores igual (<code>=</code>) y <code>OR</code> en lugar del operador <code>IN</code>, lo que equivale a la consulta anterior:</p> <pre><code>SELECT \n  film_id, \n  title \nFROM \n  film \nWHERE \n  film_id = 1 \n  OR film_id = 2 \n  OR film_id = 3;\n</code></pre> <p>La consulta que utiliza el operador <code>IN</code> es m\u00e1s corta y m\u00e1s legible que la consulta que utiliza operadores iguales (<code>=</code>) y <code>OR</code>.</p> <p>Adem\u00e1s, PostgreSQL ejecuta la consulta con el operador <code>IN</code> mucho m\u00e1s r\u00e1pido que la misma consulta que utiliza una lista de operadores <code>OR</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#uso-del-operador-in-de-postgresql-con-una-lista-de-cadenas","title":"Uso del operador IN de PostgreSQL con una lista de cadenas","text":"<p>Utilizaremos la tabla <code>actor</code> de la base de datos de ejemplo:</p> <p></p> <p>El siguiente ejemplo utiliza el operador <code>IN</code> para encontrar los actores que tienen el apellido en la lista <code>'Allen'</code>, <code>'Chase'</code> y <code>'Davis'</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name\nFROM \n  actor \nWHERE \n  last_name IN ('Allen', 'Chase', 'Davis') \nORDER BY \n  last_name;\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Meryl      | Allen\n Cuba       | Allen\n Kim        | Allen\n Jon        | Chase\n Ed         | Chase\n Susan      | Davis\n Jennifer   | Davis\n Susan      | Davis\n(8 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#uso-del-operador-in-de-postgresql-con-una-lista-de-fechas","title":"Uso del operador IN de PostgreSQL con una lista de fechas","text":"<p>La siguiente sentencia utiliza el operador IN para encontrar pagos cuyas fechas de pago se encuentren en una lista de fechas: <code>2007-02-15</code> y <code>2007-02-16</code>:</p> <pre><code>SELECT \n  payment_id, \n  amount, \n  payment_date \nFROM \n  payment \nWHERE \n  payment_date::date IN ('2007-02-15', '2007-02-16');\n</code></pre> <p>Salida:</p> <pre><code>payment_id | amount |        payment_date\n------------+--------+----------------------------\n      17503 |   7.99 | 2007-02-15 22:25:46.996577\n      17504 |   1.99 | 2007-02-16 17:23:14.996577\n      17505 |   7.99 | 2007-02-16 22:41:45.996577\n      17512 |   4.99 | 2007-02-16 00:10:50.996577\n...\n</code></pre> <p>En este ejemplo, la columna <code>payment_date</code> tiene el tipo <code>timestamp</code> que consta de partes de fecha y hora.</p> <p>Para hacer coincidir los valores de la columna <code>payment_date</code> con una lista de fechas, debe convertirlos en valores de fecha que s\u00f3lo contengan la parte de fecha.</p> <p>Para ello, utilice el operador cast <code>::</code></p> <pre><code>payment_date::date\n</code></pre> <p>Por ejemplo, si el valor del timestamp es <code>2007-02-15 22:25:46.996577</code>, el operador cast <code>::</code> lo convertir\u00e1 a <code>2007-02-15</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#operador-not-in-de-postgresql","title":"Operador NOT IN de PostgreSQL","text":"<p>Para negar el operador <code>IN</code>, se utiliza el operador <code>NOT IN</code>. Esta es la sintaxis b\u00e1sica del operador <code>NOT IN</code>:</p> <pre><code>value NOT IN (value1, value2, ...)Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>El operador <code>NOT IN</code> devuelve <code>true</code> si el <code>value</code> no es igual a ning\u00fan valor de la lista como <code>value1</code> y <code>value2</code>; en caso contrario, el operador <code>NOT IN</code> devuelve <code>false</code>.</p> <p>El operador <code>NOT IN</code> equivale a una combinaci\u00f3n de varias expresiones booleanas con los operadores AND:</p> <pre><code>value &lt;&gt; value1 AND value &lt;&gt; value2 AND ...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#ejemplo-de-operador-not-in-de-postgresql","title":"Ejemplo de operador NOT IN de PostgreSQL","text":"<p>El siguiente ejemplo utiliza el operador <code>NOT IN</code> para recuperar pel\u00edculas cuyo id no sea 1, 2 o 3:</p> <pre><code>SELECT \n  film_id, \n  title \nFROM \n  film \nWHERE \n  film_id NOT IN (1, 2, 3) \nORDER BY \n  film_id;\n</code></pre> <p>Salida:</p> <pre><code> film_id |            title\n---------+-----------------------------\n       4 | Affair Prejudice\n       5 | African Egg\n       6 | Agent Truman\n       7 | Airplane Sierra\n       8 | Airport Pollock\n...\n</code></pre> <p>La siguiente consulta recupera el mismo conjunto de datos pero utiliza los operadores no igual (<code>&lt;&gt;</code>) y <code>AND</code>:</p> <pre><code>SELECT \n  film_id, \n  title \nFROM \n  film \nWHERE \n  film_id &lt;&gt; 1 \n  AND film_id &lt;&gt; 2 \n  AND film_id &lt;&gt; 3 \nORDER BY \n  film_id;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/06.-IN/#resumen","title":"Resumen","text":"<ul> <li>Utilice el operador <code>IN</code> para comprobar si un valor coincide con cualquier valor de una lista de valores.</li> <li>Utilice el operador <code>NOT</code> para negar el operador <code>IN</code>. </li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/","title":"07.-BETWEEN","text":"<p>El operador <code>BETWEEN</code> permite comprobar si un valor se encuentra dentro de un rango de valores.</p> <p>La sintaxis b\u00e1sica del operador <code>BETWEEN</code> es la siguiente:</p> <pre><code>value BETWEEN low AND high;\n</code></pre> <p>Si el <code>valor</code> es mayor o igual que el <code>valor bajo</code> y menor o igual que el <code>valor alto</code>, el operador <code>BETWEEN</code> devuelve <code>true</code>; en caso contrario, devuelve <code>false</code>.</p> <p>Puede reescribir el operador <code>BETWEEN</code> utilizando los operadores mayor que o igual ( <code>&gt;=</code>) y menor que o igual a ( <code>&lt;=</code>) y el operador l\u00f3gico AND:</p> <pre><code>value &gt;= low AND value &lt;= high\n</code></pre> <p>Si desea comprobar si un valor est\u00e1 fuera de un rango espec\u00edfico, puede utilizar el operador <code>NOT BETWEEN</code> de la siguiente manera:</p> <pre><code>value NOT BETWEEN low AND high\n</code></pre> <p>La siguiente expresi\u00f3n es equivalente a la expresi\u00f3n que utiliza los operadores <code>NOT BETWEEN</code>:</p> <pre><code>value &lt; low OR value &gt; high\n</code></pre> <p>En la pr\u00e1ctica, a menudo se utiliza el operador <code>BETWEEN</code> en la cl\u00e1usula WHERE de las sentencias SELECT, INSERT, UPDATE,y DELETE.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/#ejemplos-del-operador-between-de-postgresql","title":"Ejemplos del operador BETWEEN de PostgreSQL","text":"<p>Echemos un vistazo a la tabla <code>payment</code> de la base de datos de ejemplo.</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/#uso-del-operador-between-de-postgresql-con-numeros","title":"Uso del operador BETWEEN de PostgreSQL con n\u00fameros","text":"<p>La siguiente consulta utiliza el operador <code>BETWEEN</code> para recuperar pagos con <code>payment_id</code> entre <code>17510</code> y <code>17505</code>:</p> <pre><code>SELECT \n  payment_id, \n  amount \nFROM \n  payment \nWHERE \n  payment_id BETWEEN 17503 AND 17505 \nORDER BY \n  payment_id;\n</code></pre> <p>Salida:</p> <pre><code> payment_id | amount\n------------+--------\n      17503 |   7.99\n      17504 |   1.99\n      17505 |   7.99\n(3 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/#uso-del-ejemplo-not-between-de-postgresql","title":"Uso del ejemplo NOT BETWEEN de PostgreSQL","text":"<p>El siguiente ejemplo utiliza el operador <code>NOT BETWEEN</code> para encontrar pagos cuyo <code>payment_id</code> no est\u00e9 entre <code>17510</code> y <code>17505</code>:</p> <pre><code>SELECT \n  payment_id, \n  amount \nFROM \n  payment \nWHERE \n  payment_id NOT BETWEEN 17503 AND 17505 \nORDER BY \n  payment_id;\n</code></pre> <p>Salida:</p> <pre><code>payment_id | amount\n------------+--------\n      17506 |   2.99\n      17507 |   7.99\n      17508 |   5.99\n      17509 |   5.99\n      17510 |   5.99\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/#usando-el-between-de-postgresql-con-un-rango-de-fechas","title":"Usando el BETWEEN de PostgreSQL con un rango de fechas","text":"<p>Si desea comprobar un valor con respecto a un intervalo de fechas, utilice la fecha literal en formato ISO 8601, que es <code>YYYY-MM-DD</code>.</p> <p>El siguiente ejemplo utiliza el operador <code>BETWEEN</code> para buscar pagos cuyas fechas de pago est\u00e9n comprendidas entre el <code>2007-02-14</code> y el <code>2007-02-20</code> y cuyo importe sea superior a 10:</p> <pre><code>SELECT \n  payment_id, \n  amount, \n  payment_date \nFROM \n  payment \nWHERE \n  payment_date BETWEEN '2007-02-15' AND '2007-02-20' \n  AND amount &gt; 10 \nORDER BY \n  payment_date;\n</code></pre> <p>Salida:</p> <pre><code> customer_id | payment_id | amount |        payment_date\n-------------+------------+--------+----------------------------\n          33 |      18640 |  10.99 | 2007-02-15 08:14:59.996577\n         544 |      18272 |  10.99 | 2007-02-15 16:59:12.996577\n         516 |      18175 |  10.99 | 2007-02-16 13:20:28.996577\n         572 |      18367 |  10.99 | 2007-02-17 02:33:38.996577\n         260 |      19481 |  10.99 | 2007-02-17 16:37:30.996577\n         477 |      18035 |  10.99 | 2007-02-18 07:01:49.996577\n         221 |      19336 |  10.99 | 2007-02-19 09:18:28.996577\n(7 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/07.-BETWEEN/#resumen","title":"Resumen","text":"<ul> <li>Utilice el operador <code>BETWEEN</code> para comprobar si un valor se encuentra dentro de un rango determinado.</li> <li>Utilice el operador <code>NOT BETWEEN</code> para negar el operador <code>BETWEEN</code>.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/","title":"08.-LIKE","text":"<p>Supongamos que quiere encontrar a unos clientes, pero no recuerda exactamente sus nombres. Sin embargo, recuerda que empiezan por \"Jen\".</p> <p>\u00bfC\u00f3mo localiza a los clientes exactos en la base de datos? Puede identificar a los clientes en la tabla <code>cliente</code> examinando la columna nombre para ver si alg\u00fan valor empieza por <code>Jen</code>. Sin embargo, este proceso puede llevar mucho tiempo, sobre todo cuando la tabla <code>customer</code> tiene un gran n\u00famero de filas.</p> <p>Afortunadamente, puede utilizar el operador <code>LIKE</code> de PostgreSQL para hacer coincidir los nombres de pila de los clientes con una cadena utilizando la siguiente consulta:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE 'Jen%';\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Jennifer   | Davis\n Jennie     | Terry\n Jenny      | Castro\n(3 rows)\n</code></pre> <p>La cl\u00e1usula <code>WHERE</code> de la consulta contiene una expresi\u00f3n:</p> <pre><code>first_name LIKE 'Jen%'\n</code></pre> <p>Ta expresi\u00f3n est\u00e1 formada por el <code>nombre</code>, el operador <code>LIKE</code> y una cadena literal que contiene un signo de porcentaje <code>(%</code>). La cadena <code>'Jen%</code> se denomina patr\u00f3n.</p> <p>La consulta devuelve las filas cuyos valores de la columna <code>nombre</code> empiezan por <code>Jen</code> y van seguidos de cualquier secuencia de caracteres. Esta t\u00e9cnica se denomina comparaci\u00f3n de patrones.</p> <p>Se construye un patr\u00f3n combinando valores literales con caracteres comod\u00edn y utilizando el operador <code>LIKE</code> o <code>NOT LIKE</code> para encontrar las coincidencias.</p> <p>PostgreSQL ofrece dos comodines:</p> <ul> <li>Signo de porcentaje ( <code>%</code>) coincide con cualquier secuencia de cero o m\u00e1s caracteres.</li> <li>El gui\u00f3n bajo (<code>_</code>) coincide con cualquier car\u00e1cter.</li> </ul> <p>Esta es la sintaxis b\u00e1sica del operador <code>LIKE</code>:</p> <pre><code>value LIKE pattern\n</code></pre> <p>El operador <code>LIKE</code> devuelve <code>true</code> si el <code>value</code> coincide con el <code>pattern</code>. Para negar el operador <code>LIKE</code>, utilice el operador <code>NOT</code> de la siguiente manera:</p> <pre><code>value NOT LIKE pattern\n</code></pre> <p>El operador <code>NOT LIKE</code> devuelve <code>true</code> cuando el <code>value</code> no coincide con el <code>pattern</code>.</p> <p>Si el patr\u00f3n no contiene ning\u00fan car\u00e1cter comod\u00edn, el operador <code>LIKE</code> se comporta como el operador igual (<code>=</code>).</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#ejemplos-del-operador-like-en-postgresql","title":"Ejemplos del operador LIKE en PostgreSQL","text":"<p>Veamos algunos ejemplos de uso del operador `LIKE</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#ejemplos-basicos-del-operador-like","title":"Ejemplos b\u00e1sicos del operador LIKE","text":"<p>La siguiente sentencia utiliza el operador <code>LIKE</code> con un patr\u00f3n que no tiene caracteres comod\u00edn:</p> <pre><code>SELECT 'Apple' LIKE 'Apple' AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>En este ejemplo, el operador <code>LIKE</code> se comporta como el operador igual a (<code>=</code>). La consulta devuelve <code>true</code> porque '<code>Apple' = 'Apple'</code> es <code>true</code>.</p> <p>El siguiente ejemplo utiliza el operador <code>LIKE</code> para buscar cualquier cadena que empiece por la letra <code>A</code>:</p> <pre><code>SELECT 'Apple' LIKE 'A%' AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n t\n(1 row)\n</code></pre> <p>La consulta devuelve verdadero porque la cadena <code>'Apple'</code> empieza por la letra <code>'A'</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#uso-del-operador-like-con-datos-de-tabla","title":"Uso del operador LIKE con datos de tabla","text":"<p>Utilizaremos la tabla <code>customer</code> de la base de datos de ejemplo:</p> <p></p> <p>El siguiente ejemplo utiliza el operador <code>LIKE</code> para buscar clientes cuyo nombre contenga la cadena <code>er</code> :</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE '%er%' \nORDER BY \n  first_name;\n</code></pre> <p>Salida:</p> <pre><code>first_name  |  last_name\n-------------+-------------\n Albert      | Crouse\n Alberto     | Henning\n Alexander   | Fennell\n Amber       | Dixon\n Bernard     | Colby\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#utilizar-el-operador-like-con-un-patron-que-contenga-ambos-comodines","title":"Utilizar el operador LIKE con un patr\u00f3n que contenga ambos comodines","text":"<p>El siguiente ejemplo utiliza el operador <code>LIKE</code> con un patr\u00f3n que contiene los comodines porcentaje ( <code>%</code>) y gui\u00f3n bajo (<code>_</code>):</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE '_her%' \nORDER BY \n  first_name;\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Cheryl     | Murphy\n Sherri     | Rhodes\n Sherry     | Marshall\n Theresa    | Watson\n(4 rows)\n</code></pre> <p>El patr\u00f3n <code>_her%</code> coincide con cualquier cadena que cumpla las siguientes condiciones:</p> <ul> <li>El primer car\u00e1cter puede ser cualquier cosa.</li> <li>Los caracteres siguientes deben ser \"ella\".</li> <li>Puede haber cualquier n\u00famero de caracteres (incluido cero) despu\u00e9s de \"ella\".</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#ejemplos-de-not-like-en-postgresql","title":"Ejemplos de NOT LIKE en PostgreSQL","text":"<p>La siguiente consulta utiliza el operador <code>NOT LIKE</code> para encontrar clientes cuyo nombre no empiece por <code>Jen</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name NOT LIKE 'Jen%' \nORDER BY \n  first_name;\n</code></pre> <p>Salida:</p> <pre><code> first_name  |  last_name\n-------------+--------------\n Aaron       | Selby\n Adam        | Gooch\n Adrian      | Clary\n Agnes       | Bishop\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#extensiones-postgresql-del-operador-like","title":"Extensiones PostgreSQL del operador LIKE","text":"<p>El operador <code>ILIKE</code> de PostgreSQL, que es similar al operador <code>LIKE</code>, pero permite coincidencias insensibles a may\u00fasculas/min\u00fasculas. Por ejemplo:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name ILIKE 'BAR%';\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Barbara    | Jones\n Barry      | Lovelace\n(2 rows)\n</code></pre> <p>En este ejemplo, el patr\u00f3n <code>BAR%</code> coincide con cualquier cadena que empiece por <code>BAR</code>, <code>Bar</code>, <code>BaR</code>, etc. Si utiliza el operador <code>LIKE</code> en su lugar, la consulta no devolver\u00e1 ninguna fila:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name LIKE 'BAR%';\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n(0 rows)\n</code></pre> <p>PostgreSQL tambi\u00e9n proporciona algunos operadores que reflejan la funcionalidad de <code>LIKE</code>, <code>NOT LIKE</code>, <code>ILIKE</code>, <code>NOT ILIKE</code>, como se muestra en la siguiente tabla:</p> Operador Equivalente a ~~ LIKE ~~* ILIKE !~~ NOT LIKE !~~* NOT ILIKE <p>Por ejemplo, la siguiente sentencia utiliza el operador <code>~~</code> para buscar un cliente cuyo nombre empiece por la cadena <code>Dar</code>:</p> <pre><code>SELECT \n  first_name, \n  last_name \nFROM \n  customer \nWHERE \n  first_name ~~ 'Dar%' \nORDER BY \n  first_name;\n</code></pre> <p>Salida:</p> <pre><code> first_name | last_name\n------------+-----------\n Darlene    | Rose\n Darrell    | Power\n Darren     | Windham\n Darryl     | Ashcraft\n Daryl      | Larue\n(5 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#operador-like-de-postgresql-con-opcion-escape","title":"Operador LIKE de PostgreSQL con opci\u00f3n ESCAPE","text":"<p>A veces, los datos que desea comparar contienen los caracteres comod\u00edn <code>%</code> y <code>_</code>. Por ejemplo:</p> <pre><code>The rents are now 10% higher than last month\nThe new film will have _ in the titleCode language: JavaScript (javascript)\n</code></pre> <p>Para indicar al operador <code>LIKE</code> que trate los caracteres comod\u00edn <code>%</code> y <code>_</code> como caracteres literales normales, puede utilizar la opci\u00f3n <code>ESCAPE</code> en el operador <code>LIKE</code>:</p> <pre><code>string LIKE pattern ESCAPE escape_character;\n</code></pre> <p>Vamos a crear una tabla simple para demostraci\u00f3n:</p> <pre><code>CREATE TABLE t(\n   message text\n);\n\nINSERT INTO t(message) \nVALUES('The rents are now 10% higher than last month'), \n      ('The new film will have _ in the title');\n\nSELECT message FROM t;\n</code></pre> <p>Ten en cuenta que aprender\u00e1s a crear una tabla y a insertar datos en ella en los pr\u00f3ximos tutoriales.</p> <p>Salida:</p> <pre><code>                   message\n----------------------------------------------\n The rents are now 10% higher than last month\n The new film will have _ in the title\n(2 rows)Code language: JavaScript (javascript)\n</code></pre> <p>La siguiente sentencia utiliza el operador <code>LIKE</code> con la opci\u00f3n <code>ESCAPE</code> para tratar el <code>%</code> seguido del n\u00famero <code>10</code> como un car\u00e1cter regular:</p> <pre><code>SELECT * FROM t \nWHERE message LIKE '%10$%%' ESCAPE '$';\n</code></pre> <p>Salida:</p> <pre><code>                   message\n----------------------------------------------\n The rents are now 10% higher than last month\n(1 row)\n</code></pre> <p>En el patr\u00f3n <code>%10$%%</code>, el primer y el \u00faltimo <code>%</code> son los caracteres comod\u00edn, mientras que el <code>%</code> que aparece despu\u00e9s del car\u00e1cter de escape <code>$</code> es un car\u00e1cter regular.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/08.-LIKE/#resumen","title":"Resumen","text":"<ul> <li>Utilice el operador <code>LIKE</code> para hacer coincidir datos por patrones.</li> <li>Utilice el operador <code>NOT LIKE</code> para negar el operador <code>LIKE</code>.</li> <li>Use el comod\u00edn <code>%</code> para coincidir con cero o m\u00e1s caracteres.</li> <li>Utilice el comod\u00edn <code>_</code> para buscar un \u00fanico car\u00e1cter.</li> <li>Utilice la opci\u00f3n <code>ESCAPE</code> para especificar el car\u00e1cter de escape.</li> <li>Utilice el operador <code>ILIKE</code> para distinguir entre may\u00fasculas y min\u00fasculas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/","title":"09.-IS NULL","text":"<p>En el mundo de las bases de datos, NULL significa que falta informaci\u00f3n o que no es aplicable. NULL no es un valor, por lo tanto, no se puede comparar con otros valores como n\u00fameros o cadenas.</p> <p>La comparaci\u00f3n de NULL con un valor siempre dar\u00e1 como resultado NULL. Adem\u00e1s, NULL no es igual a NULL por lo que la siguiente expresi\u00f3n devuelve NULL:</p> <pre><code>SELECT null = null AS result;\n</code></pre> <p>Salida:</p> <pre><code> result\n--------\n null\n(1 row)Code language: JavaScript (javascript)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/#operador-is-null","title":"Operador IS NULL","text":"<p>Para comprobar si un valor es NULL o no, no se pueden utilizar los operadores igual a (<code>=</code>) o no igual a (<code>&lt;&gt;</code>). En su lugar, se utiliza el operador <code>IS NULL</code>.</p> <p>Esta es la sintaxis b\u00e1sica del operador <code>IS NULL</code>:</p> <pre><code>value IS NULL\n</code></pre> <p>El operador <code>IS NULL</code> devuelve NULL si el valor es NULL o false en caso contrario.</p> <p>Para negar el operador <code>IS NULL</code>, se utiliza el operador <code>IS NOT NULL</code>:</p> <pre><code>value IS NOT NULL\n</code></pre> <p>El operador <code>IS NOT NULL</code> devuelve verdadero si el valor no es nulo o falso en caso contrario.</p> <p>Para tratar con NULL en la ordenaci\u00f3n, consulte el tutorial ORDER BY).</p> <p>PostgreSQL ofrece algunas funciones que tratan con NULL incluyendo NULLIF, ISNULL, y COALESCE.</p> <p>Para asegurar una columna que no contiene NULL, puede utilizar la restricci\u00f3n NOT NULL.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/#ejemplos-del-operador-is-null-de-postgresql","title":"Ejemplos del operador IS NULL de PostgreSQL","text":"<p>Utilizaremos la tabla <code>address</code> de la base de datos de ejemplo:</p> <p></p> <p>El <code>psql</code> muestra <code>NULL</code> como una cadena vac\u00eda por defecto. Para cambiar la forma en que <code>psql</code> muestra el null en la terminal, puede utilizar el comando <code>\\pset null null</code>. Mostrar\u00e1 NULL como null.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/#ejemplo-basico-del-operador-is-null","title":"Ejemplo b\u00e1sico del operador IS NULL","text":"<p>El siguiente ejemplo utiliza el operador <code>IS NULL</code> para encontrar las direcciones de la tabla <code>address</code> que la columna <code>address2</code> contiene <code>NULL</code>:</p> <pre><code>SELECT \n  address, \n  address2 \nFROM \n  address \nWHERE \n  address2 IS NULL;\n</code></pre> <p>Salida:</p> <pre><code>       address        | address2\n----------------------+----------\n 47 MySakila Drive    | null\n 28 MySQL Boulevard   | null\n 23 Workhaven Lane    | null\n 1411 Lillydale Drive | null\n(4 rows)Code language: JavaScript (javascript)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/#ejemplo-de-uso-del-operador-is-not-null","title":"Ejemplo de uso del operador IS NOT NULL","text":"<p>El siguiente ejemplo utiliza el operador <code>IS NOT NULL</code> para recuperar la direcci\u00f3n que tiene la direcci\u00f3n2 no nula:</p> <pre><code>SELECT \n  address, \n  address2 \nFROM \n  address \nWHERE \n  address2 IS NOT NULL;\n</code></pre> <p>Salida:</p> <pre><code>                address                 | address2\n----------------------------------------+----------\n 1913 Hanoi Way                         |\n 1121 Loja Avenue                       |\n 692 Joliet Street                      |\n 1566 Inegl Manor                       |\n</code></pre> <p>F\u00edjate en que la <code>direcci\u00f3n2</code> est\u00e1 vac\u00eda, no es NULL. Este es un buen ejemplo de una mala pr\u00e1ctica cuando se trata de almacenar cadenas vac\u00edas y NULL en la misma columna.</p> <p>Para arreglarlo, puedes usar la sentencia <code>UPDATE</code> para cambiar las cadenas vac\u00edas a NULL en la columna <code>address2</code>, lo cual aprender\u00e1s en el tutorial UPDATE.</p>"},{"location":"02.-Tutorial%20Avanzado/02.-Filtrado%20de%20datos/09.-IS%20NULL/#resumen","title":"Resumen","text":"<ul> <li>En bases de datos, NULL significa informaci\u00f3n faltante o no aplicable.</li> <li>Utilice el operador <code>IS NULL</code> para comprobar si un valor es NULL o no.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/","title":"01.-Joins","text":"<p>PostgreSQL join se utiliza para combinar columnas de una self-join o m\u00e1s tablas bas\u00e1ndose en los valores de las columnas comunes entre las tablas relacionadas. Las columnas comunes suelen ser las columnas de clave primaria de la primera tabla y las columnas de clave externa de la segunda tabla.</p> <p>PostgreSQL soporta inner join, left join, right join, full outer join, cross join, natural join, y un tipo especial de join llamado self-join.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#configuracion-de-tablas-de-ejemplo","title":"Configuraci\u00f3n de tablas de ejemplo","text":"<p>Suponga que tiene dos tablas llamadas <code>cesta_a</code> y <code>cesta_b</code> que almacenan frutas:</p> <pre><code>CREATE TABLE basket_a (\n    a INT PRIMARY KEY,\n    fruit_a VARCHAR (100) NOT NULL\n);\n\nCREATE TABLE basket_b (\n    b INT PRIMARY KEY,\n    fruit_b VARCHAR (100) NOT NULL\n);\n\nINSERT INTO basket_a (a, fruit_a)\nVALUES\n    (1, 'Apple'),\n    (2, 'Orange'),\n    (3, 'Banana'),\n    (4, 'Cucumber');\n\nINSERT INTO basket_b (b, fruit_b)\nVALUES\n    (1, 'Orange'),\n    (2, 'Apple'),\n    (3, 'Watermelon'),\n    (4, 'Pear');\n</code></pre> <p>Las tablas tienen algunas frutas comunes como <code>manzana</code> y <code>naranja</code>.</p> <p>La siguiente sentencia devuelve datos de la tabla <code>basket_a</code>:</p> <pre><code> a | fruit_a\n---+----------\n 1 | Apple\n 2 | Orange\n 3 | Banana\n 4 | Cucumber\n(4 rows)\n</code></pre> <p>La siguiente sentencia devuelve datos de la tabla <code>basket_b</code>:</p> <pre><code> b |  fruit_b\n---+------------\n 1 | Orange\n 2 | Apple\n 3 | Watermelon\n 4 | Pear\n(4 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#union-interna-postgresql","title":"Uni\u00f3n interna PostgreSQL","text":"<p>La siguiente sentencia une la primera tabla (<code>basket_a</code>) con la segunda tabla (<code>basket_b</code>) comparando los valores de las columnas <code>fruit_a</code> y <code>fruit_b</code>:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nINNER JOIN basket_b\n    ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code> a | fruit_a | b | fruit_b\n---+---------+---+---------\n 1 | Apple   | 2 | Apple\n 2 | Orange  | 1 | Orange\n(2 rows)\n</code></pre> <p>La uni\u00f3n interna examina cada fila de la primera tabla (<code>cesta_a</code>). Compara el valor de la columna <code>fruta_a</code> con el valor de la columna <code>fruta_b</code> de cada fila de la segunda tabla (<code>cesta_b</code>). Si estos valores son iguales, la uni\u00f3n interna crea una nueva fila que contiene columnas de ambas tablas y a\u00f1ade esta nueva fila al conjunto de resultados.</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n interna:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-left-join","title":"PostgreSQL left join","text":"<p>La siguiente sentencia utiliza la cl\u00e1usula left join para unir la tabla <code>basket_a</code> con la tabla <code>basket_b</code>.  En el contexto de left join, la primera tabla se denomina tabla izquierda y la segunda tabla se denomina tabla derecha.</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nLEFT JOIN basket_b \n   ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code> a | fruit_a  |  b   | fruit_b\n---+----------+------+---------\n 1 | Apple    |    2 | Apple\n 2 | Orange   |    1 | Orange\n 3 | Banana   | null | null\n 4 | Cucumber | null | null\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>La uni\u00f3n izquierda comienza seleccionando datos de la tabla izquierda. Compara los valores de la columna fruta_a con los valores de la columna fruta_b de la tabla cesta_b.</p> <p>Si estos valores son iguales, la uni\u00f3n izquierda crea una nueva fila que contiene columnas de ambas tablas y a\u00f1ade esta nueva fila al conjunto de resultados.  (v\u00e9ase la fila n\u00ba 1 y n\u00ba 2 en el conjunto de resultados).</p> <p>En caso de que los valores no sean iguales, la uni\u00f3n izquierda tambi\u00e9n crea una nueva fila que contiene columnas de ambas tablas y la a\u00f1ade al conjunto de resultados.  Sin embargo, rellena las columnas de la tabla derecha (<code>basket_b</code>) con null. (v\u00e9anse las filas n\u00ba 3 y 4 del conjunto de resultados).</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n izquierda:</p> <p></p> <p>Para seleccionar filas de la tabla izquierda que no tienen filas coincidentes en la tabla derecha, utilice la uni\u00f3n izquierda con una cl\u00e1usula <code>WHERE</code>. Por ejemplo:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nLEFT JOIN basket_b \n    ON fruit_a = fruit_b\nWHERE b IS NULL;\n</code></pre> <p>La salida es:</p> <pre><code> a | fruit_a  |  b   | fruit_b\n---+----------+------+---------\n 3 | Banana   | null | null\n 4 | Cucumber | null | null\n(2 rows)\nCode language: JavaScript (javascript)\n</code></pre> <p>Tenga en cuenta que el <code>LEFT JOIN</code> es lo mismo que el <code>LEFT OUTER JOIN</code>, por lo que puede utilizarlos indistintamente.</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n izquierda que devuelve filas de la tabla izquierda que no tienen filas coincidentes de la tabla derecha:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-right-join","title":"PostgreSQL right join","text":"<p>El right join es una versi\u00f3n invertida del left join. El right join comienza seleccionando datos de la tabla derecha. Compara cada valor de la columna fruit_b de cada fila de la tabla derecha con cada valor de la columna fruit_a de cada fila de la tabla fruit_a.</p> <p>Si estos valores son iguales, la uni\u00f3n a la derecha crea una nueva fila que contiene columnas de ambas tablas.</p> <p>En caso de que estos valores no sean iguales, la uni\u00f3n a la derecha tambi\u00e9n crea una nueva fila que contiene columnas de ambas tablas. Sin embargo, rellena las columnas de la tabla izquierda con NULL.</p> <p>La siguiente sentencia utiliza la uni\u00f3n a la derecha para unir la tabla <code>cesta_a</code> con la tabla <code>cesta_b</code>:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nRIGHT JOIN basket_b ON fruit_a = fruit_b;\n</code></pre> <p>Here is the output:</p> <pre><code>  a   | fruit_a | b |  fruit_b\n------+---------+---+------------\n    2 | Orange  | 1 | Orange\n    1 | Apple   | 2 | Apple\n null | null    | 3 | Watermelon\n null | null    | 4 | Pear\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>The following Venn diagram illustrates the right join:</p> <p></p> <p>Similarly, you can get rows from the right table that do not have matching rows from the left table by adding a <code>WHERE</code> clause as follows:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nRIGHT JOIN basket_b \n   ON fruit_a = fruit_b\nWHERE a IS NULL;\n</code></pre> <p>Salida:</p> <pre><code>  a   | fruit_a | b |  fruit_b\n------+---------+---+------------\n null | null    | 3 | Watermelon\n null | null    | 4 | Pear\n(2 rows)Code language: JavaScript (javascript)\n</code></pre> <p>The <code>RIGHT JOIN</code> and <code>RIGHT OUTER JOIN</code> are the same therefore you can use them interchangeably.</p> <p>The following Venn diagram illustrates the right join that returns rows  from the right table that do not have matching rows in the left table:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-full-outer-join","title":"PostgreSQL full outer join","text":"<p>El full outer join o full join devuelve un conjunto de resultados que contiene todas las filas de las tablas izquierda y derecha, con las filas coincidentes de ambos lados si est\u00e1n disponibles.  En caso de que no haya ninguna coincidencia, las columnas de la tabla se rellenar\u00e1n con NULL.</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nFULL OUTER JOIN basket_b \n    ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code>  a   | fruit_a  |  b   |  fruit_b\n------+----------+------+------------\n    1 | Apple    |    2 | Apple\n    2 | Orange   |    1 | Orange\n    3 | Banana   | null | null\n    4 | Cucumber | null | null\n null | null     |    3 | Watermelon\n null | null     |    4 | Pear\n(6 rows)\nCode language: JavaScript (javascript)\n</code></pre> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n externa completa:</p> <p></p> <p>Para devolver filas en una tabla que no tienen filas coincidentes en la otra, se utiliza la uni\u00f3n completa con una cl\u00e1usula <code>WHERE</code> como \u00e9sta:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nFULL JOIN basket_b \n   ON fruit_a = fruit_b\nWHERE a IS NULL OR b IS NULL;\n</code></pre> <p>He aqu\u00ed el resultado:</p> <pre><code>  a   | fruit_a  |  b   |  fruit_b\n------+----------+------+------------\n    3 | Banana   | null | null\n    4 | Cucumber | null | null\n null | null     |    3 | Watermelon\n null | null     |    4 | Pear\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n externa completa que devuelve filas de una tabla que no tienen las filas correspondientes en la otra tabla:</p> <p></p> <p>La siguiente imagen muestra todas las uniones PostgreSQL que hemos discutido hasta ahora con la sintaxis detallada:</p> <p></p> <p>La siguiente imagen muestra todas las uniones PostgreSQL que hemos discutido hasta ahora con la sintaxis detallada:</p> <pre><code>CREATE TABLE basket_a (\n    a INT PRIMARY KEY,\n    fruit_a VARCHAR (100) NOT NULL\n);\n\nCREATE TABLE basket_b (\n    b INT PRIMARY KEY,\n    fruit_b VARCHAR (100) NOT NULL\n);\n\nINSERT INTO basket_a (a, fruit_a)\nVALUES\n    (1, 'Apple'),\n    (2, 'Orange'),\n    (3, 'Banana'),\n    (4, 'Cucumber');\n\nINSERT INTO basket_b (b, fruit_b)\nVALUES\n    (1, 'Orange'),\n    (2, 'Apple'),\n    (3, 'Watermelon'),\n    (4, 'Pear');\n</code></pre> <p>Las tablas tienen algunas frutas comunes como <code>manzana</code> y <code>naranja</code>.</p> <p>La siguiente sentencia devuelve datos de la tabla <code>basket_a</code>:</p> <pre><code> a | fruit_a\n---+----------\n 1 | Apple\n 2 | Orange\n 3 | Banana\n 4 | Cucumber\n(4 rows)\n</code></pre> <p>La siguiente sentencia devuelve datos de la tabla <code>basket_b</code>:</p> <pre><code> b |  fruit_b\n---+------------\n 1 | Orange\n 2 | Apple\n 3 | Watermelon\n 4 | Pear\n(4 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-inner-join","title":"PostgreSQL inner join","text":"<p>La siguiente sentencia une la primera tabla (<code>cesta_a</code>) con la segunda tabla (<code>cesta_b</code>) comparando los valores de las columnas <code>fruta_a</code> y <code>fruta_b</code>:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nINNER JOIN basket_b\n    ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code> a | fruit_a | b | fruit_b\n---+---------+---+---------\n 1 | Apple   | 2 | Apple\n 2 | Orange  | 1 | Orange\n(2 rows)\n</code></pre> <p>La uni\u00f3n interna examina cada fila de la primera tabla (<code>cesta_a</code>). Compara el valor de la columna <code>fruta_a</code> con el valor de la columna <code>fruta_b</code> de cada fila de la segunda tabla (<code>cesta_b</code>). Si estos valores son iguales, la uni\u00f3n interna crea una nueva fila que contiene columnas de ambas tablas y a\u00f1ade esta nueva fila al conjunto de resultados.</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n interna:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-left-join_1","title":"PostgreSQL left join","text":"<p>La siguiente sentencia utiliza la cl\u00e1usula left join para unir la tabla <code>basket_a</code> con la tabla <code>basket_b</code>.  En el contexto de left join, la primera tabla se denomina tabla izquierda y la segunda tabla se denomina tabla derecha.</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nLEFT JOIN basket_b \n   ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code> a | fruit_a  |  b   | fruit_b\n---+----------+------+---------\n 1 | Apple    |    2 | Apple\n 2 | Orange   |    1 | Orange\n 3 | Banana   | null | null\n 4 | Cucumber | null | null\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>La uni\u00f3n izquierda comienza seleccionando datos de la tabla izquierda. Compara los valores de la columna fruta_a con los valores de la columna fruta_b de la tabla cesta_b.</p> <p>Si estos valores son iguales, la uni\u00f3n izquierda crea una nueva fila que contiene columnas de ambas tablas y a\u00f1ade esta nueva fila al conjunto de resultados.  (v\u00e9ase la fila n\u00ba 1 y n\u00ba 2 en el conjunto de resultados).</p> <p>En caso de que los valores no sean iguales, la uni\u00f3n izquierda tambi\u00e9n crea una nueva fila que contiene columnas de ambas tablas y la a\u00f1ade al conjunto de resultados.  Sin embargo, rellena las columnas de la tabla derecha (<code>basket_b</code>) con null. (v\u00e9anse las filas n\u00ba 3 y 4 del conjunto de resultados).</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n izquierda:</p> <p></p> <p>Para seleccionar filas de la tabla izquierda que no tienen filas coincidentes en la tabla derecha, utilice la uni\u00f3n izquierda con una cl\u00e1usula <code>WHERE</code>. Por ejemplo:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nLEFT JOIN basket_b \n    ON fruit_a = fruit_b\nWHERE b IS NULL;\n</code></pre> <p>La salida es:</p> <pre><code> a | fruit_a  |  b   | fruit_b\n---+----------+------+---------\n 3 | Banana   | null | null\n 4 | Cucumber | null | null\n(2 rows)\n</code></pre> <p>Tenga en cuenta que el <code>LEFT JOIN</code> es lo mismo que el <code>LEFT OUTER JOIN</code>, por lo que puede utilizarlos indistintamente.</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n izquierda que devuelve filas de la tabla izquierda que no tienen filas coincidentes de la tabla derecha:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-right-join_1","title":"PostgreSQL right join","text":"<p>El right join es una versi\u00f3n invertida del left join. El right join comienza seleccionando datos de la tabla derecha. Compara cada valor de la columna fruit_b de cada fila de la tabla derecha con cada valor de la columna fruit_a de cada fila de la tabla fruit_a.</p> <p>Si estos valores son iguales, la uni\u00f3n a la derecha crea una nueva fila que contiene columnas de ambas tablas.</p> <p>En caso de que estos valores no sean iguales, la uni\u00f3n a la derecha tambi\u00e9n crea una nueva fila que contiene columnas de ambas tablas. Sin embargo, rellena las columnas de la tabla izquierda con NULL.</p> <p>La siguiente sentencia utiliza la uni\u00f3n a la derecha para unir la tabla <code>cesta_a</code> con la tabla <code>cesta_b</code>:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nRIGHT JOIN basket_b ON fruit_a = fruit_b;\n</code></pre> <p>Este es el resultado:</p> <pre><code>  a   | fruit_a | b |  fruit_b\n------+---------+---+------------\n    2 | Orange  | 1 | Orange\n    1 | Apple   | 2 | Apple\n null | null    | 3 | Watermelon\n null | null    | 4 | Pear\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n correcta:</p> <p></p> <p>Del mismo modo, puede obtener filas de la tabla derecha que no tengan filas coincidentes de la tabla izquierda a\u00f1adiendo una cl\u00e1usula <code>WHERE</code> como se indica a continuaci\u00f3n:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nRIGHT JOIN basket_b \n   ON fruit_a = fruit_b\nWHERE a IS NULL;\n</code></pre> <p>Salida:</p> <pre><code>  a   | fruit_a | b |  fruit_b\n------+---------+---+------------\n null | null    | 3 | Watermelon\n null | null    | 4 | Pear\n(2 rows)Code language: JavaScript (javascript)\n</code></pre> <p>El <code>RIGHT JOIN</code> y el <code>RIGHT OUTER JOIN</code> son lo mismo, por lo que puede utilizarlos indistintamente.</p> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n derecha que devuelve filas de la tabla derecha que no tienen filas coincidentes en la tabla izquierda:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/01.-Joins/#postgresql-full-outer-join_1","title":"PostgreSQL full outer join","text":"<p>El full outer join o full join devuelve un conjunto de resultados que contiene todas las filas de las tablas izquierda y derecha, con las filas coincidentes de ambos lados si est\u00e1n disponibles.  En caso de que no haya ninguna coincidencia, las columnas de la tabla se rellenar\u00e1n con NULL.</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nFULL OUTER JOIN basket_b \n    ON fruit_a = fruit_b;\n</code></pre> <p>Salida:</p> <pre><code>  a   | fruit_a  |  b   |  fruit_b\n------+----------+------+------------\n    1 | Apple    |    2 | Apple\n    2 | Orange   |    1 | Orange\n    3 | Banana   | null | null\n    4 | Cucumber | null | null\n null | null     |    3 | Watermelon\n null | null     |    4 | Pear\n(6 rows)\nCode language: JavaScript (javascript)\n</code></pre> <p>The following Venn diagram illustrates the full outer join:</p> <p></p> <p>Para devolver filas en una tabla que no tienen filas coincidentes en la otra, se utiliza la uni\u00f3n completa con una cl\u00e1usula <code>WHERE</code> como \u00e9sta:</p> <pre><code>SELECT\n    a,\n    fruit_a,\n    b,\n    fruit_b\nFROM\n    basket_a\nFULL JOIN basket_b \n   ON fruit_a = fruit_b\nWHERE a IS NULL OR b IS NULL;\n</code></pre> <p>He aqu\u00ed el resultado:</p> <pre><code>  a   | fruit_a  |  b   |  fruit_b\n------+----------+------+------------\n    3 | Banana   | null | null\n    4 | Cucumber | null | null\n null | null     |    3 | Watermelon\n null | null     |    4 | Pear\n(4 rows)Code language: JavaScript (javascript)\n</code></pre> <p>El siguiente diagrama de Venn ilustra la uni\u00f3n externa completa que devuelve filas de una tabla que no tienen las filas correspondientes en la otra tabla:</p> <p></p> <p>La siguiente imagen muestra todas las uniones PostgreSQL que hemos discutido hasta ahora con la sintaxis detallada:</p> <p>En este tutorial, ha aprendido a utilizar varios tipos de uniones PostgreSQL para combinar datos de m\u00faltiples tablas relacionadas.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/","title":"02.-Alias de tablas","text":"<p>Un alias de tabla es una funci\u00f3n de SQL que permite asignar un nombre temporal a una tabla durante la ejecuci\u00f3n de una consulta.</p> <p>A continuaci\u00f3n se ilustra la sintaxis para definir un alias de tabla:</p> <pre><code>table_name AS alias_name\n</code></pre> <p>En esta sintaxis</p> <ul> <li><code>nombre_tabla</code>: Especifique el nombre de la tabla a la que desea dar un alias.</li> <li><code>nombre_alias</code>: Indique el alias de la tabla.</li> </ul> <p>Al igual que alias de columna, la palabra clave <code>AS</code> es opcional, lo que significa que puede omitirla de la siguiente manera:</p> <pre><code>table_name alias_name\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/#ejemplos-de-alias-de-tablas-postgresql","title":"Ejemplos de alias de tablas PostgreSQL","text":"<p>Veamos algunos ejemplos de uso de alias de tablas.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/#ejemplo-basico-de-alias-de-tabla-postgresql","title":"Ejemplo b\u00e1sico de alias de tabla PostgreSQL","text":"<p>El siguiente ejemplo utiliza un alias de tabla para recuperar cinco t\u00edtulos de la tabla <code>film</code>:</p> <pre><code>SELECT f.title\nFROM film AS f\nORDER BY f.title\nLIMIT 5;Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code>      title\n------------------\n Academy Dinosaur\n Ace Goldfinger\n Adaptation Holes\n Affair Prejudice\n African Egg\n(5 rows)\n</code></pre> <p>En este ejemplo, asignamos a la tabla <code>film</code> un alias <code>f</code> y utilizamos el alias de la tabla para calificar completamente la columna <code>title</code>.</p> <p>Dado que la palabra clave <code>AS</code> es opcional, puede eliminarla de la siguiente manera:</p> <pre><code>SELECT f.title\nFROM film f\nORDER BY f.title\nLIMIT 5;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/#uso-de-alias-de-tabla-en-clausulas-join","title":"Uso de alias de tabla en cl\u00e1usulas join","text":"<p>Normalmente, se utilizan alias de tabla en una consulta que tiene una cl\u00e1usula join para recuperar datos de varias tablas relacionadas que comparten el mismo nombre de columna.</p> <p>Si utiliza el mismo nombre de columna procedente de varias tablas en la misma consulta sin cualificarlas completamente, obtendr\u00e1 un error.</p> <p>Para evitar este error, puede calificar las columnas utilizando la siguiente sintaxis:</p> <pre><code>table_name.column_name\n</code></pre> <p>Si la tabla tiene un alias, puede calificar su columna utilizando el alias:</p> <pre><code>alias.column_name\n</code></pre> <p>Por ejemplo, la siguiente consulta utiliza una cl\u00e1usula <code>INNER JOIN</code> para recuperar datos de las tablas <code>customer</code> y <code>payment</code>:</p> <pre><code>SELECT \n  c.customer_id, \n  c.first_name, \n  p.amount, \n  p.payment_date \nFROM \n  customer c \n  INNER JOIN payment p ON p.customer_id = c.customer_id \nORDER BY \n  p.payment_date DESC;Code language: SQL (Structured Query Language) (sql)\n</code></pre> <p>Salida:</p> <pre><code> customer_id | first_name  | amount |        payment_date\n-------------+-------------+--------+----------------------------\n          94 | Norma       |   4.99 | 2007-05-14 13:44:29.996577\n         264 | Gwendolyn   |   2.99 | 2007-05-14 13:44:29.996577\n         263 | Hilda       |   0.99 | 2007-05-14 13:44:29.996577\n         252 | Mattie      |   4.99 | 2007-05-14 13:44:29.996577\n</code></pre> <p>Tenga en cuenta que aprender\u00e1 sobre INNER JOIN en el pr\u00f3ximo tutorial.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/#uso-de-alias-de-tablas-en-la-autounion","title":"Uso de alias de tablas en la autouni\u00f3n","text":"<p>Cuando se une una tabla a s\u00ed misma (tambi\u00e9n conocido como self-join, es necesario utilizar alias de tablas. Esto se debe a que si se hace referencia a la misma tabla varias veces en una consulta, se producir\u00e1 un error.</p> <p>El siguiente ejemplo muestra c\u00f3mo hacer referencia a la tabla <code>film</code> dos veces en la misma consulta utilizando los alias de tabla:</p> <pre><code>SELECT\n    f1.title,\n    f2.title,\n    f1.length\nFROM\n    film f1\nINNER JOIN film f2 \n    ON f1.film_id &lt;&gt; f2.film_id AND \n       f1.length = f2.length;\n</code></pre> <p>Salida:</p> <pre><code>            title            |            title            | length\n-----------------------------+-----------------------------+--------\n Chamber Italian             | Resurrection Silverado      |    117\n Chamber Italian             | Magic Mallrats              |    117\n Chamber Italian             | Graffiti Love               |    117\n Chamber Italian             | Affair Prejudice            |    117\n Grosse Wonderful            | Hurricane Affair            |     49\n Grosse Wonderful            | Hook Chariots               |     49\n Grosse Wonderful            | Heavenly Gun                |     49\n Grosse Wonderful            | Doors President             |     49\n...\n</code></pre> <p>Ten en cuenta que aprender\u00e1s sobre self-join en el pr\u00f3ximo tutorial.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/02.-Alias%20de%20tablas/#resumen","title":"Resumen","text":"<ul> <li>Utilice los alias de tabla PostgreSQL para asignar un nombre temporal a una tabla durante la ejecuci\u00f3n de una consulta.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/","title":"03.-INNER JOIN","text":"<p>En una base de datos relacional, los datos suelen estar distribuidos en varias tablas. Para recuperar datos completos, a menudo es necesario consultarlos desde m\u00faltiples tablas.</p> <p>En este tutorial, nos centraremos en c\u00f3mo recuperar datos de m\u00faltiples tablas utilizando la cl\u00e1usula <code>INNER JOIN</code>.</p> <p>Esta es la sintaxis gen\u00e9rica para la cl\u00e1usula <code>INNER JOIN</code> que une dos tablas:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1\nINNER JOIN table2 \n  ON table1.column_name = table2.column_name;\n</code></pre> <p>En esta sintaxis:</p> <ul> <li>Primero, especifique las columnas de ambas tablas en la lista de selecci\u00f3n de la cl\u00e1usula <code>SELECT</code>.</li> <li>En segundo lugar, especifique la tabla principal (<code>table1</code>) de la que desea seleccionar los datos en la cl\u00e1usula <code>FROM</code>.</li> <li>En tercer lugar, especifique la segunda tabla (<code>table2</code>) a la que desea unirse utilizando la palabra clave <code>INNER JOIN</code>.</li> <li>Por \u00faltimo, defina una condici\u00f3n para la uni\u00f3n. Esta condici\u00f3n indica qu\u00e9 columna (<code>nombre_columna</code>) de cada tabla debe tener valores coincidentes para la uni\u00f3n.</li> </ul> <p>Para acortar la consulta, puede utilizar alias de tablas:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1 t1\nINNER JOIN table2 t2 \n    ON t1.column_name = t2.column_name;\n</code></pre> <p>En esta sintaxis, primero asignamos <code>t1</code> y <code>t2</code> como alias de tabla para <code>table1</code> y <code>table2</code>. A continuaci\u00f3n, utilizamos los alias de tabla para calificar las columnas de cada tabla.</p> <p>Si las columnas a comparar comparten el mismo nombre, puede utilizar la sintaxis <code>USING</code>:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1 t1\nINNER JOIN table2 t2 USING(column_name);\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/#como-funciona-el-inner-join","title":"C\u00f3mo funciona el INNER JOIN","text":"<p>Para cada fila de la <code>tabla1</code>, la uni\u00f3n interna compara el valor de <code>nombre_columna</code> con el valor de la columna correspondiente de cada fila de la <code>tabla2</code>.</p> <p>Cuando estos valores son iguales, el join interno crea una nueva fila que incluye todas las columnas de ambas tablas y la a\u00f1ade al conjunto de resultados.</p> <p>Por el contrario, si estos valores no son iguales, la uni\u00f3n interna ignora el par actual y pasa a la fila siguiente, repitiendo el proceso de coincidencia.</p> <p>El siguiente diagrama de Venn ilustra el funcionamiento de la cl\u00e1usula <code>INNER JOIN</code>.</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/#ejemplos-de-inner-join-en-postgresql","title":"Ejemplos de INNER JOIN en PostgreSQL","text":"<p>Veamos algunos ejemplos de uso de la cl\u00e1usula <code>INNER JOIN</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/#usando-postgresql-inner-join-para-unir-dos-tablas","title":"Usando PostgreSQL INNER JOIN para unir dos tablas","text":"<p>Veamos las tablas <code>customer</code> y <code>payment</code> en la base de datos de ejemplo.</p> <p></p> <p>En este esquema, cada vez que un cliente realiza un pago, se inserta una nueva fila en la tabla <code>payment</code>. Aunque cada cliente puede tener cero o muchos pagos, cada pago pertenece a un solo cliente. La columna <code>customer_id</code> sirve de enlace para establecer la relaci\u00f3n entre las dos tablas.</p> <p>La siguiente sentencia utiliza la cl\u00e1usula <code>INNER JOIN</code> para seleccionar datos de ambas tablas:</p> <pre><code>SELECT \n  customer.customer_id, \n  customer.first_name, \n  customer.last_name, \n  payment.amount, \n  payment.payment_date \nFROM \n  customer \n  INNER JOIN payment ON payment.customer_id = customer.customer_id \nORDER BY \n  payment.payment_date;\n</code></pre> <p>Salida:</p> <pre><code> customer_id | first_name  |  last_name   | amount |        payment_date\n-------------+-------------+--------------+--------+----------------------------\n         416 | Jeffery     | Pinson       |   2.99 | 2007-02-14 21:21:59.996577\n         516 | Elmer       | Noe          |   4.99 | 2007-02-14 21:23:39.996577\n         239 | Minnie      | Romero       |   4.99 | 2007-02-14 21:29:00.996577\n         592 | Terrance    | Roush        |   6.99 | 2007-02-14 21:41:12.996577\n          49 | Joyce       | Edwards      |   0.99 | 2007-02-14 21:44:52.996577\n...\n</code></pre> <p>Para acortar la consulta, puede utilizar los alias de tabla:</p> <pre><code>SELECT \n  c.customer_id, \n  c.first_name, \n  c.last_name, \n  p.amount, \n  p.payment_date \nFROM \n  customer c \n  INNER JOIN payment p ON p.customer_id = c.customer_id \nORDER BY \n  p.payment_date;\n</code></pre> <p>Como ambas tablas tienen la misma columna <code>customer_id</code>, puede utilizar la sintaxis <code>USING</code>:</p> <pre><code>SELECT \n  customer_id, \n  first_name, \n  last_name, \n  amount, \n  payment_date \nFROM \n  customer \n  INNER JOIN payment USING(customer_id) \nORDER BY \n  payment_date;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/#uso-de-inner-join-de-postgresql-para-unir-tres-tablas","title":"Uso de INNER JOIN de PostgreSQL para unir tres tablas","text":"<p>El siguiente diagrama ilustra la relaci\u00f3n entre tres tablas: <code>staff</code>, <code>payment</code>, y <code>customer</code>:</p> <p></p> <p>Cada miembro del personal puede gestionar cero o m\u00faltiples pagos, y cada pago es procesado por uno y s\u00f3lo un miembro del personal.</p> <p>Del mismo modo, cada cliente puede realizar cero o varios pagos, y cada pago est\u00e1 asociado a un \u00fanico cliente.</p> <p>El siguiente ejemplo utiliza cl\u00e1usulas <code>INNER JOIN</code> para recuperar datos de tres tablas</p> <pre><code>SELECT \n  c.customer_id, \n  c.first_name || ' ' || c.last_name customer_name, \n  s.first_name || ' ' || s.last_name staff_name, \n  p.amount, \n  p.payment_date \nFROM \n  customer c \n  INNER JOIN payment p USING (customer_id) \n  INNER JOIN staff s using(staff_id) \nORDER BY \n  payment_date;\n</code></pre> <p>Salida:</p> <pre><code> customer_id |     customer_name     |  staff_name  | amount |        payment_date\n-------------+-----------------------+--------------+--------+----------------------------\n         416 | Jeffery Pinson        | Jon Stephens |   2.99 | 2007-02-14 21:21:59.996577\n         516 | Elmer Noe             | Jon Stephens |   4.99 | 2007-02-14 21:23:39.996577\n         239 | Minnie Romero         | Mike Hillyer |   4.99 | 2007-02-14 21:29:00.996577\n         592 | Terrance Roush        | Jon Stephens |   6.99 | 2007-02-14 21:41:12.996577\n          49 | Joyce Edwards         | Mike Hillyer |   0.99 | 2007-02-14 21:44:52.996577\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/03.-INNER%20JOIN/#resumen","title":"Resumen","text":"<ul> <li>Utilice las cl\u00e1usulas <code>INNER JOIN</code> para seleccionar datos de dos o m\u00e1s tablas relacionadas y devolver filas que tengan valores coincidentes en todas las tablas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/","title":"04.-LEFT JOIN","text":"<p>La cl\u00e1usula <code>LEFT JOIN</code> une una tabla izquierda con la tabla derecha y devuelve las filas de la tabla izquierda que pueden o no tener filas correspondientes en la tabla derecha.</p> <p>La cl\u00e1usula <code>LEFT JOIN</code> puede ser \u00fatil para seleccionar filas de una tabla que no tienen filas coincidentes en otra.</p> <p>Esta es la sintaxis b\u00e1sica de la cl\u00e1usula <code>LEFT JOIN</code>:</p> <pre><code>SELECT \n  seleccionar_lista \nFROM \n  tabla1\nLEFT JOIN tabla2 \n  ON tabla1.nombre_columna = tabla2.nombre_columna;\n</code></pre> <p>En esta sintaxis</p> <ul> <li>En primer lugar, especifique las columnas de ambas tablas en la lista de selecci\u00f3n (<code>select_list</code>) de la cl\u00e1usula <code>SELECT</code>.</li> <li>En segundo lugar, especifique la tabla izquierda (<code>table1</code>) de la que desea seleccionar los datos en la cl\u00e1usula <code>FROM</code>.</li> <li>En tercer lugar, especifique la tabla derecha (<code>table2</code>) a la que desea unirse mediante la palabra clave <code>LEFT JOIN</code>.</li> <li>Por \u00faltimo, defina una condici\u00f3n para la uni\u00f3n (<code>nombre_columna1 = nombre_columna2</code>), que indica que la columna (<code>nombre_columna</code>) de cada tabla debe tener valores coincidentes.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/#como-funciona-left-join","title":"C\u00f3mo funciona LEFT JOIN","text":"<p>La cl\u00e1usula <code>LEFT JOIN</code> comienza seleccionando los datos de la tabla izquierda (<code>table1</code>). Para cada fila de la tabla izquierda, compara el valor de <code>nombre_columna</code> con el valor de la columna correspondiente de cada fila de la tabla derecha.</p> <p>Cuando estos valores son iguales, la cl\u00e1usula join izquierda genera una nueva fila que incluye las columnas que aparecen en la <code>select_list</code> y la a\u00f1ade al conjunto de resultados.</p> <p>Si estos valores no son iguales, la cl\u00e1usula <code>LEFT JOIN</code> crea una nueva fila que incluye las columnas especificadas en la cl\u00e1usula <code>SELECT</code>. Adem\u00e1s, rellena con NULL las columnas que provienen de la tabla de la derecha.</p> <p>Tenga en cuenta que <code>LEFT JOIN</code> tambi\u00e9n se denomina <code>LEFT OUTER JOIN</code>.</p> <p>Si las columnas para unir dos tablas tienen el mismo nombre, puede utilizar la sintaxis <code>USING</code>:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1 \n  LEFT JOIN table2 USING (column_name);\n</code></pre> <p>El siguiente diagrama de Venn ilustra c\u00f3mo funciona la cl\u00e1usula <code>LEFT JOIN</code>:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/#ejemplos-de-left-join-en-postgresql","title":"Ejemplos de LEFT JOIN en PostgreSQL","text":"<p>Veamos las siguientes tablas <code>film</code> e <code>inventory</code> de la base de datos de ejemplo.</p> <p></p> <p>Cada fila de la tabla <code>film</code> puede corresponder a cero o m\u00faltiples filas de la tabla <code>inventory</code>.</p> <p>A la inversa, cada fila de la tabla <code>inventario</code> tiene una y s\u00f3lo una fila en la tabla <code>pel\u00edcula</code>.</p> <p>El v\u00ednculo entre las tablas <code>film</code> e <code>inventory</code> se establece a trav\u00e9s de la columna <code>film_id</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/#1-ejemplos-basicos-de-left-join-en-postgresql","title":"1) Ejemplos b\u00e1sicos de LEFT JOIN en PostgreSQL","text":"<p>La siguiente sentencia utiliza la cl\u00e1usula <code>LEFT JOIN</code> para unir la tabla <code>film</code> con la tabla <code>inventory</code>:</p> <pre><code>SELECT \n  film.film_id, \n  film.title, \n  inventory.inventory_id \nFROM \n  film \n  LEFT JOIN inventory ON inventory.film_id = film.film_id \nORDER BY \n  film.title;\n</code></pre> <p></p> <p>Cuando una fila de la tabla <code>film</code> no tiene una fila coincidente en la tabla <code>inventory</code>, el valor de la columna <code>inventory_id</code> de esta fila es <code>NULL</code>.</p> <p>La siguiente sentencia utiliza alias de tablas y la cl\u00e1usula <code>LEFT JOIN</code> para unir las tablas <code>film</code> e <code>inventory</code>:</p> <pre><code>SELECT \n  f.film_id, \n  f.title, \n  i.inventory_id \nFROM \n  film f\n  LEFT JOIN inventory i ON i.film_id = f.film_id \nORDER BY \n  i.inventory_id;\n</code></pre> <p>Dado que las tablas <code>film</code> e <code>inventory</code> comparten la misma columna <code>film_id</code>, puede utilizar la sintaxis <code>USING</code>:</p> <pre><code>SELECT \n  f.film_id, \n  f.title, \n  i.inventory_id \nFROM \n  film f\n  LEFT JOIN inventory i USING (film_id)\nORDER BY \n  i.inventory_id;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/#2-uso-de-postgresql-left-join-con-clausula-where","title":"2) Uso de PostgreSQL LEFT JOIN con cl\u00e1usula WHERE","text":"<p>A continuaci\u00f3n se utiliza la cl\u00e1usula <code>LEFT JOIN</code> para unir las tablas <code>inventory</code> y <code>film</code>. Incluye una cl\u00e1usula <code>WHERE</code> que identifica las pel\u00edculas que no est\u00e1n presentes en el inventario:</p> <pre><code>SELECT \n  f.film_id, \n  f.title, \n  i.inventory_id \nFROM \n  film f \n  LEFT JOIN inventory i USING (film_id) \nWHERE \n  i.film_id IS NULL \nORDER BY \n  f.title;\n</code></pre> <p>Salida:</p> <pre><code> film_id |         title          | inventory_id\n---------+------------------------+--------------\n      14 | Alice Fantasia         |         null\n      33 | Apollo Teen            |         null\n      36 | Argonauts Town         |         null\n      38 | Ark Ridgemont          |         null\n      41 | Arsenic Independence   |         null\n...\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/04.-LEFT%20JOIN/#resumen","title":"Resumen","text":"<ul> <li>Utilice la cl\u00e1usula <code>LEFT JOIN</code> de PostgreSQL para seleccionar filas de una tabla que pueden o no tener filas correspondientes en otras tablas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/05.-SELF%20JOIN/","title":"05.-SELF JOIN","text":"<p>Una autouni\u00f3n es una uni\u00f3n regular que une una tabla consigo misma. En la pr\u00e1ctica, se suele utilizar una autouni\u00f3n para consultar datos jer\u00e1rquicos o para comparar filas dentro de la misma tabla.</p> <p>Para formar una autouni\u00f3n, especifique la misma tabla dos veces con alias de tablas diferentes y proporcione el predicado de uni\u00f3n despu\u00e9s de la palabra clave <code>ON</code>.</p> <p>La siguiente consulta utiliza un <code>INNER JOIN</code> que une la tabla consigo misma:</p> <pre><code>SELECT select_list\nFROM table_name t1\nINNER JOIN table_name t2 ON join_predicate;\n</code></pre> <p>En esta sintaxis, <code>nombre_tabla</code> se une a s\u00ed misma mediante la cl\u00e1usula <code>INNER JOIN</code>.</p> <p>Alternativamente, puede utilizar la cl\u00e1usula <code>LEFT JOIN</code> o <code>RIGHT JOIN</code> para unir la tabla a s\u00ed misma de la siguiente manera:</p> <pre><code>SELECT select_list\nFROM table_name t1\nLEFT JOIN table_name t2 ON join_predicate;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/05.-SELF%20JOIN/#ejemplos-de-auto-uniones-en-postgresql","title":"Ejemplos de auto-uniones en PostgreSQL","text":"<p>Veamos algunos ejemplos de uso de autouniones.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/05.-SELF%20JOIN/#ejemplo-de-consulta-de-datos-jerarquicos","title":"Ejemplo de consulta de datos jer\u00e1rquicos","text":"<p>Vamos a crear una tabla de ejemplo para la demostraci\u00f3n.</p> <p>Supongamos que tenemos la siguiente estructura organizativa:</p> <p></p> <p>Las siguientes sentencias crean la tabla <code>employee</code> e insertan algunos datos de ejemplo en la tabla.</p> <pre><code>CREATE TABLE employee (\n  employee_id INT PRIMARY KEY, \n  first_name VARCHAR (255) NOT NULL, \n  last_name VARCHAR (255) NOT NULL, \n  manager_id INT, \n  FOREIGN KEY (manager_id) REFERENCES employee (employee_id) ON DELETE CASCADE\n);\nINSERT INTO employee (employee_id, first_name, last_name, manager_id) \nVALUES \n  (1, 'Windy', 'Hays', NULL), \n  (2, 'Ava', 'Christensen', 1), \n  (3, 'Hassan', 'Conner', 1), \n  (4, 'Anna', 'Reeves', 2), \n  (5, 'Sau', 'Norman', 2), \n  (6, 'Kelsie', 'Hays', 3), \n  (7, 'Tory', 'Goff', 3), \n  (8, 'Salley', 'Lester', 3);\n\nSELECT * FROM employee;\n</code></pre> <p>Salida:</p> <pre><code> employee_id | first_name |  last_name  | manager_id\n-------------+------------+-------------+------------\n           1 | Windy      | Hays        |       null\n           2 | Ava        | Christensen |          1\n           3 | Hassan     | Conner      |          1\n           4 | Anna       | Reeves      |          2\n           5 | Sau        | Norman      |          2\n           6 | Kelsie     | Hays        |          3\n           7 | Tory       | Goff        |          3\n           8 | Salley     | Lester      |          3\n(8 rows)\n</code></pre> <p>En esta tabla <code>employee</code>, la columna <code>manager_id</code> hace referencia a la columna <code>employee_id</code>.</p> <p>La columna <code>manager_id</code> indica la relaci\u00f3n directa, mostrando el manager del que depende el empleado.</p> <p>Si la columna <code>manager_id</code> contiene NULL, significa que el empleado en cuesti\u00f3n no depende de nadie, ocupando esencialmente el puesto de alto directivo.</p> <p>La siguiente consulta utiliza la autouni\u00f3n para averiguar qui\u00e9n depende de qui\u00e9n:</p> <pre><code>SELECT \n  e.first_name || ' ' || e.last_name employee, \n  m.first_name || ' ' || m.last_name manager \nFROM \n  employee e \n  INNER JOIN employee m ON m.employee_id = e.manager_id \nORDER BY \n  manager;\n</code></pre> <p>Salida:</p> <pre><code>    employee     |     manager\n-----------------+-----------------\n Sau Norman      | Ava Christensen\n Anna Reeves     | Ava Christensen\n Salley Lester   | Hassan Conner\n Kelsie Hays     | Hassan Conner\n Tory Goff       | Hassan Conner\n Ava Christensen | Windy Hays\n Hassan Conner   | Windy Hays\n(7 rows)\n</code></pre> <p>Esta consulta hace referencia a la tabla <code>employees</code> dos veces, una como empleado y otra como directivo. Utiliza los alias de tabla <code>e</code> para el empleado y <code>m</code> para el directivo.</p> <p>El predicado join encuentra la pareja empleado/director comparando los valores de las columnas <code>employee_id</code> y <code>manager_id</code>.</p> <p>Observe que el m\u00e1ximo responsable no aparece en el resultado.</p> <p>Para incluir al m\u00e1ximo responsable en el conjunto de resultados, utilice la cl\u00e1usula <code>LEFT JOIN</code> en lugar de <code>INNER JOIN</code> como se muestra en la siguiente consulta:</p> <pre><code>SELECT \n  e.first_name || ' ' || e.last_name employee, \n  m.first_name || ' ' || m.last_name manager \nFROM \n  employee e \n  LEFT JOIN employee m ON m.employee_id = e.manager_id \nORDER BY \n  manager;\n</code></pre> <p>Salida:</p> <pre><code>    employee     |     manager\n-----------------+-----------------\n Anna Reeves     | Ava Christensen\n Sau Norman      | Ava Christensen\n Salley Lester   | Hassan Conner\n Kelsie Hays     | Hassan Conner\n Tory Goff       | Hassan Conner\n Hassan Conner   | Windy Hays\n Ava Christensen | Windy Hays\n Windy Hays      | null\n(8 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/05.-SELF%20JOIN/#comparacion-de-las-filas-con-la-misma-tabla","title":"Comparaci\u00f3n de las filas con la misma tabla","text":"<p>V\u00e9ase la siguiente tabla <code>film</code> de la base de datos de alquiler de DVD:</p> <p></p> <p>La siguiente consulta encuentra todos los pares de pel\u00edculas que tienen la misma duraci\u00f3n,</p> <pre><code>SELECT \n  f1.title, \n  f2.title, \n  f1.length \nFROM \n  film f1 \n  INNER JOIN film f2 ON f1.film_id &gt; f2.film_id \n  AND f1.length = f2.length;\n</code></pre> <p>Salida:</p> <pre><code>           title           |            title            | length\n---------------------------+-----------------------------+--------\n Chamber Italian           | Affair Prejudice            |    117\n Grosse Wonderful          | Doors President             |     49\n Bright Encounters         | Bedazzled Married           |     73\n Date Speed                | Crow Grease                 |    104\n Annie Identity            | Academy Dinosaur            |     86\n Anything Savannah         | Alone Trip                  |     82\n Apache Divine             | Anaconda Confessions        |     92\n Arabia Dogma              | Airplane Sierra             |     62\n Dying Maker               | Antitrust Tomatoes          |    168\n...\n</code></pre> <p>El predicado join coincide con dos pel\u00edculas diferentes (<code>f1.film_id &gt; f2.film_id</code>) que tienen la misma longitud (<code>f1.length = f2.length</code>)</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/05.-SELF%20JOIN/#resumen","title":"Resumen","text":"<ul> <li>Una autouni\u00f3n PostgreSQL es una uni\u00f3n regular que une una tabla a s\u00ed misma usando <code>INNER JOIN</code> o <code>LEFT JOIN</code>.</li> <li>Las autouniones son muy \u00fatiles para consultar datos jer\u00e1rquicos o comparar filas dentro de la misma tabla.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/","title":"06.-FULL OUTER JOIN","text":"<p>El <code>FULL OUTER JOIN</code> combina datos de dos tablas y devuelve todas las filas de ambas tablas, incluidas las filas coincidentes y no coincidentes de ambos lados.</p> <p>En otras palabras, el <code>FULL OUTER JOIN</code> combina los resultados del left join y del right join.</p> <p>Esta es la sintaxis b\u00e1sica de la cl\u00e1usula <code>FULL OUTER JOIN</code>:</p> <pre><code>SELECT select_list\nFROM table1\nFULL OUTER JOIN table2 \n   ON table1.column_name = table2.column_name;\n</code></pre> <p>En esta sintaxis:</p> <ul> <li>Primero, especifique las columnas de <code>table1</code> y <code>table2</code> en la <code>select_list</code>.</li> <li>En segundo lugar, especifique la <code>table1</code> que desea recuperar los datos en la cl\u00e1usula <code>FROM</code>.</li> <li>En tercer lugar, especifique la <code>table2</code> que desea unir con la <code>table1</code> en la cl\u00e1usula <code>FULL OUTER JOIN</code>.</li> <li>Por \u00faltimo, defina una condici\u00f3n para unir dos tablas.</li> </ul> <p>El <code>FULL OUTER JOIN</code> tambi\u00e9n se conoce como <code>FULL JOIN</code>. La palabra clave <code>OUTER</code> es opcional.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#como-funciona-el-full-outer-join","title":"C\u00f3mo funciona el FULL OUTER JOIN","text":""},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#paso-1-inicializar-el-conjunto-de-resultados","title":"Paso 1. Inicializar el conjunto de resultados:","text":"<ul> <li>El <code>FULL OUTER JOIN</code> comienza con un resultado vac\u00edo.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#paso-2-coincidencia-de-filas","title":"Paso 2. Coincidencia de filas:","text":"<ul> <li>En primer lugar, identifique las filas de la <code>tabla1</code> y la <code>tabla2</code> en las que coincidan los valores del <code>nombre_columna</code> especificado.</li> <li>A continuaci\u00f3n, incluya estas filas coincidentes en el conjunto de resultados.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#paso-3-incluir-filas-no-coincidentes-de-la-tabla1-y-la-tabla2","title":"Paso 3. Incluir filas no coincidentes de la <code>tabla1</code> y la <code>tabla2</code>:","text":"<ul> <li>En primer lugar, incluya las filas de la <code>tabla1</code> que no coincidan con las de la <code>tabla2</code>. Para las columnas de la <code>tabla2</code> en estas filas, incluya NULLs.</li> <li>En segundo lugar, incluya las filas de la <code>tabla2</code> que no coincidan con las de la <code>tabla1</code>. Para las columnas de la <code>tabla1</code> en estas filas, incluya NULLs.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#paso-4-devolver-el-conjunto-de-resultados","title":"Paso 4. Devolver el conjunto de resultados:","text":"<ul> <li>Devuelve el conjunto de resultados final que contendr\u00e1 todas las filas de ambas tablas, con filas coincidentes y no coincidentes tanto de <code>table1</code> como de <code>table2</code>.</li> <li>Si una fila tiene una coincidencia en ambos lados, combina los valores en una sola fila.</li> <li>Si no hay ninguna coincidencia en uno de los lados, las columnas del lado no coincidente tendr\u00e1n valores NULL.</li> </ul> <p>El siguiente diagrama de Venn ilustra la operaci\u00f3n <code>FULL OUTER JOIN</code>.</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#configurar-tablas-de-ejemplo","title":"Configurar tablas de ejemplo","text":"<p>Primero, cree dos nuevas tablas para la demostraci\u00f3n: <code>employees</code> y <code>departments</code>:</p> <pre><code>CREATE TABLE departments (\n  department_id serial PRIMARY KEY, \n  department_name VARCHAR (255) NOT NULL\n);\nCREATE TABLE employees (\n  employee_id serial PRIMARY KEY, \n  employee_name VARCHAR (255), \n  department_id INTEGER\n);\n</code></pre> <p>Cada departamento tiene cero o muchos empleados y cada empleado pertenece a cero o un departamento.</p> <p>En segundo lugar, inserte algunos datos de ejemplo en las tablas <code>departments</code> y <code>employees</code>.</p> <pre><code>INSERT INTO departments (department_name) \nVALUES \n  ('Sales'), \n  ('Marketing'), \n  ('HR'), \n  ('IT'), \n  ('Production');\nINSERT INTO employees (employee_name, department_id) \nVALUES \n  ('Bette Nicholson', 1), \n  ('Christian Gable', 1), \n  ('Joe Swank', 2), \n  ('Fred Costner', 3), \n  ('Sandra Kilmer', 4), \n  ('Julia Mcqueen', NULL);\n\n</code></pre> <p>En tercer lugar, consulta los datos de las tablas <code>departments</code> y <code>employees</code>:</p> <pre><code>SELECT * FROM departments;\n</code></pre> <p>Salida:</p> <pre><code> department_id | department_name\n---------------+-----------------\n             1 | Sales\n             2 | Marketing\n             3 | HR\n             4 | IT\n             5 | Production\n(5 rows)\nSELECT * FROM employees;\n</code></pre> <p>Salida:</p> <pre><code> employee_id |  employee_name  | department_id\n-------------+-----------------+---------------\n           1 | Bette Nicholson |             1\n           2 | Christian Gable |             1\n           3 | Joe Swank       |             2\n           4 | Fred Costner    |             3\n           5 | Sandra Kilmer   |             4\n           6 | Julia Mcqueen   |          null\n(6 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#ejemplos-de-full-outer-join-en-postgresql","title":"Ejemplos de FULL OUTER JOIN en PostgreSQL","text":"<p>Veamos algunos ejemplos del uso de la cl\u00e1usula <code>FULL OUTER JOIN</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#ejemplo-basico-de-full-outer-join","title":"Ejemplo b\u00e1sico de FULL OUTER JOIN","text":"<p>La siguiente consulta utiliza la cl\u00e1usula <code>FULL OUTER JOIN</code> para consultar datos de las tablas <code>employees</code> y <code>departments</code>:</p> <pre><code>SELECT \n  employee_name, \n  department_name \nFROM \n  employees e \nFULL OUTER JOIN departments d \n  ON d.department_id = e.department_id;\n</code></pre> <p>Salida:</p> <pre><code>  employee_name  | department_name\n-----------------+-----------------\n Bette Nicholson | Sales\n Christian Gable | Sales\n Joe Swank       | Marketing\n Fred Costner    | HR\n Sandra Kilmer   | IT\n Julia Mcqueen   | null\n null            | Production\n(7 rows)\n</code></pre> <p>El conjunto de resultados incluye todos los empleados que pertenecen a un departamento y todos los departamentos que tienen un empleado.</p> <p>Adem\u00e1s, incluye todos los empleados que no pertenecen a ning\u00fan departamento y todos los departamentos que no tienen empleados.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#ejemplo-de-utilizacion-de-full-outer-join-con-clausula-where","title":"Ejemplo de utilizaci\u00f3n de FULL OUTER JOIN con cl\u00e1usula WHERE","text":"<p>El siguiente ejemplo utiliza <code>FULL OUTER JOIN</code> con una cl\u00e1usula WHERE para encontrar el departamento que no tiene ning\u00fan empleado:</p> <pre><code>SELECT \n  employee_name, \n  department_name \nFROM \n  employees e \nFULL OUTER JOIN departments d \n  ON d.department_id = e.department_id \nWHERE \n  employee_name IS NULL;\n\n</code></pre> <p>Salida:</p> <pre><code> employee_name | department_name\n---------------+-----------------\n null          | Production\n(1 row)\n</code></pre> <p>El resultado muestra que el departamento <code>Production</code> no tiene ning\u00fan empleado.</p> <p>El siguiente ejemplo utiliza el cluase <code>FULL OUTER JOIN</code> con una cl\u00e1usula <code>WHERE</code> para encontrar empleados que no pertenezcan a ning\u00fan departamento:</p> <pre><code>SELECT \n  employee_name, \n  department_name \nFROM \n  employees e \nFULL OUTER JOIN departments d \n  ON d.department_id = e.department_id \nWHERE \n  department_name IS NULL;\n</code></pre> <p>Salida:</p> <pre><code> employee_name | department_name\n---------------+-----------------\n Julia Mcqueen | null\n(1 row)\n</code></pre> <p>La salida muestra que <code>Juila Mcqueen</code> no pertenece a ning\u00fan departamento.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/06.-FULL%20OUTER%20JOIN/#resumen","title":"Resumen","text":"<ul> <li>Utilice la cl\u00e1usula <code>FULL OUTER JOIN</code> de PostgreSQL para combinar datos de ambas tablas, asegur\u00e1ndose de que se incluyen las filas coincidentes tanto de la tabla izquierda como de la derecha, as\u00ed como las filas no coincidentes de cualquiera de las tablas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/","title":"07.-CROSS JOIN","text":"<p>Un <code>CROSS JOIN</code> le permite producir un producto cartesiano de filas en dos tablas. Esto significa que el <code>CROSS JOIN</code> combina cada fila de la primera tabla con cada fila de la segunda tabla, dando como resultado una combinaci\u00f3n completa de todas las filas.</p> <p>A diferencia de otras cl\u00e1usulas join como LEFT JOIN o INNER JOIN, la cl\u00e1usula <code>CROSS JOIN</code> no tiene un predicado de uni\u00f3n.</p> <p>Supongamos que tiene que realizar un <code>CROSS JOIN</code> de la <code>tabla1</code> y la <code>tabla2</code>.</p> <p>Si la <code>tabla1</code> tiene <code>n</code> filas y la <code>tabla2</code> tiene <code>m</code> filas, el CROSS JOIN devolver\u00e1 un resultado con <code>nxm</code> filas.</p> <p>Por ejemplo, si la <code>tabla1</code> tiene <code>1.000</code> filas y la <code>tabla2</code> tiene <code>1.000</code> filas, el resultado tendr\u00e1 <code>1.000 x 1.000</code> = <code>1.000.000</code> filas.</p> <p>Debido a que un <code>CROSS JOIN</code> puede generar un conjunto de resultados grande, debe utilizarlo con criterio para evitar problemas de rendimiento.</p> <p>Esta es la sintaxis b\u00e1sica del <code>CROSS JOIN</code>:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1 \nCROSS JOIN table2;\n</code></pre> <p>La siguiente afirmaci\u00f3n es equivalente a la anterior:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1,table2;\n</code></pre> <p>Como alternativa, puede utilizar una cl\u00e1usula <code>INNER JOIN</code> con una condici\u00f3n que siempre se eval\u00fae como verdadera para simular la uni\u00f3n cruzada:</p> <pre><code>SELECT \n  select_list \nFROM \n  table1 \n  INNER JOIN table2 ON true;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/#postgresql-cross-join-ejemplo","title":"PostgreSQL CROSS JOIN ejemplo","text":"<p>Las siguientes sentencias CREATE TABLE crean las tablas T1 y T2 e insert sample data para la demostraci\u00f3n cruzada.</p> <pre><code>DROP TABLE IF EXISTS T1;\nCREATE TABLE T1 (label CHAR(1) PRIMARY KEY);\n\nDROP TABLE IF EXISTS T2;\nCREATE TABLE T2 (score INT PRIMARY KEY);\n\nINSERT INTO T1 (label)\nVALUES\n    ('A'),\n    ('B');\n\nINSERT INTO T2 (score)\nVALUES\n    (1),\n    (2),\n    (3);\n</code></pre> <p>La siguiente sentencia utiliza el operador <code>CROSS JOIN</code> para unir la tabla T1 con la tabla T2.</p> <pre><code>SELECT *\nFROM T1\nCROSS JOIN T2;\n label | score\n-------+-------\n A     |     1\n B     |     1\n A     |     2\n B     |     2\n A     |     3\n B     |     3\n(6 rows)\n</code></pre> <p>La siguiente imagen ilustra el resultado del <code>CROSS JOIN</code> al unir la tabla T1 a la tabla T2:</p> <p></p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/#algunos-ejemplos-practicos-del-uso-de-cross-join","title":"Algunos ejemplos pr\u00e1cticos del uso de CROSS JOIN","text":"<p>En la pr\u00e1ctica, el <code>CROSS JOIN</code> puede resultarle \u00fatil cuando necesite combinar datos de dos tablas sin condiciones de coincidencia espec\u00edficas. Por ejemplo:</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/#programacion","title":"Programaci\u00f3n","text":"<p>Suponga que tiene una tabla de empleados y turnos, y quiere crear un horario que enumere todas las combinaciones posibles de empleados y turnos para explorar varios escenarios de dotaci\u00f3n de personal:</p> <pre><code>SELECT *\nFROM employee\nCROOS JOIN shift;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/#gestion-de-inventarios","title":"Gesti\u00f3n de inventarios","text":"<p>En un sistema de gesti\u00f3n de inventarios, tiene tablas para almacenes y productos. Un <code>CROSS JOIN</code> puede ayudarle a analizar la disponibilidad de cada producto en cada almac\u00e9n:</p> <pre><code>SELECT *\nFROM products\nCROSS JOIN warehouses;\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/07.-CROSS%20JOIN/#resumen","title":"Resumen","text":"<ul> <li>Utilice la cl\u00e1usula <code>CROSS JOIN</code> de PostgreSQL para hacer un producto cartesiano de filas en dos tablas.</li> </ul>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/","title":"08.-NATURAL JOIN","text":"<p>Una uni\u00f3n natural es una uni\u00f3n que crea una uni\u00f3n impl\u00edcita basada en los mismos nombres de columna en las tablas unidas.</p> <p>A continuaci\u00f3n se muestra la sintaxis de la uni\u00f3n natural PostgreSQL:</p> <pre><code>SELECT select_list\nFROM table1\nNATURAL [INNER, LEFT, RIGHT] JOIN table2;\n</code></pre> <p>En esta sintaxis:</p> <ul> <li>En primer lugar, especifique las columnas de las tablas de las que desea obtener datos en la <code>select_list</code> de la cl\u00e1usula <code>SELECT</code>.</li> <li>En segundo lugar, indique la tabla principal (<code>table1</code>) de la que desea obtener los datos.</li> <li>En tercer lugar, especifique la tabla (<code>table2</code>) a la que desea unirse, en la cl\u00e1usula <code>NATURAL JOIN</code>.</li> </ul> <p>Una uni\u00f3n natural puede ser una uni\u00f3n interna, izquierda o derecha. Si no especifica un join expl\u00edcito, PostgreSQL utilizar\u00e1 el <code>INNER JOIN</code> por defecto.</p> <p>La conveniencia del <code>NATURAL JOIN</code> es que no requiere que especifique la cl\u00e1usula join porque utiliza una cl\u00e1usula join impl\u00edcita basada en la columna com\u00fan.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#inner-join","title":"Inner Join","text":"<p>Las siguientes sentencias son equivalentes:</p> <pre><code>SELECT select_list\nFROM table1\nNATURAL INNER JOIN table2;\n</code></pre> <p>y</p> <pre><code>SELECT select_list\nFROM table1\nINNER JOIN table2 USING (column_name);\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#left-join","title":"Left Join","text":"<p>Las siguientes sentencias son equivalentes:</p> <pre><code>SELECT select_list\nFROM table1\nNATURAL LEFT JOIN table2;\n</code></pre> <p>y</p> <pre><code>SELECT select_list\nFROM table1\nLEFT JOIN table2 USING (column_name);\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#right-join","title":"Right join","text":"<p>Las siguientes sentencias son equivalentes:</p> <pre><code>SELECT select_list\nFROM table1\nNATURAL RIGHT JOIN table2;\n</code></pre> <p>y</p> <pre><code>SELECT select_list\nFROM table1\nRIGHT JOIN table2 USING (column_name);\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#creacion-de-tablas-de-ejemplo","title":"Creaci\u00f3n de tablas de ejemplo","text":"<p>Las siguientes sentencias crean las tablas <code>categories</code> y <code>products</code>, e insertan datos de ejemplo para la demostraci\u00f3n:</p> <pre><code>CREATE TABLE categories (\n  category_id SERIAL PRIMARY KEY, \n  category_name VARCHAR (255) NOT NULL\n);\n\nCREATE TABLE products (\n  product_id serial PRIMARY KEY, \n  product_name VARCHAR (255) NOT NULL, \n  category_id INT NOT NULL, \n  FOREIGN KEY (category_id) REFERENCES categories (category_id)\n);\n\nINSERT INTO categories (category_name) \nVALUES \n  ('Smartphone'), \n  ('Laptop'), \n  ('Tablet'),\n  ('VR');\n\nINSERT INTO products (product_name, category_id) \nVALUES \n  ('iPhone', 1), \n  ('Samsung Galaxy', 1), \n  ('HP Elite', 2), \n  ('Lenovo Thinkpad', 2), \n  ('iPad', 3), \n  ('Kindle Fire', 3);\n\nSELECT * FROM products;\nSELECT * FROM categories;\n</code></pre> <p>La tabla <code>productos</code> tiene los siguientes datos:</p> <pre><code> product_id |  product_name   | category_id\n------------+-----------------+-------------\n          1 | iPhone          |           1\n          2 | Samsung Galaxy  |           1\n          3 | HP Elite        |           2\n          4 | Lenovo Thinkpad |           2\n          5 | iPad            |           3\n          6 | Kindle Fire     |           3\n(6 rows)\n</code></pre> <p>La tabla <code>categories</code> tiene los siguientes datos:</p> <pre><code> category_id | category_name\n-------------+---------------\n           1 | Smartphone\n           2 | Laptop\n           3 | Tablet\n           4 | VR\n(4 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#ejemplos-de-natural-join-en-postgresql","title":"Ejemplos de NATURAL JOIN en PostgreSQL","text":"<p>Exploremos algunos ejemplos del uso de la sentencia <code>NATURAL JOIN</code>.</p>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#ejemplo-basico-de-natural-join-en-postgresql","title":"Ejemplo b\u00e1sico de NATURAL JOIN en PostgreSQL","text":"<p>La siguiente sentencia utiliza la cl\u00e1usula <code>NATURAL JOIN</code> para unir la tabla <code>products</code> con la tabla <code>categories</code>:</p> <pre><code>SELECT * \nFROM products\nNATURAL JOIN categories;\n</code></pre> <p>This statement performs an inner join using the <code>category_id</code> column.</p> <p>Output:</p> <pre><code> category_id | product_id |  product_name   | category_name\n-------------+------------+-----------------+---------------\n           1 |          1 | iPhone          | Smartphone\n           1 |          2 | Samsung Galaxy  | Smartphone\n           2 |          3 | HP Elite        | Laptop\n           2 |          4 | Lenovo Thinkpad | Laptop\n           3 |          5 | iPad            | Tablet\n           3 |          6 | Kindle Fire     | Tablet\n(6 rows)\n</code></pre> <p>La sentencia es equivalente a la siguiente sentencia que utiliza la cl\u00e1usula <code>INNER JOIN</code>:</p> <pre><code>SELECT  * \nFROM products\nINNER JOIN categories USING (category_id);\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#uso-de-postgresql-natural-join-para-realizar-un-left-join","title":"Uso de PostgreSQL NATURAL JOIN para realizar un LEFT JOIN","text":"<p>El siguiente ejemplo utiliza la cl\u00e1usula <code>NATURAL JOIN</code> para realizar un <code>LEFT JOIN</code> sin especificar la columna coincidente:</p> <pre><code>SELECT * \nFROM categories\nNATURAL LEFT JOIN products;\n</code></pre> <p>Salida:</p> <pre><code> category_id | category_name | product_id |  product_name\n-------------+---------------+------------+-----------------\n           1 | Smartphone    |          1 | iPhone\n           1 | Smartphone    |          2 | Samsung Galaxy\n           2 | Laptop        |          3 | HP Elite\n           2 | Laptop        |          4 | Lenovo Thinkpad\n           3 | Tablet        |          5 | iPad\n           3 | Tablet        |          6 | Kindle Fire\n           4 | VR            |       null | null\n(7 rows)\n</code></pre>"},{"location":"02.-Tutorial%20Avanzado/03.-Uniendo%20m%C3%BAltiples%20tablas/08.-NATURAL%20JOIN/#ejemplo-de-utilizacion-de-natural-join-que-provoca-un-resultado-inesperado","title":"Ejemplo de utilizaci\u00f3n de NATURAL JOIN que provoca un resultado inesperado","text":"<p>En la pr\u00e1ctica, deber\u00eda evitar utilizar el <code>NATURAL JOIN</code> siempre que sea posible porque a veces puede provocar un resultado inesperado.</p> <p>Considere las siguientes tablas <code>city</code> y <code>country</code> de la base de datos de ejemplo:</p> <p></p> <p></p> <ul> <li>Ambas tablas tienen la misma columna <code>country_id</code> por lo que puede utilizar el <code>NATURAL JOIN</code> para unir estas tablas de la siguiente manera:</li> </ul> <p><code>SELECT *    FROM ciudad   NATURAL JOIN pa\u00eds;</code></p> <p>La consulta devuelve un conjunto de resultados vac\u00edo.</p> <p>La raz\u00f3n es que ambas tablas tienen otra columna com\u00fan llamada <code>last_update</code>. Cuando la cl\u00e1usula <code>NATURAL JOIN</code> utiliza la columna <code>last_update</code>, no encuentra ninguna coincidencia.</p> <p># Resumen</p> <ul> <li>Utilice la cl\u00e1usula <code>NATURAL JOIN</code> de PostgreSQL para consultar datos de dos o m\u00e1s tablas que tengan columnas comunes.</li> </ul>"}]}