Un escaneo de un solo índice sólo puede utilizar cláusulas de  consulta que utilizan las columnas del índice con los operadores de su  clase de operador y se unen con `AND`. Por ejemplo, dado un índice de  `(a, b)`una condición de consulta como  `WHERE a = 5 AND b = 6`podría usar el índice, pero una consulta como  `WHERE a = 5 OR b = 6`no podía utilizar directamente el índice.

Afortunadamente, PostgreSQL tiene la capacidad de combinar múltiples índices (incluyendo múltiples  usos del mismo índice) para manejar casos que no pueden ser  implementados mediante escaneos de un solo índice. El sistema puede  formarse  `AND`y  `OR`afecciones en varios escaneos de índice. Por ejemplo, una consulta como  `WHERE x = 42 OR x = 47 OR x = 53 OR x = 99`podría dividirse en cuatro escaneos separados de un índice en `x`, cada escaneo usando una de las cláusulas de consulta. Los resultados de estos escaneos se juntan para producir el resultado. Otro ejemplo es  que si tenemos índices separados en  `x`y `y`, una posible implementación de una consulta como  `WHERE x = 5 AND y = 6`es utilizar cada índice con la cláusula de consulta apropiada y luego Y  juntos los resultados del índice para identificar las filas de  resultados.

Para combinar múltiples índices, el sistema escanea cada índice necesario y prepara un *mapa* de *bits* en la memoria dando las ubicaciones de las filas de tablas que se  reportan como que coinciden con las condiciones de ese índice. Los mapas de bits son entonces ANDed y ORed juntos según sea necesario por la  consulta. Finalmente, las filas de mesa reales son visitadas y  devueltas. Las filas de tablas se visitan en orden físico, porque así es como se establece el mapa de bits; esto significa que cualquier pedido  de los índices originales se pierde, por lo que se necesitará un paso de tipo separado si la consulta tiene un  `ORDER BY`cláusula. Por esta razón, y debido a que cada escaneo de índice adicional añade  tiempo adicional, el planificador a veces optará por utilizar un simple  escaneo de índice a pesar de que hay índices adicionales disponibles que podrían haber sido utilizados también.

En todas las aplicaciones menos las más sencillas, hay varias  combinaciones de índices que podrían ser útiles, y el desarrollador de  bases de datos debe hacer compensaciones para decidir qué índices  proporcionar. A veces los índices multicolumn son mejores, pero a veces  es mejor crear índices separados y confiar en la función de combinación  de índices. Por ejemplo, si su carga de trabajo incluye una mezcla de  consultas que a veces implican sólo columna `x`, a veces sólo columna `y`, y a veces ambas columnas, usted podría elegir para crear dos índices separados en  `x`y `y`, apoyándose en la combinación de índices para procesar las consultas que utilizan ambas columnas. También podría crear un índice multicolumna en `(x, y)`. Este  índice sería típicamente más eficiente que la combinación de índices  para las consultas que involucran a ambas columnas, pero como se indica  en [la sección 11.](https://www.postgresql.org/docs/current/indexes-multicolumn.html)3, sería casi inservidor para las consultas que involucran únicamente `y`, por lo que no debería ser el único índice. Una combinación del índice multicolumn y un índice separado sobre  `y`serviría razonablemente bien. Para consultas que sólo implican `x`, el índice multicolumn podría utilizarse, aunque sería más grande y, por lo tanto, más lento que un índice en  `x`solo. La última alternativa es crear los tres índices, pero esto es  probablemente sólo razonable si la tabla se busca mucho más a menudo de  lo que se actualiza y los tres tipos de consultas son comunes. Si uno de los tipos de consulta es mucho menos común que los otros, probablemente te conformarías con crear sólo los dos índices que mejor se adaptan a  los tipos comunes.