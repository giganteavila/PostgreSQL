Los tipos de datos JSON son para almacenar los datos de JSON (JavaScript Object Notation), según se especifica en [RFC 7159](https://tools.ietf.org/html/rfc7159). Estos datos también pueden almacenarse como `text`, pero los tipos de datos JSON tienen la ventaja de hacer cumplir que  cada valor almacenado es válido de acuerdo con las normas JSON. También  hay funciones y operadores específicos de JSON disponibles para los  datos almacenados en estos tipos de datos; véase .

PostgreSQL ofrece dos tipos para almacenar datos JSON:  `json`y `jsonb`. Para implementar mecanismos de consulta eficientes para estos tipos de datos, PostgreSQL también proporciona la  `jsonpath`Tipo de datos descrito en [la sección 8.14](https://www.postgresql.org/docs/current/datatype-json.html#DATATYPE-JSONPATH).7.

El  `json`y  `jsonb`Los tipos de datos aceptan conjuntos de valores *casi* idénticos como entrada. La principal diferencia práctica es la de la eficiencia. El  `json`el tipo de datos almacena una copia exacta del texto de entrada, qué  funciones de procesamiento deben volver a ensayar en cada ejecución;  mientras que  `jsonb`los datos se almacenan en un formato binario descompuesto que hace que sea  ligeramente más lento a la entrada debido a la conversión adicional,  pero significativamente más rápido en proceso, ya que no se necesita  reparación.  `jsonb`también es compatible con la indexación, lo que puede ser una ventaja significativa.

Porque el  `json`Tipo almacena una copia exacta del texto de entrada, preservará el espacio  blanco semánticalmente insignificante entre tokens, así como el orden de las teclas dentro de los objetos JSON. Además, si un objeto JSON dentro del valor contiene la misma clave más que una vez, todos los pares de  clave/valor se mantienen. (Las funciones de procesamiento consideran el  último valor como el operativo.) En cambio,  `jsonb`no conserva el espacio en blanco, no conserva el orden de las teclas de  objetos, y no mantiene las claves de objetos duplicados. Si se  especifican las claves duplicadas en la entrada, sólo se mantiene el  último valor.

En general, la mayoría de las aplicaciones deben preferir almacenar datos JSON como `jsonb`, a menos que haya necesidades bastante especializadas, tales como  suposiciones heredadas sobre el orden de las claves de objetos.

 RFC7159 especifica que las cuerdas JSON deben ser codificadas en UTF8. Por lo  tanto, los tipos JSON no pueden ajustarse rígidamente a la  especificación JSON a menos que la codificación de la base de datos sea  UTF8. Los intentos de incluir directamente caracteres que no pueden ser  representados en la codificación de la base de datos fallarán; a la  inversa, se permitirán caracteres que puedan ser representados en la  codificación de la base de datos, pero no en UTF8.

 RFC7159 permite que las cuerdas JSON contengan secuencias de escape de Unicode denotadas por `\u*`XXXX`*`. En la función de entrada para el  `json`Tipo, Unicode escapes se permite independientemente de la codificación de la  base de datos, y se comprueban sólo para la corrección sintáctica (es  decir, que cuatro dígitos hex siguen `\u`). Sin embargo, la función de entrada para  `jsonb`es más estricto: desautoriza que Unicode escape para personajes que no  pueden ser representados en la codificación de la base de datos. El  `jsonb`tipo también rechaza  `\u0000`(porque eso no puede ser representado en PostgreSQL 's  `text`tipo), e insiste en que cualquier uso de parejas sustitutas de Unicode para  designar caracteres fuera del Plano Multilenal Básico Unicode sea  correcto. Los escapes de Unicode Válido se convierten al carácter único  equivalente para el almacenamiento; esto incluye pares de sustitutos  plegables en un solo carácter.

### Nota

Muchas de las funciones de procesamiento JSON descritas en [la Sección 9.16](https://www.postgresql.org/docs/current/functions-json.html) convertirán los escapes de Unicode a caracteres regulares, y por lo  tanto lanzarán los mismos tipos de errores que se acaban de describir  incluso si su entrada es de tipo  `json`no `jsonb`. El hecho de que el  `json`La función de entrada no hace que estos controles puedan considerarse un  artefacto histórico, aunque sí permite un simple almacenamiento (sin  procesamiento) de JSON Unicode escapa en una codificación de base de  datos que no soporta los caracteres representados.

Al convertir la entrada de JSON textual en `jsonb`, los tipos primitivos descritos por  RFC7159 se mapean efectivamente en los tipos nativos de PostgreSQL, como se muestra en la [Tabla 8.23.](https://www.postgresql.org/docs/current/datatype-json.html#JSON-TYPE-MAPPING-TABLE) Por lo tanto, hay algunas limitaciones adicionales menores a lo que constituye válido  `jsonb`datos que no se aplican a la  `json`tipo, ni JSON en el resumen, correspondiente a límites en lo que puede representar el tipo de datos subyacente. En particular,  `jsonb`rechazará los números que están fuera del alcance de PostgreSQL  `numeric`tipo de datos, mientras que  `json`no lo hará. Esas restricciones definidas por la aplicación están permitidas por  RFC7159. Sin embargo, en la práctica es mucho más probable que se produzcan  tales problemas en otras implementaciones, ya que es común representar  la  `number`Tipo primitivo como IEEE 754 punto flotante de doble precisión (que  RFC7159 se anticipa explícitamente y permite). Al utilizar JSON como formato de intercambio con dichos sistemas, se debe considerar el peligro de  perder precisión numérica en comparación con los datos almacenados  originalmente por PostgreSQL.

Por el contrario, como se señala en la tabla hay algunas  restricciones menores en el formato de entrada de los tipos primitivos  de JSON que no se aplican a los tipos correspondientes de PostgreSQL.

**Cuadro 8.23. JSON Tipos Primitivos y Tipos PostgreSQL correspondientes**

| Tipo JSON primitivo | Tipo PostgreSQL | Notas                                                        |
| ------------------- | --------------- | ------------------------------------------------------------ |
| `string`            | `text`          | `\u0000`es desautorizado, al igual que los escapados de Unicode representando  caracteres no disponibles en la codificación de la base de datos |
| `number`            | `numeric`       | `NaN`y  `infinity`valores se desautorizado                   |
| `boolean`           | `boolean`       | Sólo minúscula  `true`y  `false`se aceptan ortaciones        |
| `null`              | (ninguno)       | SQL  `NULL`es un concepto diferente                          |