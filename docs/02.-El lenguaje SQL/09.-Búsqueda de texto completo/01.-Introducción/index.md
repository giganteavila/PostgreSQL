Búsqueda de texto completo (o sólo *búsqueda* de *texto*) proporciona la capacidad de identificar *documentos* de lenguaje natural que satisfagan una *consulta*, y opcionalmente para ordenarlos por relevancia para la consulta. El  tipo de búsqueda más común es encontrar todos los documentos que  contengan *los términos* de *consulta* dados y devolverlos en orden de su *similitud* con la consulta. Nociones de  `query`y  `similarity`son muy flexibles y dependen de la aplicación específica. La búsqueda más simple se considera  `query`como un conjunto de palabras y  como la frecuencia de las palabras de consulta en el documento.

Los operadores de búsqueda textual han existido en bases de datos durante años. PostgreSQL tiene `~`, `~*`, `LIKE`, y  `ILIKE`operadores para tipos de datos textuales, pero carecen de muchas propiedades  esenciales requeridas por los sistemas de información modernos:

- No hay apoyo idiomático, ni siquiera para el inglés. Las  expresiones regulares no son suficientes porque no pueden manejar  fácilmente las palabras derivadas, por ejemplo,  `satisfies`y `satisfy`. Puedes perderte documentos que contengan `satisfies`, aunque probablemente te gustaría encontrarlos cuando buscas `satisfy`. Es posible utilizar  `OR`para buscar múltiples formas derivadas, pero esto es tedioso y propenso a  errores (algáñalas pueden tener varios miles de derivados).
- No proporcionan ningún pedido (ranking) de los resultados de  búsqueda, lo que los hace ineficaces cuando se encuentran miles de  documentos coincidetivos.
- Tienden a ser lentos porque no hay soporte de índice, por lo que deben procesar todos los documentos para cada búsqueda.

La indexación completa de texto permite *preprocesar* los documentos y un índice guardado para la búsqueda rápida posterior. El preprocesamiento incluye:

- *Paro de documentos en \*fichas**. Es útil identificar varias clases de fichas, por ejemplo, números,  palabras, palabras complejas, direcciones de correo electrónico, para  que puedan procesarse de manera diferente. En principio, las clases  sitbaizadas dependen de la aplicación específica, pero para la mayoría  de los propósitos es adecuado utilizar un conjunto de clases  predefinidos. PostgreSQL utiliza un *analizador* para realizar este paso. Se proporciona un analizador estándar y se  pueden crear parsers personalizados para necesidades específicas.
- *Conversión de fichas en \*lexemes**. Una lexeme es una cuerda, al igual que una ficha, pero se ha *normalizado* de modo que se hacen diferentes formas de la misma palabra. Por  ejemplo, la normalización casi siempre incluye la doblaje de letras  mayúsculas a la minúscula, y a menudo implica la eliminación de sufijos  (como  `s`o o  `es`en inglés). Esto permite que las búsquedas encuentren formas variantes de  la misma palabra, sin entrar tediosamente todas las variantes posibles.  Además, este paso típicamente elimina *las palabras de stop*, que son palabras que son tan comunes que son inútiles para la búsqueda. (En resumen, entonces, los tokens son fragmentos crudos del texto del  documento, mientras que las lexemes son palabras que se consideran  útiles para indexar y buscar.) PostgreSQL utiliza *diccionarios* para realizar este paso. Se proporcionan varios diccionarios estándar y se pueden crear los personalizados para necesidades específicas.
- *Almacenar documentos preprocesados optimizados para la búsqueda*. Por ejemplo, cada documento puede ser representado como una variedad  ordenada de lexemes normalizados. Junto con los lexemes a menudo es  deseable almacenar información posicional para su *ranking* de *proximidad*, de modo que un documento que contiene una denseregión más  de palabras de consulta se asigna un rango más alto que uno con palabras de consulta dispersas.

Los diccionarios permiten un control fino sobre cómo se normalizan las fichas. Con los diccionarios adecuados, puede:

- Definir palabras de alto que no deben ser indexadas.
- Mapa sinónimo de una sola palabra usando Ispell.
- Mapear frases a una sola palabra usando un tesauro.
- Mapear diferentes variaciones de una palabra a una forma canónica usando un diccionario de Ispell.
- Mapa diferentes variaciones de una palabra a una forma canónica usando reglas de desbaratero de Snowball.

Tipo de datos  `tsvector`se proporciona para el almacenamiento de documentos preprocesados, junto con un tipo  `tsquery`para la representación de las consultas procesadas (11). Hay muchas funciones y operadores disponibles para estos tipos de datos ([Sección 9.](https://www.postgresql.org/docs/current/functions-textsearch.html)13), el más importante de los cuales es el operador de la coincidencia `@@`, que presentamos en [la Sección 12.1.2](https://www.postgresql.org/docs/current/textsearch-intro.html#TEXTSEARCH-MATCHING). Las búsquedas de texto completo se pueden acelerar mediante índices ([Sección 12.](https://www.postgresql.org/docs/current/textsearch-indexes.html)9).