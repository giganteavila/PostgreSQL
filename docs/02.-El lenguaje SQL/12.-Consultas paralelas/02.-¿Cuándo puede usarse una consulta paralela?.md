Hay varios ajustes que pueden hacer que el planificador de consultas  no genere un plan de consultas paralelo bajo ninguna circunstancia. Para que cualquier plan de consulta paralelo se genere, los siguientes  ajustes deben ser configurados como se indica.

- Debe [max_parallel_workers_per_gather](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER)establecerse un valor superior al cero. Este es un caso especial del principio más  general de que no se deben utilizar más trabajadores que el número  configurado a través de `max_parallel_workers_per_gather`.

Además, el sistema no debe funcionar en modo de un solo usuario.  Dado que todo el sistema de bases de datos funciona como un solo proceso en esta situación, no habrá trabajadores de antecedentes disponibles.

Incluso cuando en general es posible que se generen planes de  consulta paralela, el planificador no los generará para una consulta  dada si alguno de los siguientes son ciertos:

- La consulta escribe cualquier dato o bloquea cualquier fila  de bases de datos. Si una consulta contiene una operación que modifica  la base de datos, ya sea en el nivel superior o dentro de un CTE, no se  generarán planes paralelos para esa consulta. Como excepción, los  siguientes comandos, que crean una nueva tabla y la pueblan, pueden  utilizar un plan paralelo para el subyacente  `SELECT`parte de la consulta:
  - `CREATE TABLE ... AS`
  - `SELECT INTO`
  - `CREATE MATERIALIZED VIEW`
  - `REFRESH MATERIALIZED VIEW`
- La consulta podría ser suspendida durante la ejecución. En  cualquier situación en la que el sistema piense que puede ocurrir una  ejecución parcial o incremental, no se genera ningún plan paralelo. Por  ejemplo, un cursor creado usando [DECLARE CURSOR](https://www.postgresql.org/docs/current/sql-declare.html) nunca usará un plan paralelo. Del mismo modo, un bucle PL/pgSQL de la forma  `FOR x IN query LOOP .. END LOOP`nunca usará un plan paralelo, porque el sistema de consultas paralelas es  incapaz de verificar que el código en el bucle es seguro de ejecutar  mientras la consulta paralela está activa.
- La consulta utiliza cualquier función marcada `PARALLEL UNSAFE`. La mayoría de las funciones definidas en el sistema son `PARALLEL SAFE`, pero las funciones definidas por el usuario están marcadas  `PARALLEL UNSAFE`por defecto. Véase el debate de [la sección 15](https://www.postgresql.org/docs/current/parallel-safety.html).4.
- La consulta está corrida dentro de otra consulta que ya es  paralela. Por ejemplo, si una función llamada por una consulta paralela  emite una consulta SQL misma, esa consulta nunca usará un plan paralelo. Se trata de una limitación de la aplicación actual, pero puede no ser  deseable eliminar esta limitación, ya que podría dar lugar a una sola  consulta utilizando un gran número de procesos.

Incluso cuando se genera un plan de consultas paralelas para una  consulta particular, hay varias circunstancias en las que será imposible ejecutar ese plan en paralelo en el momento de la ejecución. Si esto  ocurre, el líder ejecutará la parte del plan por debajo de la  `Gather`nodo por sí solo, casi como si el  `Gather`El nodo no estaba presente. Esto sucederá si se cumple alguna de las siguientes condiciones:

- No se puede obtener trabajadores de antecedentes debido a la limitación de que el número total de trabajadores de origen no puede exceder los [procesos](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES) de [mayor trabajo](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES).
- No se puede obtener trabajadores de antecedentes debido a la limitación de que el número total de trabajadores de origen lanzados a efectos de  consulta paralela no puede exceder de los [trabajadores de máximas](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS).
- El cliente envía un mensaje de ejecución con un conteo de búsqueda sin cero. Véase la discusión del [protocolo de consulta ampliada](https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY). Dado que [libpq](https://www.postgresql.org/docs/current/libpq.html) actualmente no proporciona ninguna manera de enviar un mensaje de este  tipo, esto sólo puede ocurrir cuando se utiliza un cliente que no confía en libpq. Si esto es una ocurrencia frecuente, puede ser una buena idea establecer a [max_parallel_workers_per_gather](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER)cero en sesiones donde es probable que se genere planes de consulta que pueden ser subópties cuando se ejecuten serialmente.