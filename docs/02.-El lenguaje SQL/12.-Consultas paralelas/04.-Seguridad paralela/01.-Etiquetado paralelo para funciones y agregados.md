El planificador no puede determinar automáticamente si una función  definida por el usuario o agregado es seguro paralelo, restringido  paralelo o inseguro paralelo, porque esto requeriría predecir cada  operación que la función podría realizar. En general, esto equivale al  problema de la relación y, por lo tanto, imposible. Incluso para  funciones simples donde podría estar bien hecho, no lo intentamos, ya  que esto sería caro y propenso a errores. En cambio, se supone que todas las funciones definidas por el usuario son inseguras paralelas a menos  que se marque otra cosa. Cuando se utiliza [CREATE FUNCTION](https://www.postgresql.org/docs/current/sql-createfunction.html) o [ALTER FUNCTION](https://www.postgresql.org/docs/current/sql-alterfunction.html), las marcas se pueden configurar especificando `PARALLEL SAFE`, `PARALLEL RESTRICTED`, o  `PARALLEL UNSAFE`según corresponda. Cuando se utiliza [CREATE AGGREGATE](https://www.postgresql.org/docs/current/sql-createaggregate.html), el  `PARALLEL`la opción se puede especificar con `SAFE`, `RESTRICTED`, o  `UNSAFE`como el valor correspondiente.

Funciones y agregados deben marcarse  `PARALLEL UNSAFE`si escriben a la base de datos, acceden a secuencias, cambian el estado de transacción incluso temporalmente (por ejemplo, una función PL/pgSQL  que establece un  `EXCEPTION`bloquear para atrapar errores, o realizar cambios persistentes en la  configuración. Del mismo modo, las funciones deben estar marcadas  `PARALLEL RESTRICTED`si acceden a mesas temporales, estado de conexión al cliente, cursores,  declaraciones preparadas o varios estados locales de backend que el  sistema no puede sincronizarse entre los trabajadores. Por ejemplo,  `setseed`y  `random`están restringidos por esta última razón.

En general, si una función está etiquetada como segura cuando  está restringida o es insegura, o si está etiquetada como restringida  cuando es de hecho insegura, puede lanzar errores o producir respuestas  incorrectas cuando se utiliza en una consulta paralela. Las funciones de idioma C podrían en teoría mostrar un comportamiento totalmente  indefinido si se etiqueta mal, ya que no hay manera de que el sistema se proteja contra código C arbitrario, pero en casos muy probables el  resultado no será peor que para cualquier otra función. Si tienes dudas, es mejor etiquetar las funciones como `UNSAFE`.

Si una función ejecutada dentro de un trabajador paralelo  adquiere cerrajas que no están en manos del líder, por ejemplo  consultando una tabla no referenciada en la consulta, esas cerrajas  serán liberadas a la salida del trabajador, no al final de la  transacción. Si escribes una función que hace esto, y esta diferencia de comportamiento es importante para ti, marque funciones tales como  `PARALLEL RESTRICTED`para asegurarse de que ejecuten sólo en el líder.

Tenga en cuenta que el planificador de consultas no considera  aplazar la evaluación de funciones restringidas paralelas o agregados  involucrados en la consulta con el fin de obtener un plan superior. Así, por ejemplo, si a  `WHERE`La cláusula aplicada a una tabla en particular es paralela, el  planificador de consultas no considerará realizar un escaneo de esa  tabla en la parte paralela de un plan. En algunos casos, sería posible  (y tal vez incluso eficiente) incluir el escaneo de esa tabla en la  parte paralela de la consulta y aplazar la evaluación de la  `WHERE`cláusula para que ocurra por encima de la  `Gather`Nodo. Sin embargo, el planificador no lo hace.