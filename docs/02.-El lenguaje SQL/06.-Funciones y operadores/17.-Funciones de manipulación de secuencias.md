Esta sección describe funciones para operar en *objetos* de *secuencia*, también llamados generadores de secuencia o simplemente secuencias. Los objetos de secuencia son mesas especiales de una sola fila creadas con [CREATE SEQUENCE](https://www.postgresql.org/docs/current/sql-createsequence.html). Los objetos de secuencia se utilizan comúnmente para generar  identificadores únicos para las filas de una tabla. Las funciones de  secuencia, enumeradas en [la Tabla 9.52](https://www.postgresql.org/docs/current/functions-sequence.html#FUNCTIONS-SEQUENCE-TABLE), proporcionan métodos simples y multiusuarios para obtener sucesivos valores de secuencia de objetos de secuencia.

**Cuadro 9.52. Funciones de secuencia**

| Función              Descripción                             |
| ------------------------------------------------------------ |
| `nextval`(  `regclass`) . `bigint`              Avance el objeto de secuencia a su siguiente valor y  devuelve ese valor. Esto se hace atómicamente: incluso si se ejecutan  varias sesiones  `nextval`concurrentemente, cada uno recibirá con seguridad un valor de secuencia distinto. Si el  objeto de secuencia ha sido creado con parámetros por defecto, sucesivos  `nextval`Las  llamadas devolverán valores sucesivos a partir de 1. Otros  comportamientos se pueden obtener utilizando parámetros apropiados en el comando [CREATE SEQUENCE](https://www.postgresql.org/docs/current/sql-createsequence.html).              Esta función requiere  `USAGE`o o  `UPDATE`privilegio en la secuencia. |
| `setval`( `regclass`,  `bigint`[,  `boolean`] . `bigint`              Establece el valor actual del objeto de secuencia, y opcionalmente su  `is_called`- bandera. La forma de dos parámetros establece la secuencia  `last_value`campo al valor especificado y fija su  `is_called`campo a `true`, lo que significa que el siguiente  `nextval`avanzará en la secuencia antes de devolver un valor. El valor que se comunicará por  `currval`se establece también al valor especificado. En la forma de tres parámetros,  `is_called`puede ser configurado a cualquiera de los dos  `true`o o `false`.  `true`tiene el mismo efecto que la forma de dos parámetros. Si está listo `false`, el siguiente  `nextval`devolverá exactamente el valor especificado, y el avance de secuencias comienza con el siguiente `nextval`. Además, el valor comunicado por  `currval`no se ha cambiado en este caso. Por ejemplo,              `SELECT setval('myseq', 42); *Siguiente  `nextval`regresará 43* SELECT setval('myseq', 42, true); *Iguo que arriba* SELECT setval('myseq', 42, falso); *Siguiente  `nextval`regresará 42*`              El resultado devuelto por  `setval`es sólo el valor de su segundo argumento.              Esta función requiere  `UPDATE`privilegio en la secuencia. |
| `currval`(  `regclass`) . `bigint`              Devuelve el valor obtenido recientemente por  `nextval`para esta secuencia en el actual período de sesiones. (Se informa de un error si  `nextval`Nunca se ha llamado a esta secuencia en esta sesión.) Debido a que esto está  devolviendo un valor de sesión-local, da una respuesta predecible si  otras sesiones han ejecutado o no  `nextval`desde el actual período de sesiones.              Esta función requiere  `USAGE`o o  `SELECT`privilegio en la secuencia. |
| `lastval`() `bigint`              Devuelve el valor devuelto más recientemente por  `nextval`en el actual período de sesiones. Esta función es idéntica a `currval`, excepto que en lugar de tomar el nombre de la secuencia como argumento se refiere a cualquier secuencia  `nextval`Se aplicó más recientemente en el actual período de sesiones. Es un error llamar  `lastval`si  `nextval`Todavía no se ha convocado en el actual período de sesiones.              Esta función requiere  `USAGE`o o  `SELECT`privilegio en la última secuencia usada. |

### Precaución

Para evitar bloquear las transacciones simultáneas que obtienen números de la misma secuencia, el valor obtenido por  `nextval`no se reclama para su reutilización si la transacción de llamada aborta  más tarde. Esto significa que los abortos de transacciones o fallos de  bases de datos pueden resultar en lagunas en la secuencia de valores  asignados. Eso también puede suceder sin que una transacción aborte. Por ejemplo a  `INSERT`con un  `ON CONFLICT`cláusula calculará la tupla de la que se pueda insertar, incluyendo hacer lo requerido  `nextval`llamadas, antes de detectar cualquier conflicto que le hiciera seguir el  `ON CONFLICT`Regla en lugar de eso. Por lo tanto, los objetos de secuencia PostgreSQL *no se pueden utilizar para obtener gaplesssecuencias sin huecos*.

Asimismo, los cambios de estado de secuencia realizados por  `setval`son inmediatamente visibles a otras transacciones, y no se deshacen si la transacción de llamada retrocede.

Si el grupo de base de datos se bloquea antes de cometer una transacción que contiene un  `nextval`o o  `setval`Llama, el cambio de estado de secuencia podría no haber hecho su camino hacia  el almacenamiento persistente, por lo que no está claro si la secuencia  tendrá su estado original o actualizado después de que el cúmulo se  reinicia. Esto es inofenable para el uso de la secuencia dentro de la  base de datos, ya que otros efectos de transacciones no comprometidas  tampoco serán visibles. Sin embargo, si desea utilizar un valor de  secuencia para fines persistentes de la base de datos externo, asegúrese de que el  `nextval`Se ha cometido una llamada antes de hacerlo.

La secuencia a operar por una función de secuencia se especifica por un  `regclass`argument, que es simplemente la OID de la secuencia en el  `pg_class`catálogo de sistemas. Sin embargo, no tienes que buscar el OID a mano, desde el  `regclass`El convertidor de entradas del tipo de datos hará el trabajo para usted. Véase [la sección 8.19](https://www.postgresql.org/docs/current/datatype-oid.html) para más detalles.