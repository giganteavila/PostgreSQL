Las funciones que se muestran en [la Tabla 9.95](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-REPLICATION-TABLE) son para controlar e interactuar con las características de replicación. Véanse [la sección 27.2.5](https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION), [sección 27.2.](https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS)66 y [el capítulo 50](https://www.postgresql.org/docs/current/replication-origins.html) para información sobre las características subyacentes. El uso de  funciones para el origen de replicación sólo se permite al superusuario  por defecto, pero se le puede permitir a otros usuarios mediante el uso  de la  `GRANT`comando. El uso de funciones para las ranuras de replicación se limita a los superusuarios y usuarios que tienen  `REPLICATION`privilegio.

Muchas de estas funciones tienen comandos equivalentes en el protocolo de replicación; véase [la Sección 55](https://www.postgresql.org/docs/current/protocol-replication.html).4.

Las funciones descritas en la [sección 9.27.3](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-BACKUP), [sección 9.27.4](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-RECOVERY-CONTROL) y [en la sección 9.27.5](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION) también son pertinentes para la reproducción.

**Cuadro 9.95. Funciones de gestión de la replicación**

| Función                Descripción                           |
| ------------------------------------------------------------ |
| `pg_create_physical_replication_slot`(   *`slot_name`*`name`[,  *`immediately_reserve`*`boolean`,   *`temporary`*`boolean`] .  `record`(  *`slot_name`*`name`,   *`lsn`*`pg_lsn`)                Crea una nueva ranura de replicación física nombrada *`slot_name`*. El segundo parámetro opcional, cuando `true`, especifica que la  LSNpara esta ranura de replicación se reserva inmediatamente; de lo contrario la  LSNestá reservado en la primera conexión desde un cliente de replicación en  streaming. Los cambios de estanqueamiento a partir de una ranura física  sólo son posibles con el protocolo de replicación de streaming. ver [Sección 55](https://www.postgresql.org/docs/current/protocol-replication.html).4. El tercer parámetro opcional, *`temporary`*, cuando se establece como verdadero, especifica que la ranura no debe  almacenarse permanentemente en el disco y sólo está destinada a ser  utilizado en la sesión actual. Las franjas horaras temporales también se liberan por cualquier error. Esta función corresponde al comando  protocolo de replicación `CREATE_REPLICATION_SLOT ... PHYSICAL`. |
| `pg_drop_replication_slot`(   *`slot_name`*`name`) . `void`                Suelta la ranura de replicación física o lógica llamada *`slot_name`*. Igual que el comando de protocolo de replicación `DROP_REPLICATION_SLOT`. Para las ranuras lógicas, esto debe llamarse mientras está conectado a la misma base de datos en la que se creó la ranura. |
| `pg_create_logical_replication_slot`(  *`slot_name`*`name`,   *`plugin`*`name`[,  *`temporary`*`boolean`,   *`twophase`*`boolean`] .  `record`(  *`slot_name`*`name`,   *`lsn`*`pg_lsn`)                Crea una nueva ranura de replicación lógica (decodificación) llamada  *`slot_name`*utilizando el plugin de salida *`plugin`*. El tercer parámetro opcional, *`temporary`*, cuando se establece como verdadero, especifica que la ranura no debe  almacenarse permanentemente en el disco y sólo está destinada a ser  utilizado en la sesión actual. Las franjas horaras temporales también se liberan por cualquier error. El cuarto parámetro opcional, *`twophase`*, cuando se establece como verdadero, especifica que la decodificación de las transacciones preparadas está habilitada para esta ranura. Una  llamada a esta función tiene el mismo efecto que el comando protocolo de replicación `CREATE_REPLICATION_SLOT ... LOGICAL`. |
| `pg_copy_physical_replication_slot`(  *`src_slot_name`*`name`,   *`dst_slot_name`*`name`[,   *`temporary`*`boolean`] .  `record`(  *`slot_name`*`name`,   *`lsn`*`pg_lsn`)                Copias de una ranura de replicación física existente llamada  *`src_slot_name`*a una ranura de replicación física nombrada *`dst_slot_name`*. La ranura física copiada comienza a reservar WAL desde el mismo  LSNcomo la ranura de la fuente.  *`temporary`*es opcional. Si  *`temporary`*se omite, se utiliza el mismo valor que la ranura de origen. |
| `pg_copy_logical_replication_slot`(  *`src_slot_name`*`name`,   *`dst_slot_name`*`name`[,   *`temporary`*`boolean`[,   *`plugin`*`name`]] ) .  `record`(  *`slot_name`*`name`,   *`lsn`*`pg_lsn`)                Copias de una ranura de replicación lógica existente llamada  *`src_slot_name`*a una ranura de replicación lógica nombrada *`dst_slot_name`*, cambiando opcionalmente el plugin de salida y la persistencia. La ranura lógica copiada comienza desde el mismo  LSNcomo la ranura lógica de origen. Ambos  *`temporary`*y  *`plugin`*son opcionales; si se omiten, se utilizan los valores de la ranura de origen. |
| `pg_logical_slot_get_changes`(  *`slot_name`*`name`,  *`upto_lsn`*`pg_lsn`,  *`upto_nchanges`*`integer`,    `VARIADIC`*`options`*`text[]`) .  `setof record`(  *`lsn`*`pg_lsn`,  *`xid`*`xid`,   *`data`*`text`)                Devuelve cambios en la ranura *`slot_name`*, a partir del punto desde el que se han consumido los cambios en último lugar. Si  *`upto_lsn`*y  *`upto_nchanges`*son NULL, la decodificación lógica continuará hasta el final de WAL. Si  *`upto_lsn`*no es NóLL, la decodificación incluirá únicamente las transacciones que se comprometan antes de la LSN especificada. Si  *`upto_nchanges`*no-NULL, la decodificación se detendrá cuando el número de filas producidas por  decodificación exceda del valor especificado. Tenga en cuenta, sin  embargo, que el número real de filas devueltas puede ser mayor, ya que  este límite sólo se comprueba después de añadir las filas producidas al  decodificar cada nueva transacción commit. |
| `pg_logical_slot_peek_changes`(  *`slot_name`*`name`,  *`upto_lsn`*`pg_lsn`,  *`upto_nchanges`*`integer`,    `VARIADIC`*`options`*`text[]`) .  `setof record`(  *`lsn`*`pg_lsn`,  *`xid`*`xid`,   *`data`*`text`)                Se comporta como el  `pg_logical_slot_get_changes()`función, excepto que los cambios no se consumen; es decir, serán devueltos de nuevo en futuras llamadas. |
| `pg_logical_slot_get_binary_changes`(  *`slot_name`*`name`,  *`upto_lsn`*`pg_lsn`,  *`upto_nchanges`*`integer`,    `VARIADIC`*`options`*`text[]`) .  `setof record`(  *`lsn`*`pg_lsn`,  *`xid`*`xid`,   *`data`*`bytea`)                Se comporta como el  `pg_logical_slot_get_changes()`función, excepto que los cambios se devuelven como `bytea`. |
| `pg_logical_slot_peek_binary_changes`(  *`slot_name`*`name`,  *`upto_lsn`*`pg_lsn`,  *`upto_nchanges`*`integer`,    `VARIADIC`*`options`*`text[]`) .  `setof record`(  *`lsn`*`pg_lsn`,  *`xid`*`xid`,   *`data`*`bytea`)                Se comporta como el  `pg_logical_slot_peek_changes()`función, excepto que los cambios se devuelven como `bytea`. |
| `pg_replication_slot_advance`(  *`slot_name`*`name`,   *`upto_lsn`*`pg_lsn`) .  `record`(  *`slot_name`*`name`,   *`end_lsn`*`pg_lsn`)                Avances la posición confirmada actual de una ranura de replicación nombrada *`slot_name`*. La ranura no se moverá hacia atrás, y no se moverá más allá de la  ubicación de inserción actual. Devuelve el nombre de la ranura y la  posición real a la que se adelanó. La información actualizada sobre la  posición de franja horar que se escribe en el siguiente punto de control si se hace algún avance. Así que en el caso de un accidente, la ranura  puede volver a una posición anterior. |
| `pg_replication_origin_create`(   *`node_name`*`text`) . `oid`                Crea un origen de replicación con el nombre externo dado, y devuelve el ID interno asignado a él. |
| `pg_replication_origin_drop`(   *`node_name`*`text`) . `void`                Elimina un origen de replicación creado previamente, incluyendo cualquier progreso de repetición asociado. |
| `pg_replication_origin_oid`(   *`node_name`*`text`) . `oid`                Busca un origen de replicación por su nombre y devuelve el ID interno. Si no se encuentra tal origen de replicación,  `NULL`es devuelto. |
| `pg_replication_origin_session_setup`(   *`node_name`*`text`) . `void`                Marca la sesión actual como repetición desde el  origen dado, permitiendo que se rastree el progreso de la repetición.  Sólo se puede utilizar si actualmente no se selecciona ningún origen.  Uso  `pg_replication_origin_session_reset`para deshacer. |
| `pg_replication_origin_session_reset`() `void`                Cancela los efectos de `pg_replication_origin_session_setup()`. |
| `pg_replication_origin_session_is_setup`() `boolean`                Devuelve cierto si se ha seleccionado un origen de replicación en la sesión actual. |
| `pg_replication_origin_session_progress`(   *`flush`*`boolean`) . `pg_lsn`                Devuelve la ubicación de repetición para el origen de replicación seleccionado en la sesión actual. El parámetro  *`flush`*determina si la transacción local correspondiente estará garantizada a haber sido enrojecida o no en el disco. |
| `pg_replication_origin_xact_setup`(  *`origin_lsn`*`pg_lsn`,   *`origin_timestamp`*`timestamp with time zone`) . `void`                Marca la transacción actual como repetición de una transacción que se ha comprometido en el momento dado  LSNy marca de tiempo. Sólo se puede llamar cuando se ha seleccionado un origen de replicación utilizando `pg_replication_origin_session_setup`. |
| `pg_replication_origin_xact_reset`() `void`                Cancela los efectos de `pg_replication_origin_xact_setup()`. |
| `pg_replication_origin_advance`(  *`node_name`*`text`,   *`lsn`*`pg_lsn`) . `void`                Estace el progreso de la replicación para el nodo  dado a la ubicación dada. Esto es principalmente útil para configurar la ubicación inicial, o establecer una nueva ubicación después de los  cambios de configuración y similares. Tenga en cuenta que el uso  descuidado de esta función puede conducir a datos replicados de manera  inconsistente. |
| `pg_replication_origin_progress`(  *`node_name`*`text`,   *`flush`*`boolean`) . `pg_lsn`                Devuelve la ubicación de repetición para el origen de replicación dado. El parámetro  *`flush`*determina si la transacción local correspondiente estará garantizada a haber sido enrojecida o no en el disco. |
| `pg_logical_emit_message`(  *`transactional`*`boolean`,  *`prefix`*`text`,   *`content`*`text`) . `pg_lsn`                 `pg_logical_emit_message`(  *`transactional`*`boolean`,  *`prefix`*`text`,   *`content`*`bytea`) . `pg_lsn`                Emite un mensaje lógico de decodificación. Esto se  puede utilizar para pasar mensajes genéricos a los plugins de  decodificación lógico a través de WAL. El  *`transactional`*El parámetro especifica si el mensaje debe ser parte de la transacción  actual, o si debe ser escrito inmediatamente y decodificado tan pronto  como el decodificador lógico lea el registro. El  *`prefix`*El parámetro es un prefijo textual que se puede utilizar por los plugins  lógicos decodificación para reconocer fácilmente los mensajes que son  interesantes para ellos. El  *`content`*El parámetro es el contenido del mensaje, dado en texto o en forma binaria. |